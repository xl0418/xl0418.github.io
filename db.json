{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/Hacker/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/Hacker/source/images/icon-heart.svg","path":"images/icon-heart.svg","modified":0,"renderable":1},{"_id":"themes/Hacker/source/css/base/normalize.css","path":"css/base/normalize.css","modified":0,"renderable":1},{"_id":"themes/Hacker/source/css/components/article.styl","path":"css/components/article.styl","modified":0,"renderable":1},{"_id":"themes/Hacker/source/css/components/archive.styl","path":"css/components/archive.styl","modified":0,"renderable":1},{"_id":"themes/Hacker/source/css/components/categories.styl","path":"css/components/categories.styl","modified":0,"renderable":1},{"_id":"themes/Hacker/source/css/components/footer.styl","path":"css/components/footer.styl","modified":0,"renderable":1},{"_id":"themes/Hacker/source/css/components/header.styl","path":"css/components/header.styl","modified":0,"renderable":1},{"_id":"themes/Hacker/source/css/components/layout.styl","path":"css/components/layout.styl","modified":0,"renderable":1},{"_id":"themes/Hacker/source/css/components/icon.styl","path":"css/components/icon.styl","modified":0,"renderable":1},{"_id":"themes/Hacker/source/css/components/pagination.styl","path":"css/components/pagination.styl","modified":0,"renderable":1},{"_id":"themes/Hacker/source/css/components/responsive.styl","path":"css/components/responsive.styl","modified":0,"renderable":1},{"_id":"themes/Hacker/source/css/components/syntax.styl","path":"css/components/syntax.styl","modified":0,"renderable":1},{"_id":"themes/Hacker/source/css/components/tags.styl","path":"css/components/tags.styl","modified":0,"renderable":1},{"_id":"source/about/Liang_CV.pdf","path":"about/Liang_CV.pdf","modified":0,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"4028ee89983dd9af4e9fd5616787170c6ab26614","modified":1663380245107},{"_id":"source/._.DS_Store","hash":"c1f453f8a35c6a455bc2c9d53ef88020fc2d5e82","modified":1663380245107},{"_id":"source/about/._index.md","hash":"b784cd5823dddd79d915424573826522906e675d","modified":1663380245657},{"_id":"source/categories/._index.md","hash":"b32c347609a791a4ce2dfb3464084b3e99ff2865","modified":1663380245658},{"_id":"source/about/index.md","hash":"00ee51c06f4c28b90796d73b1277a45c51d0d60c","modified":1663380245658},{"_id":"source/categories/index.md","hash":"2b673bc3d1d47ed013ab17899ec414a491c9197b","modified":1663390376210},{"_id":"source/_posts/.DS_Store","hash":"d6f562f6696e67875664e49cbcc98f907c34cabd","modified":1663380245108},{"_id":"source/_posts/._.DS_Store","hash":"c1f453f8a35c6a455bc2c9d53ef88020fc2d5e82","modified":1663380245108},{"_id":"source/_posts/._2018-10-22-IntrotoPro1.md","hash":"7b2b9bb545a70ff2f6e0d8857e4d2e70c8e038bb","modified":1663380245108},{"_id":"source/_posts/._2018-10-23-Blogging tech.md","hash":"13b0f08a91a2afcdd17201b03f24d2446e18415d","modified":1663380245108},{"_id":"source/_posts/._2018-10-24-derivingFPequ.md","hash":"d803bf74fbe0c3c846491cc8900198c4d24b7cb1","modified":1663380245108},{"_id":"source/_posts/._2018-10-24-phylo2Lfunction.md","hash":"410faaafa804e95a1479a9c8630eefab3e1911c5","modified":1663380245108},{"_id":"source/_posts/._2018-10-24-pruneLfunction.md","hash":"27cdac63cc641cc808f6e661674aafa9c0b69fbf","modified":1663380245108},{"_id":"source/_posts/._2018-10-25-PLSR.md","hash":"688099384f0f1251a7c41f617f683df45658e182","modified":1663380245108},{"_id":"source/_posts/._2018-10-29-sed.md","hash":"bdd2692f618799af044173ec9e6a2f08b1e47d69","modified":1663380245109},{"_id":"source/_posts/._2018-11-26-Rupdateallpackages.md","hash":"d015ffeeac287585a400c0af908d73f8d102d065","modified":1663380245109},{"_id":"source/_posts/._2018-11-29-color.md","hash":"0afbb31df33c99e17f142dceb916a7fd03b6988a","modified":1663380245109},{"_id":"source/_posts/._2018-11-30-SMCplots.md","hash":"9a9bb628da527dcf73aec1da086f7e9fcf6ff3f1","modified":1663380245109},{"_id":"source/_posts/._2018-12-05-ggradar2.md","hash":"2692f682e6a1062b80d45d70e70a4ac203bdc009","modified":1663380245109},{"_id":"source/_posts/._2018-12-07-ggradar2helpdocument.md","hash":"fad5b139ff9aa5d7bd539eaf1161a9634d923129","modified":1663380245109},{"_id":"source/_posts/._2019-01-04-PyCUDAseries1.md","hash":"b6c3ff00b9ee3cea72dcd743033e96e1c81a4d6e","modified":1663380245109},{"_id":"source/_posts/._2019-01-10sed2.md","hash":"905057f37b7992bc90a1ab8eec81109212b13fac","modified":1663380245109},{"_id":"source/_posts/._2019-01-14-PyCUDAseries2.md","hash":"38b0097f8ba08aa85239bd1b71435fb4114e7c65","modified":1663380245109},{"_id":"source/_posts/._2019-01-21-PyCUDAseries3.md","hash":"85560c26ece770b6dd3644ae678b9cf13597d936","modified":1663380245109},{"_id":"source/_posts/._2019-02-01-Machinelearningseries1.md","hash":"7148292116276bd4a06e5d234046c6018e26bbfe","modified":1663380245109},{"_id":"source/_posts/._2019-02-08-Machinelearningseries2.md","hash":"974024e1a5fdd1ae024c57d272970454dc46f57a","modified":1663380245109},{"_id":"source/_posts/._2019-03-20-readdatadon.md","hash":"5db0d3cc74f059615de427d00aaa1685a6b3f9ec","modified":1663380245110},{"_id":"source/_posts/._2019-06-21-ABCalgorithm.md","hash":"f3f1ffec1a8db956f919ff16a9c6377bc6865895","modified":1663380245110},{"_id":"source/_posts/._2019-06-21-TPmodel.md","hash":"39e769e2d611d2ee198606029bddf35eff1696a1","modified":1663380245110},{"_id":"source/_posts/._2020-03-09-GUI-traitevolution.md","hash":"554ba9f28ed597353bf610b5858c1ac68e6fae1b","modified":1663380245110},{"_id":"source/_posts/._2020-03-18-generalABC.md","hash":"ec4e4b3ebc46d3f2badca6028513208e46934480","modified":1663380245110},{"_id":"source/_posts/._2020-04-02-government&pandemic.md","hash":"6c7b9086cff0e678a5d575243b0abebcabb7be3b","modified":1663380245110},{"_id":"source/_posts/._2020-04-25-Covid_19.md","hash":"c0492a4e30899dc2f80c8e78cff9be1d13204bdd","modified":1663380245110},{"_id":"source/_posts/._2020-10-05-update.md","hash":"42c9b0fbdbc5fd663abb533b99f470f41fb4c9f4","modified":1663380245110},{"_id":"source/_posts/._2021-03-21-Blender.md","hash":"e7c7d85247fc1a1190df069c3a348fd13018fdac","modified":1663380245110},{"_id":"source/_posts/._hello-world.md","hash":"ed61fc13ea5267c38bb46e3160e40d0c39e5f34c","modified":1663380245111},{"_id":"source/_posts/2018-10-22-IntrotoPro1.md","hash":"7b337fff41d944f2a3cf536c1b1901ed0b2347b6","modified":1663390337351},{"_id":"source/_posts/2018-10-23-Blogging tech.md","hash":"58c70721380dbc743b993ed660ae48d896a41d46","modified":1663380245116},{"_id":"source/_posts/2018-10-24-derivingFPequ.md","hash":"2597623eee05defc277db33941ddb14e667d3031","modified":1663380245116},{"_id":"source/_posts/2018-10-24-phylo2Lfunction.md","hash":"7d233e5d64358f79445310ddd700d58ce0fdb969","modified":1663380245116},{"_id":"source/_posts/2018-10-24-pruneLfunction.md","hash":"a2230964c7e0ea9a04a152626eb276795cb84b4a","modified":1663380245116},{"_id":"source/_posts/2018-10-25-PLSR.md","hash":"3c0e326430072a4c5a643affe35f89629ade8064","modified":1663380245116},{"_id":"source/_posts/2018-10-29-sed.md","hash":"b7243a3946bc087db18c870aefb389110b84e232","modified":1663380245116},{"_id":"source/_posts/2018-11-26-Rupdateallpackages.md","hash":"bdf58c5a81761e9c7f644c6079cb5d4caed981de","modified":1663380245117},{"_id":"source/_posts/2018-11-29-color.md","hash":"1cadd38100be9600c4e50c252bcb443a4ae9c9cf","modified":1663380245117},{"_id":"source/_posts/2018-11-30-SMCplots.md","hash":"b8fe2bee364a1282d6cdfe06c6fd57181fa4cf41","modified":1663380245118},{"_id":"source/_posts/2018-12-05-ggradar2.md","hash":"14e04cf38b5ca317461227a577ce473e032d9919","modified":1663380245118},{"_id":"source/_posts/2018-12-07-ggradar2helpdocument.md","hash":"6b54d1416e0c758bd35d8b4c7f8a2dd96a3b6874","modified":1663380245121},{"_id":"source/_posts/2019-01-04-PyCUDAseries1.md","hash":"8bc7aaa8a398e0ebe4486a93eef6afddcd993328","modified":1663380245121},{"_id":"source/_posts/2019-01-10sed2.md","hash":"fd6f024132fa527c57d56167074cf2f73ffb1b05","modified":1663380245123},{"_id":"source/_posts/2019-01-14-PyCUDAseries2.md","hash":"62db8be9b81093e363c591f88bc1e5d8b77faef7","modified":1663380245124},{"_id":"source/_posts/2019-01-21-PyCUDAseries3.md","hash":"e717fbea7e80d9fb734fcf29f08c42858b358c89","modified":1663380245125},{"_id":"source/_posts/2019-02-01-Machinelearningseries1.md","hash":"a0a6469209c2b66cbfb113ced81b453fba146889","modified":1663380245125},{"_id":"source/_posts/2019-02-08-Machinelearningseries2.md","hash":"ef1be343bd55141ef1793935b8363e810d3f49c5","modified":1663380245126},{"_id":"source/_posts/2019-03-20-readdatadon.md","hash":"bf216f6999e54e47204b3d18fa08762c3efe856a","modified":1663380245178},{"_id":"source/_posts/2019-06-21-ABCalgorithm.md","hash":"cbe6c7d0cd4d9f4f9f5a700a093d51778cc778bc","modified":1663380245179},{"_id":"source/_posts/2019-06-21-TPmodel.md","hash":"e631e49c424228d8f87f762042c707b2d3755b2d","modified":1663380245231},{"_id":"source/_posts/2020-03-09-GUI-traitevolution.md","hash":"5dd73808c6f4f5e1bca1ec611f4be50b5c5aab1a","modified":1663380245591},{"_id":"source/_posts/2020-03-18-generalABC.md","hash":"9440e517fa1f7b0f45ea69705a851653f509fece","modified":1663380245592},{"_id":"source/_posts/2020-04-02-government&pandemic.md","hash":"6f91701ab5f7d9d0efe09f76e8de4b8725c73de3","modified":1663380245603},{"_id":"source/_posts/2020-04-25-Covid_19.md","hash":"b2a74f5b3e59d20b3bc121c098f123a4b916668a","modified":1663380245603},{"_id":"source/_posts/2020-10-05-update.md","hash":"9d407fbd0bde10e4d671ed736dbdb7045b37e921","modified":1663380245603},{"_id":"source/_posts/2021-03-21-Blender.md","hash":"b1d540d8d3b79e372457162432604fdea34fa225","modified":1663387180510},{"_id":"source/_posts/hello-world.md","hash":"a5c94547c94d791b7a14aa7f04a89d1ac042239b","modified":1663380245657},{"_id":"source/tags/index.md","hash":"4b6a485b9066018e2589179270e7b91920a2f772","modified":1663390380641},{"_id":"source/_posts/2018-10-29-sed/d.png","hash":"6bdc800119bc8de7461548b9d94b5f776c43a345","modified":1663380245117},{"_id":"source/_posts/2018-10-29-sed/ds.png","hash":"965d5418e7f621023a969770a36e2702a117ed90","modified":1663380245117},{"_id":"source/_posts/2018-10-29-sed/rawdata.png","hash":"504d3898506b182f7ffb5b6cb19618dde1154b0e","modified":1663380245117},{"_id":"source/_posts/2018-11-29-color/col1.png","hash":"cbf10523cc8e07e62bef59195000b0f541cd581f","modified":1663380245117},{"_id":"source/_posts/2018-11-29-color/col2.png","hash":"3dd942d4972d112beb80a25fc3aef5c905a92b54","modified":1663380245117},{"_id":"source/_posts/2018-11-29-color/col3.png","hash":"1d83794811a02b4bdadab17f78c8275ad87f131f","modified":1663380245117},{"_id":"source/_posts/2018-11-29-color/col4.png","hash":"8e015d04d4090c8debb5eed1964595de0f368a5b","modified":1663380245118},{"_id":"source/_posts/2018-11-30-SMCplots/Rplot1.png","hash":"7b3ed1bb1002079cb8719e12f7d0e01a4098ae75","modified":1663380245118},{"_id":"source/_posts/2018-11-30-SMCplots/Rplot2.png","hash":"a4ace9d48b797039ce52da319ebf313b339b2e1e","modified":1663380245118},{"_id":"source/_posts/2018-12-05-ggradar2/fullscore.png","hash":"5c50cfa94f69d90edfb9561abf66f229c83eee50","modified":1663380245119},{"_id":"source/_posts/2018-12-05-ggradar2/lux.png","hash":"9ddc42a286d090bbe82e25d58cbd92c1d7347079","modified":1663380245119},{"_id":"source/_posts/2018-12-05-ggradar2/mini.png","hash":"18b7ec1f51059e5dd8e748c53d68a806daec38ea","modified":1663380245119},{"_id":"source/_posts/2018-12-05-ggradar2/multipleplots.png","hash":"2c0d8c8213f7775d680657810a17ecb3e48ed38d","modified":1663380245119},{"_id":"source/_posts/2018-12-05-ggradar2/multipleplotsbig.png","hash":"739c484223aa914606da7a43e93446af8e163388","modified":1663380245120},{"_id":"source/_posts/2018-12-05-ggradar2/nolegend.png","hash":"338d96bd8f0ccd7d26c8dd4e341b39362c64a04e","modified":1663380245120},{"_id":"source/_posts/2018-12-05-ggradar2/roundfill.png","hash":"7a6539ae5da9c90b8a62b37eed031cff190d7c9c","modified":1663380245120},{"_id":"source/_posts/2018-12-05-ggradar2/roundnofill.png","hash":"31bfb3f19b550723abcc32b6b7177982128c8830","modified":1663380245120},{"_id":"source/_posts/2018-12-05-ggradar2/straightfill.png","hash":"f0f6bfe7a10e8856cd45cff454aad0655692b18f","modified":1663380245120},{"_id":"source/_posts/2018-12-05-ggradar2/trend.png","hash":"580a0ab7b4449330b9425f722f196fffb82c9134","modified":1663380245121},{"_id":"source/_posts/2018-12-05-ggradar2/straightnofill.png","hash":"efa92f19754af10d469cf6675eb7a44e08e70eda","modified":1663380245120},{"_id":"source/_posts/2019-01-10sed2/mfiles.png","hash":"45a7ad5fb9fe1ab18105f988b18272269c0e549b","modified":1663380245123},{"_id":"source/_posts/2019-01-14-PyCUDAseries2/speedtest.png","hash":"c48054dc2ef38a8857227c55428dc68e185f841d","modified":1663380245125},{"_id":"source/_posts/2019-02-01-Machinelearningseries1/modelselection1.png","hash":"c119feddb57b38b5d364ce35082001d7d62dbd74","modified":1663380245125},{"_id":"source/_posts/2019-02-01-Machinelearningseries1/prediction_sample.png","hash":"cd4ff39cfafd41d0711a4f11a77df2c0277ce7f9","modified":1663380245126},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/1.png","hash":"08f6c16b529bc03ecf83c55de5d28d2ec737aad7","modified":1663380245126},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/10.png","hash":"b2656495f031e2eefcc8734ee589b1ab555f1c6e","modified":1663380245126},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/11.png","hash":"a92bd5f59fee6cf4c18e4c7778bb53c8853c9b27","modified":1663380245126},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/12.png","hash":"6b4b7c01e0a107e349be33d327ff4a828de3ad41","modified":1663380245127},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/16.png","hash":"a79170ae6a15e5fb2342f6c373121e17d76eed33","modified":1663380245127},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/17.png","hash":"58c3578da213026a6faf5236cef70d0de0df18e7","modified":1663380245128},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/13-15.png","hash":"4e6540b7dbbc1cecadc83b89205c4e249207f2d8","modified":1663380245127},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/18.png","hash":"fe7df21d74b9ac39988417271f71df0da3e14d46","modified":1663380245128},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/19-1.png","hash":"9a35d6438ea32257c73165fa5764e7f1555390ad","modified":1663380245128},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/19.png","hash":"747d05b0ea5814c72e57861034a59c4a63211a60","modified":1663380245128},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/2.png","hash":"2ad49fbdeb4f563edd0797d9a4d972a8839c9d55","modified":1663380245128},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/20.png","hash":"85329614886a4b196eb845f13bb3a0fffabb1489","modified":1663380245128},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/21.png","hash":"94ce999c4c85fa14d85ae219eb00f9fbc6c94c36","modified":1663380245128},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/22.png","hash":"07b7bd1f8775d6e41253f8a4b0ae8e696bbc6502","modified":1663380245129},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/23.png","hash":"839ecc43535c8c589a64aa7cc947ec88441f871a","modified":1663380245129},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/24.png","hash":"81ae1d4ec941ea54cf9457840d97557d0852b2e5","modified":1663380245129},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/25.png","hash":"cb29499e4d9341922f9d1e234068966d0b28fb73","modified":1663380245129},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/3.png","hash":"82ca237383cd0b4c6c69991218d5243fe95411dd","modified":1663380245129},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/4.png","hash":"f53c3a372ae9ae0a6e992e176ef35ccf8fd1160a","modified":1663380245129},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/5.png","hash":"4445bfdd3d0690432257608a790062f4d4ecfccf","modified":1663380245129},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/6.png","hash":"d28b9b8aed0df282c8921d57715c719b924e3a37","modified":1663380245129},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/78.png","hash":"1a55ed4d935acf4d99d095bd183364b02bb7182b","modified":1663380245130},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/9.png","hash":"21858569c261d689790e470dda6647388bbf6828","modified":1663380245130},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/9-1.png","hash":"dd5ccd15eab9ebd82ffb81322a9b543f28326dff","modified":1663380245130},{"_id":"source/_posts/2019-03-20-readdatadon/d.png","hash":"6bdc800119bc8de7461548b9d94b5f776c43a345","modified":1663380245179},{"_id":"source/_posts/2019-03-20-readdatadon/rewrittendata.png","hash":"52a13bcda911b3879916779e798250de59cd01ba","modified":1663380245179},{"_id":"source/_posts/2019-06-21-ABCalgorithm/Rplot2.png","hash":"a4ace9d48b797039ce52da319ebf313b339b2e1e","modified":1663380245230},{"_id":"source/_posts/2020-03-09-GUI-traitevolution/p1.png","hash":"51eee44eff5793b37c8e4206438a97cff6b47603","modified":1663380245591},{"_id":"source/_posts/2020-03-09-GUI-traitevolution/p3.png","hash":"2ce44cf24deb5e9d34abd78b7c93eea8e43cfc72","modified":1663380245592},{"_id":"source/_posts/2020-03-09-GUI-traitevolution/p2.png","hash":"74d01c3c8e6cb746289469f2602c303afa15857a","modified":1663380245592},{"_id":"source/_posts/2020-03-18-generalABC/Predict1.png","hash":"8fbdb67a9331ad9f7d467a4a486d039dd2f5e016","modified":1663380245593},{"_id":"source/_posts/2020-03-09-GUI-traitevolution/p4.png","hash":"c8d1a197ba7983f534e5f7818b3063c086c85eed","modified":1663380245592},{"_id":"source/_posts/2020-03-18-generalABC/Predict2.png","hash":"ac88d57a8405d71db8a98580cb7951bd55dcfb29","modified":1663380245593},{"_id":"source/_posts/2020-03-18-generalABC/data.png","hash":"2f1482534ce247a1e5ece239b01f6f5690d0b5cf","modified":1663380245594},{"_id":"source/_posts/2021-03-21-Blender/.DS_Store","hash":"a4324bbaa29331723e4a68581808703558d84225","modified":1663380245604},{"_id":"source/_posts/2021-03-21-Blender/._.DS_Store","hash":"c1f453f8a35c6a455bc2c9d53ef88020fc2d5e82","modified":1663380245604},{"_id":"source/_posts/2021-03-21-Blender/._Step1.png","hash":"4d9ac3770cf66ffc150a559900c0d5fd906a5d06","modified":1663380245604},{"_id":"source/_posts/2021-03-21-Blender/._Step2.png","hash":"d4c2c50f97fccef5b7002c1bee018f62d2c3dac4","modified":1663380245604},{"_id":"source/_posts/2021-03-21-Blender/._Step3.png","hash":"10930450499c75b663ef0f3205977bd490ba5447","modified":1663380245604},{"_id":"source/about/Liang_CV.pdf","hash":"3e1a7c3b61f72b6ce450db175b0d9f7dae0653d8","modified":1663380245658},{"_id":"source/_posts/2018-10-22-IntrotoPro1/Powertable.jpg","hash":"08373cf6112778618fd1a22a51e735a27a49c679","modified":1663380245113},{"_id":"source/_posts/2019-01-04-PyCUDAseries1/win10SDK.png","hash":"255648cb736a724d3623bf51d04bbdce05778edd","modified":1663380245123},{"_id":"source/_posts/2019-01-10sed2/rdatafiles.png","hash":"7c87f5b7820eb89deaf7a4250e942ef94b1bb53b","modified":1663380245124},{"_id":"source/_posts/2019-01-14-PyCUDAseries2/gridblockthread.png","hash":"31ad63d0cf3f0411ae70f29a71261f3e6642020e","modified":1663380245125},{"_id":"source/_posts/2020-03-18-generalABC/abc_scheme.png","hash":"462844b99697e9d935b97ec985a78007fa3da4f8","modified":1663380245594},{"_id":"source/_posts/2018-10-22-IntrotoPro1/Est_S2VS.jpg","hash":"8aa9ca8c8eff24b2a06ba205d1af7c90c2434a47","modified":1663380245112},{"_id":"source/_posts/2019-01-04-PyCUDAseries1/vsinstaller.png","hash":"00caf651a329fb3185dc12e1a67b0eabf91875be","modified":1663380245122},{"_id":"source/_posts/2019-06-21-ABCalgorithm/modelseleSMC.png","hash":"084d79b8a6540c7aabcd7d285808b1340be9bc77","modified":1663380245231},{"_id":"themes/Hacker/.gitignore","hash":"6ba9b0f365bae2b510d061f91d7dae5cc4a01519","modified":1663385897808},{"_id":"themes/Hacker/CHANGELOG.md","hash":"6ca7d32d1d21fda63b2a34955a938cf23d9c81dc","modified":1663385897808},{"_id":"themes/Hacker/CHANGELOG_zh-CN.md","hash":"cb55e4d20f508eb3d0b62fba141d47da5b3b208f","modified":1663385897808},{"_id":"themes/Hacker/README.md","hash":"1a6ef7faa3c2a66c85e982caf33812b8449ab3c7","modified":1663385897809},{"_id":"themes/Hacker/LICENSE","hash":"0563ae80146b914423bf8473caf40543a9d208fd","modified":1663385897808},{"_id":"themes/Hacker/_config.yml","hash":"8e9445eb82ea50d6172a945508e7d63a4671849f","modified":1663389883674},{"_id":"themes/Hacker/languages/default.yml","hash":"6931bd3fa5ad6fdd0fb5735c6f0caefb3b60b08e","modified":1663385897809},{"_id":"themes/Hacker/README_zh-CN.md","hash":"22d5ee6d783e8016bbe81466c048b35d18b9eb3c","modified":1663385897809},{"_id":"themes/Hacker/layout/archive.ejs","hash":"2238cbe29009aafb16969d2c70dceb3f71772123","modified":1663385897809},{"_id":"themes/Hacker/layout/categories.ejs","hash":"f31be1fd83097975b371c91a3e9ea72202737d20","modified":1663385897809},{"_id":"themes/Hacker/languages/zh-CN.yml","hash":"3f931dd6578f743ea6c8078db776be7033a363cb","modified":1663385897809},{"_id":"themes/Hacker/layout/index.ejs","hash":"2c9d0685b2fdbc3c51680461574a4e9206971b1d","modified":1663385897810},{"_id":"themes/Hacker/layout/layout.ejs","hash":"1c161cec595cd9ac410b9eeb386507747ab6a529","modified":1663385897810},{"_id":"themes/Hacker/layout/page.ejs","hash":"84e00bbcc643dff4bd02880b3bbea658f510835f","modified":1663385897810},{"_id":"themes/Hacker/layout/post.ejs","hash":"84e00bbcc643dff4bd02880b3bbea658f510835f","modified":1663385897811},{"_id":"themes/Hacker/layout/tags.ejs","hash":"c56b400bb96dcc3f335f780a623989563cb7d93b","modified":1663385897811},{"_id":"themes/Hacker/layout/components/archive.ejs","hash":"fff3f4afd04956d7bf88658f285ae11637cb7b25","modified":1663385897810},{"_id":"themes/Hacker/layout/components/article.ejs","hash":"e9a49fd8bba7b6700c3d2e58e5e7d20076b9de1a","modified":1663385897810},{"_id":"themes/Hacker/layout/components/baiduanalytics.ejs","hash":"19c5f58b4b6ab8330018dbc6b7e95ac0f409222e","modified":1663385897810},{"_id":"themes/Hacker/layout/components/comment.ejs","hash":"67e74870f9d61897626cc06727a5509cd14f4cc9","modified":1663385897810},{"_id":"themes/Hacker/layout/components/categories.ejs","hash":"204c27a7a4e3b76a22f2bba6676219a2f354e01e","modified":1663385897810},{"_id":"themes/Hacker/layout/components/footer.ejs","hash":"7ba2e6fc1119b5cc547b485fd40bd0446f6c26c6","modified":1663385897810},{"_id":"themes/Hacker/layout/components/googleanalytics.ejs","hash":"c57bf5f123df35dc99a7eecfb963966f2740efb3","modified":1663385897810},{"_id":"themes/Hacker/layout/components/head.ejs","hash":"68ee219f274c2b9c52d65f1abe58bb664c344ad8","modified":1663385897810},{"_id":"themes/Hacker/layout/components/header.ejs","hash":"b5c14e4fe3904a5301c911c2f49efbeb6c4b2c18","modified":1663385897810},{"_id":"themes/Hacker/layout/components/pagination.ejs","hash":"2643b0336eddb608fc1307fd8e9fe1a34a93b6d2","modified":1663385897810},{"_id":"themes/Hacker/source/css/style.styl","hash":"2714f6b2916b0c10eded71d606372ee6a6cd30be","modified":1663385897812},{"_id":"themes/Hacker/source/images/icon-heart.svg","hash":"5fe7b418079dd99223e7ca9c09f84ae810e86af4","modified":1663385897812},{"_id":"themes/Hacker/source/css/base/normalize.css","hash":"f466245d5ad990c1062481c0e1f8741fb4bfa00e","modified":1663385897811},{"_id":"themes/Hacker/source/css/components/article.styl","hash":"8ab9bf86c52b9ab7791c8b1f6e28a59e37d75096","modified":1663385897811},{"_id":"themes/Hacker/source/css/components/archive.styl","hash":"19ca6c9c25ec988b3e87ddac31c60bfc9dc456d3","modified":1663385897811},{"_id":"themes/Hacker/source/css/components/categories.styl","hash":"38ef9adf1b59af2025cab6b2316a187912a74a57","modified":1663385897811},{"_id":"themes/Hacker/source/css/components/footer.styl","hash":"6e28a93166fc0b0012fc8ebf647c16f9fefcd5c4","modified":1663385897811},{"_id":"themes/Hacker/source/css/components/header.styl","hash":"f0df1379255d938a7bcc4bf433b627685c1dae49","modified":1663385897811},{"_id":"themes/Hacker/source/css/components/layout.styl","hash":"fc3e2a9819196c572cabe3a001fd4921d8c36d07","modified":1663385897812},{"_id":"themes/Hacker/source/css/components/icon.styl","hash":"1b82bcf66ad0bf0054a921bf4b77d2c211ffdd43","modified":1663385897811},{"_id":"themes/Hacker/source/css/components/pagination.styl","hash":"dbdf41f863b83dbaa09b3dd059cf6c50bf2fd146","modified":1663385897812},{"_id":"themes/Hacker/source/css/components/responsive.styl","hash":"254f8b6cabbcad00f6e4c54b4868842c18514261","modified":1663385897812},{"_id":"themes/Hacker/source/css/components/syntax.styl","hash":"4e80b7ffa1ed4de978fda65e0d1c7fd6d57145ef","modified":1663385897812},{"_id":"themes/Hacker/source/css/components/tags.styl","hash":"8aa0b144eb6bec6c38cea3eff5a6b0783292917a","modified":1663385897812},{"_id":"source/_posts/2018-10-22-IntrotoPro1/Trees_S2.jpg","hash":"1b861d7249e51042282ca283eaaca2a7ca6290ba","modified":1663380245116},{"_id":"source/_posts/2020-03-18-generalABC/setup_model1.gif","hash":"41faa38bfa1cf77516dc7d2021d9a1b280fdb05c","modified":1663380245597},{"_id":"source/_posts/2020-03-18-generalABC/setup_model2.gif","hash":"cfe5c89a2b130ee3022944b95bf48a184bf855bb","modified":1663380245603},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/step2.png","hash":"f083cc62bdbceaa7841d58b5ca6391b98c75b67d","modified":1663380245141},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/step1.png","hash":"0651aeec6e745d56e82cbce37c772860e19b958f","modified":1663380245136},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/step4.png","hash":"711f5160a7362eccb039cf22c6f0f6247732db15","modified":1663380245153},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/step3.png","hash":"649ae940377bf729b5997e82435eca95462b108e","modified":1663380245147},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/step5.png","hash":"a63831c50ca8613ffa826fc6e07a6f3b75eda72c","modified":1663380245159},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/step6.png","hash":"35a833df81cbb285569edf65deeede0394bd749b","modified":1663380245165},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/step7.png","hash":"8e86e2988358ba7ca17eff5b97c27560b8d73e31","modified":1663380245172},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/step8.png","hash":"3c17f96e1ae34c613775cfa48b88d2347ce32143","modified":1663380245178},{"_id":"source/_posts/2019-06-21-TPmodel/guixianren1.jpg","hash":"ed62f2db9f2ba7b6257feaabca909a4560b5b4b1","modified":1663380245248},{"_id":"source/_posts/2021-03-21-Blender/Step1.png","hash":"7fd912173f7fde84f28f24c8ed72cc80929e4cc0","modified":1663380245613},{"_id":"source/_posts/2021-03-21-Blender/Step2.png","hash":"8ec13ee36557bd2573d3932aa0ed48dcf0b86ab7","modified":1663380245622},{"_id":"source/_posts/2021-03-21-Blender/Step3.png","hash":"10f0721ec4100781f58df5cec12278897433505f","modified":1663380245630},{"_id":"source/_posts/2021-03-21-Blender/smallworld.mkv","hash":"8d37ac6ff33c1125ad592e60a7b10a1a0c44a080","modified":1663380245646},{"_id":"source/_posts/2021-03-21-Blender/smallworld.mp4","hash":"16c9248a1135d25c4908056bbb3722f2a25f69c0","modified":1663380245657},{"_id":"source/_posts/2019-06-21-TPmodel/guixianren_s.png","hash":"ac23a18f63625f176858319f7aa82cd470b7b97e","modified":1663380245269},{"_id":"source/_posts/2019-06-21-ABCalgorithm/MCMC3chains_test3.mp4","hash":"15749ae0ca8e6e6541d54680466d0976454fd81e","modified":1663380245228},{"_id":"source/_posts/2019-06-21-TPmodel/singlespecies5.mp4","hash":"8df799aec096d3ac68b64302b0124567dd866084","modified":1663380245587},{"_id":"source/_posts/2019-06-21-TPmodel/multi6species15.mp4","hash":"2361444126185c5a4cad48a95c6acef6415f4fc5","modified":1663380245399},{"_id":"public/about/index.html","hash":"cfaa7c36c91e121bff87125441792022a548b11c","modified":1663391290321},{"_id":"public/2021/03/21/2021-03-21-Blender/index.html","hash":"27e99166a889c8016a9c9b6768eb4ab13f178d4a","modified":1663391290321},{"_id":"public/2020/10/05/2020-10-05-update/index.html","hash":"7b7d09fd60f1c27a2a7be9e362f86967bd11c1af","modified":1663391290321},{"_id":"public/2020/04/25/2020-04-25-Covid_19/index.html","hash":"ea94c58fc116c4c0ce5f5aa9f4351525637ac4cf","modified":1663391290321},{"_id":"public/2020/04/02/2020-04-02-government&pandemic/index.html","hash":"767d2c95d6992d233779cd920d1d76fba3dc0c43","modified":1663391290321},{"_id":"public/2020/03/09/2020-03-09-GUI-traitevolution/index.html","hash":"6d10477bde51dace67fb45b22760488501021831","modified":1663391290321},{"_id":"public/2019/06/21/2019-06-21-ABCalgorithm/index.html","hash":"3efee4ef9f44fc39bffde19fe30a8464bbb481d8","modified":1663391290321},{"_id":"public/2019/06/21/2019-06-21-TPmodel/index.html","hash":"a1387d0748df4c282cf975ddab46274d18cd8728","modified":1663391290321},{"_id":"public/2019/03/20/2019-03-20-readdatadon/index.html","hash":"89f164612ab67e1363e3e2b302c15856f5243072","modified":1663391290321},{"_id":"public/2019/02/01/2019-02-01-Machinelearningseries1/index.html","hash":"18a01ff74e585277abd845ff24bee392c11b0e51","modified":1663391290321},{"_id":"public/2019/01/21/2019-01-21-PyCUDAseries3/index.html","hash":"f7304b73712a1cb97b660e56a4e1bbd1b3466284","modified":1663391290321},{"_id":"public/2019/01/10/2019-01-10sed2/index.html","hash":"d36d0ce0970e551901211d832289f9e086600f53","modified":1663391290321},{"_id":"public/2019/01/04/2019-01-04-PyCUDAseries1/index.html","hash":"1578fcb38640add5011bb240b260fcd6d48bc77c","modified":1663391290321},{"_id":"public/2018/12/07/2018-12-07-ggradar2helpdocument/index.html","hash":"65219b7bfe2f2211cb6629ec8c61d9c05f16a29c","modified":1663391290321},{"_id":"public/2018/11/30/2018-11-30-SMCplots/index.html","hash":"46daa0c47767e896a85d864fdd5f5088f3458beb","modified":1663391290321},{"_id":"public/2018/11/29/2018-11-29-color/index.html","hash":"e25072124297d7980f2370bdedcf3a9047f67688","modified":1663391290321},{"_id":"public/2018/11/26/2018-11-26-Rupdateallpackages/index.html","hash":"7d3e38912220c298f179141fc92d3272ee05016c","modified":1663391290321},{"_id":"public/2018/10/29/2018-10-29-sed/index.html","hash":"f02a320263057039b1ad413dc3731c38a9c3ba01","modified":1663391290321},{"_id":"public/2018/10/25/2018-10-25-PLSR/index.html","hash":"370f039e9ddc9e991f6126f242b517e79b110796","modified":1663391290321},{"_id":"public/2018/10/24/2018-10-24-derivingFPequ/index.html","hash":"5d1679c3a9787fdaa207dac1811c8e70d60a8a65","modified":1663391290321},{"_id":"public/2018/10/24/2018-10-24-phylo2Lfunction/index.html","hash":"a92c098ce08c29156832c9ca501bb711a32aa4ee","modified":1663391290321},{"_id":"public/2018/10/24/2018-10-24-pruneLfunction/index.html","hash":"dc4b85de60615facae66381b92f0841aae93a6ce","modified":1663391290321},{"_id":"public/2018/10/23/2018-10-23-Blogging tech/index.html","hash":"5607f2318fe236c62ae79bf37a0f9101f0e4d5bb","modified":1663391290321},{"_id":"public/2018/10/22/2018-10-22-IntrotoPro1/index.html","hash":"e2a1256f2448bb2b2663c1d8daa7e0a0c09da31a","modified":1663391290321},{"_id":"public/2018/10/20/hello-world/index.html","hash":"745953476a43204da13c4e16fc16b98202a217b1","modified":1663391290321},{"_id":"public/archives/index.html","hash":"2ca11c0c8364650586a89764d6df96efafb75876","modified":1663391290321},{"_id":"public/archives/page/2/index.html","hash":"7dfd47a10d9a4bee533f81e031ce271cdc458b81","modified":1663391290321},{"_id":"public/archives/page/3/index.html","hash":"04e371c757ef5524c691570e1876e40d311d5c81","modified":1663391290321},{"_id":"public/archives/2018/index.html","hash":"0258d710efdd7080855327bd3906ba8d225690db","modified":1663391290321},{"_id":"public/archives/2018/page/2/index.html","hash":"a9d8919a32d97e114517c46e2e1ff92d1079c55c","modified":1663391290321},{"_id":"public/archives/2018/10/index.html","hash":"12ad63aa6841f5101aca9f27a21a269f81f71991","modified":1663391290321},{"_id":"public/archives/2018/11/index.html","hash":"344387a066cdaf4948037b82fc243e9b4a8371a4","modified":1663391290321},{"_id":"public/archives/2018/12/index.html","hash":"1ea401e822df9a58a56d14a7920d60c9c817e43e","modified":1663391290321},{"_id":"public/archives/2019/index.html","hash":"b612cfeb64c3a85d30bac4f28b58baf9e38ffb12","modified":1663391290321},{"_id":"public/archives/2019/01/index.html","hash":"b6fea3025139d29a826b3e574ca814f3c2569d5d","modified":1663391290321},{"_id":"public/archives/2019/02/index.html","hash":"df066fc230308371b22e36009a9ecfd1d540a817","modified":1663391290321},{"_id":"public/archives/2019/03/index.html","hash":"52d3b1945c6f8fd1e0ef27c4dbd51419d208c976","modified":1663391290321},{"_id":"public/archives/2019/06/index.html","hash":"e89451e914b7a0b793da7d97e20c981d9bf39ee5","modified":1663391290321},{"_id":"public/archives/2020/index.html","hash":"a350dbbad7006f2ba90d243d1dea54207abd48fd","modified":1663391290321},{"_id":"public/archives/2020/03/index.html","hash":"d022d51d1a033385782b31c9101d7d569e84bab8","modified":1663391290321},{"_id":"public/archives/2020/04/index.html","hash":"57ce456efb3515913b99283be2c2727d7998db1d","modified":1663391290321},{"_id":"public/archives/2020/10/index.html","hash":"06fd0d00f00f36ab39ac9fb08ddca92de7e79112","modified":1663391290321},{"_id":"public/archives/2021/index.html","hash":"b19b9e655fdfab3c22352ca28b17501d3b7c9493","modified":1663391290321},{"_id":"public/archives/2021/03/index.html","hash":"41a217979abdf7350b95e3c4b7604b4a27046024","modified":1663391290321},{"_id":"public/page/3/index.html","hash":"d0e3d76af685b5d87013adb61e3c43dfa286e713","modified":1663391290321},{"_id":"public/categories/Blogging/index.html","hash":"7c455121f1e7b13f60c00e9d5afd475a488c35d3","modified":1663391290321},{"_id":"public/categories/Research/index.html","hash":"c2b103536b2103ccb332b1ca70e11d5d600d1b6b","modified":1663391290321},{"_id":"public/categories/Research/page/2/index.html","hash":"bdb4cf53404ab348e63802427118060c14409e10","modified":1663391290321},{"_id":"public/categories/Research/page/3/index.html","hash":"86f9cf2f289d18333f8aade221ead1006e87b54b","modified":1663391290321},{"_id":"public/categories/Blogging/Blogging-tech/index.html","hash":"57588b2caff08b0f3a7bef3122200fc252a4aad0","modified":1663391290321},{"_id":"public/categories/Research/Numerical-method/index.html","hash":"ab0bf7cb02d6c11be68ddc728e2d87324a508f69","modified":1663391290321},{"_id":"public/categories/Research/Phd-projects/index.html","hash":"44ecde77448c13d79e4ab933acb13372468a9aec","modified":1663391290321},{"_id":"public/categories/Research/Bash/index.html","hash":"1801d6035fe8e618c9aa8a0c06006eb17f57bd78","modified":1663391290321},{"_id":"public/categories/Research/R/index.html","hash":"4417336c4d380b96df40ffc8b4012df354fc1433","modified":1663391290321},{"_id":"public/categories/Research/Stochastic-differential-equations/index.html","hash":"9ea613009e78651fcce7e6b7fd0ad242418fce9b","modified":1663391290321},{"_id":"public/categories/Research/Data-visualization/index.html","hash":"a8d3ece5bada701935a44f98d604091395c0360f","modified":1663391290321},{"_id":"public/categories/Research/GPU-programming/index.html","hash":"b397b6fee5478deaca02acb6f4977b775fb701e9","modified":1663391290321},{"_id":"public/categories/Research/Machine-learning/index.html","hash":"c17ccac833ff500b4178b3c0174b00556c5a5b64","modified":1663391290321},{"_id":"public/categories/Research/Algorithm/index.html","hash":"449a0a7ed48c9209ccc6f28fce14d1de0aaf8552","modified":1663391290321},{"_id":"public/categories/Research/Phd-projects/trait-population-model/index.html","hash":"4ca91ae28469c43369d7872611da582fa135e72f","modified":1663391290321},{"_id":"public/categories/Research/Bash/sed/index.html","hash":"51d2979755a1f83bfa6bcd61d60db0feedc9bbb3","modified":1663391290321},{"_id":"public/categories/Research/Python/index.html","hash":"e64dff8851a4f20f2be40ef169b0fef4db665f4b","modified":1663391290321},{"_id":"public/categories/Research/Modeling/index.html","hash":"48e9f4251e253fe088776eaa94378d5fdbf85fa8","modified":1663391290321},{"_id":"public/categories/Research/Data-visualization/R/index.html","hash":"1e76b3df0f1e8efcb7af9a81346896ce5c53a925","modified":1663391290321},{"_id":"public/categories/Research/R/phylogeny-function/index.html","hash":"7c467fa4fb2a7683ce0c6c46eeedb5c077f4e625","modified":1663391290321},{"_id":"public/categories/Research/GPU-programming/pyCUDA/index.html","hash":"07b1d50b614111e675098e149a201011290e5db6","modified":1663391290321},{"_id":"public/categories/Research/Machine-learning/Deep-learning/index.html","hash":"f7a5db733176dc1a5804f975eedf23aaf385f063","modified":1663391290321},{"_id":"public/categories/Research/Algorithm/ABC/index.html","hash":"e32a648fdbc34b019ef8696570e7ba1544fe91cf","modified":1663391290321},{"_id":"public/categories/Research/Python/GUI/index.html","hash":"44933f2e7b677766d9fb019e32b32b4a4e8c4f74","modified":1663391290321},{"_id":"public/categories/Research/Data-visualization/R/ggradar2/index.html","hash":"af258429f7b2f0d9603d067796c6885148b1ce16","modified":1663391290321},{"_id":"public/categories/BB-life/index.html","hash":"5933c0ed0633c33faf5574821058d06265234808","modified":1663391290321},{"_id":"public/tags/Tech/index.html","hash":"df453475abab88606a7356e2f735fa6b3b1d6afd","modified":1663391290321},{"_id":"public/tags/evolution/index.html","hash":"5c48adf9b9393609d9d3b3a924749f3bd9a391b2","modified":1663391290321},{"_id":"public/tags/mathematical-modeling/index.html","hash":"97f1f463923d3434134a174ab2187c1310532002","modified":1663391290321},{"_id":"public/tags/diversity-dependence/index.html","hash":"3bf47de71bbdd44e69f78312c42195bfcba02bc3","modified":1663391290321},{"_id":"public/tags/the-Fokker-Planck-equation/index.html","hash":"4abc80c076eb29aa0c810d9ae22a196db581a6b8","modified":1663391290321},{"_id":"public/tags/stochastic-differential-equation/index.html","hash":"20fd204262f5725cc47009184b37885ce04c0403","modified":1663391290321},{"_id":"public/tags/math/index.html","hash":"29fe5bffd17bd6560cd480286c9dd7288a5a4c1e","modified":1663391290321},{"_id":"public/tags/phylogeny/index.html","hash":"62d5e41a566778fbdb985ac7482f18d83becc379","modified":1663391290321},{"_id":"public/tags/phylo-class/index.html","hash":"76695219a5de31b7d7fdedccbdc6acbd0bb3348b","modified":1663391290321},{"_id":"public/tags/L-table/index.html","hash":"92d6560e428d4a17faa3116def39d09097ef0ccc","modified":1663391290321},{"_id":"public/tags/DDD-package/index.html","hash":"c61444bbd0c80e0b05472fa86970b3f3471395c4","modified":1663391290321},{"_id":"public/tags/pruneL/index.html","hash":"1c2525d583508360c79bef18802d0e821ea712d5","modified":1663391290321},{"_id":"public/tags/phylo2L/index.html","hash":"1e7dd20c54df03de045a958ae74d6758951f4d54","modified":1663391290321},{"_id":"public/tags/regression/index.html","hash":"48ccdc99ebad063aaa615c950c53dfa6baffd208","modified":1663391290321},{"_id":"public/tags/least-square-method/index.html","hash":"1c555338f27ebb73d8ce9da5b01727c61fa309ef","modified":1663391290321},{"_id":"public/tags/partial-least-square/index.html","hash":"3c94a020f5541c52ea7832f03ccb7831eadc311f","modified":1663391290321},{"_id":"public/tags/machine-learning/index.html","hash":"3ebb047f9f7096289a1fe85ab041c1bc04bfa59c","modified":1663391290321},{"_id":"public/tags/project-3/index.html","hash":"53c457e2976d7fc735813b7be38219defb326d07","modified":1663391290321},{"_id":"public/tags/bash/index.html","hash":"8e2687a77be66436c907aeed4255afd894ebb25c","modified":1663391290321},{"_id":"public/tags/mega-data/index.html","hash":"7d1eb9cfd5d827b53b1e09801aae92e843115471","modified":1663391290321},{"_id":"public/tags/extract-information/index.html","hash":"1ab3d27fb024ba9aaf9210ecbd0f67149af6a49e","modified":1663391290321},{"_id":"public/tags/R/index.html","hash":"05172b4296870faa5ec9636f256829e9c87b76bd","modified":1663391290321},{"_id":"public/tags/update/index.html","hash":"ff9b1aab1917c7c2e15c95bd6c0b37cc36139fb4","modified":1663391290321},{"_id":"public/tags/packages/index.html","hash":"ecae8ecd80d43363a88a7d1bf2666711984e1ebe","modified":1663391290321},{"_id":"public/tags/color/index.html","hash":"e9a0c63ee2ccde4324e546b3bad4208cfdb9320a","modified":1663391290321},{"_id":"public/tags/python/index.html","hash":"6ba7b8f10c52213dfaea78e2c690e4c4599bdb2a","modified":1663391290321},{"_id":"public/tags/plot/index.html","hash":"2f4532381b449b96b52a866cfcf2f14e86b67fed","modified":1663391290321},{"_id":"public/tags/ggplot/index.html","hash":"e5ed05461eed64d17372b323bcb351179e9cc44b","modified":1663391290321},{"_id":"public/tags/ggradar2/index.html","hash":"60cdf2608d9c3be72737ba57148b02876c8e8424","modified":1663391290321},{"_id":"public/tags/Data-visualization/index.html","hash":"25e34f1f496aa6a860333da2961094b5bf652c7a","modified":1663391290321},{"_id":"public/tags/SMC/index.html","hash":"9541a988413e3e640fe509889606691a88950093","modified":1663391290321},{"_id":"public/tags/Python/index.html","hash":"3fc5b1a987abb23a19d0b0013fe8fadf7f707c01","modified":1663391290321},{"_id":"public/tags/CUDA/index.html","hash":"8e05421dd115b4c85ad5c6722a34ea727dda5d4e","modified":1663391290321},{"_id":"public/tags/GPU-programming/index.html","hash":"3959dc8765d8123c46cf07bb5b460fa425ab9c22","modified":1663391290321},{"_id":"public/tags/Parallel-computation/index.html","hash":"acf5f7e24761c0347ca33bafce86dc9751c693e9","modified":1663391290321},{"_id":"public/tags/help-document/index.html","hash":"d2cf7307e4d1b62167a7349d61a1b7c8d86f921f","modified":1663391290321},{"_id":"public/tags/Machine-learning/index.html","hash":"acb4461dcd9badcf0a0d9306681c7f4696f6b121","modified":1663391290321},{"_id":"public/tags/neural-networks/index.html","hash":"bd6cbae7245ad389e9ef76d734382bc92d940b4e","modified":1663391290321},{"_id":"public/tags/Backward-propagation/index.html","hash":"316be93caa4e26046ed5e7c6796e34e1d800e4e7","modified":1663391290321},{"_id":"public/tags/gradient-descent/index.html","hash":"0d7de7745fe44e9dec368bc1d469f6343801cdb8","modified":1663391290321},{"_id":"public/tags/data-analysis/index.html","hash":"253b602a011bf782b68f4dbf7020f19e4c1813a6","modified":1663391290321},{"_id":"public/tags/ABC/index.html","hash":"e627ba1647c6f64a8d451299850ba87eefcc76a0","modified":1663391290321},{"_id":"public/tags/Animation/index.html","hash":"46b0beda8c2132426b5e87f9baacda886a7e7dec","modified":1663391290321},{"_id":"public/tags/ecology/index.html","hash":"c913205e252da8602c74ba3201ef50874487e44c","modified":1663391290321},{"_id":"public/tags/GUI/index.html","hash":"33a19c75b0a3d8bb3413370784dc8dd24322d2fe","modified":1663391290321},{"_id":"public/tags/models/index.html","hash":"17674559c6b6a9e329bf8ebdc30a4f050e355f2c","modified":1663391290321},{"_id":"public/tags/algorithm/index.html","hash":"0c66a783d79703ad74d1a995c13e8794f764c0f8","modified":1663391290321},{"_id":"public/tags/simulation/index.html","hash":"a81f8a58089e6a49dc03295f3b57a7c6e063edba","modified":1663391290321},{"_id":"public/tags/coronavirus/index.html","hash":"f508a84353db61bc02a16c16955e0198fa887ce6","modified":1663391290321},{"_id":"public/tags/pandemic/index.html","hash":"703c45aeaea7efbca820fb2f1dd312123e861138","modified":1663391290321},{"_id":"public/tags/government-measure/index.html","hash":"aab30c539696d38bc07d2453b44fd93e95d1e6a4","modified":1663391290321},{"_id":"public/tags/data-visualization/index.html","hash":"8e8382235a44d71dc47f76cb845485889a58003f","modified":1663391290321},{"_id":"public/tags/Postdoc/index.html","hash":"7ea933dc0abb3dc4bd5c3900218fc3be1dc60579","modified":1663391290321},{"_id":"public/tags/Blender/index.html","hash":"3027d64dc15464d75f6bed6511665e729b38c27b","modified":1663391290321},{"_id":"public/tags/info/index.html","hash":"dbf82036ca7e73c918f1f33290cb6e876cce29d9","modified":1663391290321},{"_id":"public/categories/index.html","hash":"c74afac2334a2e8605c7553062468e944ddffca1","modified":1663391290321},{"_id":"public/tags/index.html","hash":"96b3e3daa27d6d21b8910102b4964e43de42b97e","modified":1663391290321},{"_id":"public/2020/03/18/2020-03-18-generalABC/index.html","hash":"43933db47c978ff660b7885c44842fa2157aab94","modified":1663391290321},{"_id":"public/2019/02/08/2019-02-08-Machinelearningseries2/index.html","hash":"393c350bfb4dfbb695ac19f16f0b6c728d93238e","modified":1663391290321},{"_id":"public/2019/01/14/2019-01-14-PyCUDAseries2/index.html","hash":"1b41bbc78edfb2b3b5f0f5b77a7b61677d6d3223","modified":1663391290321},{"_id":"public/2018/12/05/2018-12-05-ggradar2/index.html","hash":"6def422fa781f7983aceaa0efb14210189ea54a6","modified":1663391290321},{"_id":"public/index.html","hash":"ff351a773e6d6a0f8a4eb1295e565f37a49b379d","modified":1663391290321},{"_id":"public/page/2/index.html","hash":"eff73aad3ec5c6da85e49da7671a50339434ef5d","modified":1663391290321},{"_id":"public/images/icon-heart.svg","hash":"5fe7b418079dd99223e7ca9c09f84ae810e86af4","modified":1663391290321},{"_id":"public/2018/10/29/2018-10-29-sed/rawdata.png","hash":"504d3898506b182f7ffb5b6cb19618dde1154b0e","modified":1663391290321},{"_id":"public/2018/10/29/2018-10-29-sed/d.png","hash":"6bdc800119bc8de7461548b9d94b5f776c43a345","modified":1663391290321},{"_id":"public/2018/10/29/2018-10-29-sed/ds.png","hash":"965d5418e7f621023a969770a36e2702a117ed90","modified":1663391290321},{"_id":"public/2018/11/29/2018-11-29-color/col1.png","hash":"cbf10523cc8e07e62bef59195000b0f541cd581f","modified":1663391290321},{"_id":"public/2018/11/29/2018-11-29-color/col2.png","hash":"3dd942d4972d112beb80a25fc3aef5c905a92b54","modified":1663391290321},{"_id":"public/2018/11/29/2018-11-29-color/col3.png","hash":"1d83794811a02b4bdadab17f78c8275ad87f131f","modified":1663391290321},{"_id":"public/2018/11/29/2018-11-29-color/col4.png","hash":"8e015d04d4090c8debb5eed1964595de0f368a5b","modified":1663391290321},{"_id":"public/2018/12/05/2018-12-05-ggradar2/fullscore.png","hash":"5c50cfa94f69d90edfb9561abf66f229c83eee50","modified":1663391290321},{"_id":"public/2018/12/05/2018-12-05-ggradar2/lux.png","hash":"9ddc42a286d090bbe82e25d58cbd92c1d7347079","modified":1663391290321},{"_id":"public/2018/12/05/2018-12-05-ggradar2/multipleplots.png","hash":"2c0d8c8213f7775d680657810a17ecb3e48ed38d","modified":1663391290321},{"_id":"public/2018/12/05/2018-12-05-ggradar2/mini.png","hash":"18b7ec1f51059e5dd8e748c53d68a806daec38ea","modified":1663391290321},{"_id":"public/2018/12/05/2018-12-05-ggradar2/multipleplotsbig.png","hash":"739c484223aa914606da7a43e93446af8e163388","modified":1663391290321},{"_id":"public/2018/12/05/2018-12-05-ggradar2/nolegend.png","hash":"338d96bd8f0ccd7d26c8dd4e341b39362c64a04e","modified":1663391290321},{"_id":"public/2018/12/05/2018-12-05-ggradar2/roundfill.png","hash":"7a6539ae5da9c90b8a62b37eed031cff190d7c9c","modified":1663391290321},{"_id":"public/2018/12/05/2018-12-05-ggradar2/roundnofill.png","hash":"31bfb3f19b550723abcc32b6b7177982128c8830","modified":1663391290321},{"_id":"public/2018/12/05/2018-12-05-ggradar2/straightfill.png","hash":"f0f6bfe7a10e8856cd45cff454aad0655692b18f","modified":1663391290321},{"_id":"public/2018/12/05/2018-12-05-ggradar2/straightnofill.png","hash":"efa92f19754af10d469cf6675eb7a44e08e70eda","modified":1663391290321},{"_id":"public/2018/12/05/2018-12-05-ggradar2/trend.png","hash":"580a0ab7b4449330b9425f722f196fffb82c9134","modified":1663391290321},{"_id":"public/2018/11/30/2018-11-30-SMCplots/Rplot1.png","hash":"7b3ed1bb1002079cb8719e12f7d0e01a4098ae75","modified":1663391290321},{"_id":"public/2018/11/30/2018-11-30-SMCplots/Rplot2.png","hash":"a4ace9d48b797039ce52da319ebf313b339b2e1e","modified":1663391290321},{"_id":"public/2019/01/10/2019-01-10sed2/mfiles.png","hash":"45a7ad5fb9fe1ab18105f988b18272269c0e549b","modified":1663391290321},{"_id":"public/2019/02/01/2019-02-01-Machinelearningseries1/modelselection1.png","hash":"c119feddb57b38b5d364ce35082001d7d62dbd74","modified":1663391290321},{"_id":"public/2019/02/01/2019-02-01-Machinelearningseries1/prediction_sample.png","hash":"cd4ff39cfafd41d0711a4f11a77df2c0277ce7f9","modified":1663391290321},{"_id":"public/2019/01/14/2019-01-14-PyCUDAseries2/speedtest.png","hash":"c48054dc2ef38a8857227c55428dc68e185f841d","modified":1663391290321},{"_id":"public/2019/03/20/2019-03-20-readdatadon/d.png","hash":"6bdc800119bc8de7461548b9d94b5f776c43a345","modified":1663391290321},{"_id":"public/2019/03/20/2019-03-20-readdatadon/rewrittendata.png","hash":"52a13bcda911b3879916779e798250de59cd01ba","modified":1663391290321},{"_id":"public/2019/02/08/2019-02-08-Machinelearningseries2/1.png","hash":"08f6c16b529bc03ecf83c55de5d28d2ec737aad7","modified":1663391290321},{"_id":"public/2019/02/08/2019-02-08-Machinelearningseries2/10.png","hash":"b2656495f031e2eefcc8734ee589b1ab555f1c6e","modified":1663391290321},{"_id":"public/2019/02/08/2019-02-08-Machinelearningseries2/12.png","hash":"6b4b7c01e0a107e349be33d327ff4a828de3ad41","modified":1663391290321},{"_id":"public/2019/02/08/2019-02-08-Machinelearningseries2/11.png","hash":"a92bd5f59fee6cf4c18e4c7778bb53c8853c9b27","modified":1663391290321},{"_id":"public/2019/02/08/2019-02-08-Machinelearningseries2/13-15.png","hash":"4e6540b7dbbc1cecadc83b89205c4e249207f2d8","modified":1663391290321},{"_id":"public/2019/02/08/2019-02-08-Machinelearningseries2/16.png","hash":"a79170ae6a15e5fb2342f6c373121e17d76eed33","modified":1663391290321},{"_id":"public/2019/02/08/2019-02-08-Machinelearningseries2/17.png","hash":"58c3578da213026a6faf5236cef70d0de0df18e7","modified":1663391290321},{"_id":"public/2019/02/08/2019-02-08-Machinelearningseries2/18.png","hash":"fe7df21d74b9ac39988417271f71df0da3e14d46","modified":1663391290321},{"_id":"public/2019/02/08/2019-02-08-Machinelearningseries2/19-1.png","hash":"9a35d6438ea32257c73165fa5764e7f1555390ad","modified":1663391290321},{"_id":"public/2019/02/08/2019-02-08-Machinelearningseries2/2.png","hash":"2ad49fbdeb4f563edd0797d9a4d972a8839c9d55","modified":1663391290321},{"_id":"public/2019/02/08/2019-02-08-Machinelearningseries2/19.png","hash":"747d05b0ea5814c72e57861034a59c4a63211a60","modified":1663391290321},{"_id":"public/2019/02/08/2019-02-08-Machinelearningseries2/20.png","hash":"85329614886a4b196eb845f13bb3a0fffabb1489","modified":1663391290321},{"_id":"public/2019/02/08/2019-02-08-Machinelearningseries2/21.png","hash":"94ce999c4c85fa14d85ae219eb00f9fbc6c94c36","modified":1663391290321},{"_id":"public/2019/02/08/2019-02-08-Machinelearningseries2/22.png","hash":"07b7bd1f8775d6e41253f8a4b0ae8e696bbc6502","modified":1663391290321},{"_id":"public/2019/02/08/2019-02-08-Machinelearningseries2/24.png","hash":"81ae1d4ec941ea54cf9457840d97557d0852b2e5","modified":1663391290321},{"_id":"public/2019/02/08/2019-02-08-Machinelearningseries2/23.png","hash":"839ecc43535c8c589a64aa7cc947ec88441f871a","modified":1663391290321},{"_id":"public/2019/02/08/2019-02-08-Machinelearningseries2/25.png","hash":"cb29499e4d9341922f9d1e234068966d0b28fb73","modified":1663391290321},{"_id":"public/2019/02/08/2019-02-08-Machinelearningseries2/3.png","hash":"82ca237383cd0b4c6c69991218d5243fe95411dd","modified":1663391290321},{"_id":"public/2019/02/08/2019-02-08-Machinelearningseries2/6.png","hash":"d28b9b8aed0df282c8921d57715c719b924e3a37","modified":1663391290321},{"_id":"public/2019/02/08/2019-02-08-Machinelearningseries2/78.png","hash":"1a55ed4d935acf4d99d095bd183364b02bb7182b","modified":1663391290321},{"_id":"public/2019/02/08/2019-02-08-Machinelearningseries2/4.png","hash":"f53c3a372ae9ae0a6e992e176ef35ccf8fd1160a","modified":1663391290321},{"_id":"public/2019/02/08/2019-02-08-Machinelearningseries2/5.png","hash":"4445bfdd3d0690432257608a790062f4d4ecfccf","modified":1663391290321},{"_id":"public/2019/02/08/2019-02-08-Machinelearningseries2/9-1.png","hash":"dd5ccd15eab9ebd82ffb81322a9b543f28326dff","modified":1663391290321},{"_id":"public/2019/02/08/2019-02-08-Machinelearningseries2/9.png","hash":"21858569c261d689790e470dda6647388bbf6828","modified":1663391290321},{"_id":"public/2019/06/21/2019-06-21-ABCalgorithm/Rplot2.png","hash":"a4ace9d48b797039ce52da319ebf313b339b2e1e","modified":1663391290321},{"_id":"public/2020/03/09/2020-03-09-GUI-traitevolution/p2.png","hash":"74d01c3c8e6cb746289469f2602c303afa15857a","modified":1663391290321},{"_id":"public/2020/03/09/2020-03-09-GUI-traitevolution/p3.png","hash":"2ce44cf24deb5e9d34abd78b7c93eea8e43cfc72","modified":1663391290321},{"_id":"public/2020/03/09/2020-03-09-GUI-traitevolution/p4.png","hash":"c8d1a197ba7983f534e5f7818b3063c086c85eed","modified":1663391290321},{"_id":"public/2020/03/09/2020-03-09-GUI-traitevolution/p1.png","hash":"51eee44eff5793b37c8e4206438a97cff6b47603","modified":1663391290321},{"_id":"public/2020/03/18/2020-03-18-generalABC/Predict1.png","hash":"8fbdb67a9331ad9f7d467a4a486d039dd2f5e016","modified":1663391290321},{"_id":"public/2020/03/18/2020-03-18-generalABC/data.png","hash":"2f1482534ce247a1e5ece239b01f6f5690d0b5cf","modified":1663391290321},{"_id":"public/2020/03/18/2020-03-18-generalABC/Predict2.png","hash":"ac88d57a8405d71db8a98580cb7951bd55dcfb29","modified":1663391290321},{"_id":"public/2018/10/22/2018-10-22-IntrotoPro1/Powertable.jpg","hash":"08373cf6112778618fd1a22a51e735a27a49c679","modified":1663391290321},{"_id":"public/about/Liang_CV.pdf","hash":"3e1a7c3b61f72b6ce450db175b0d9f7dae0653d8","modified":1663391290321},{"_id":"public/2019/01/04/2019-01-04-PyCUDAseries1/win10SDK.png","hash":"255648cb736a724d3623bf51d04bbdce05778edd","modified":1663391290321},{"_id":"public/2019/01/10/2019-01-10sed2/rdatafiles.png","hash":"7c87f5b7820eb89deaf7a4250e942ef94b1bb53b","modified":1663391290321},{"_id":"public/2019/01/14/2019-01-14-PyCUDAseries2/gridblockthread.png","hash":"31ad63d0cf3f0411ae70f29a71261f3e6642020e","modified":1663391290321},{"_id":"public/2020/03/18/2020-03-18-generalABC/abc_scheme.png","hash":"462844b99697e9d935b97ec985a78007fa3da4f8","modified":1663391290321},{"_id":"public/css/base/normalize.css","hash":"e58275a588bb631a37a2988145eea231ed23176b","modified":1663391290321},{"_id":"public/css/components/categories.css","hash":"f181d27640f1408f032c5386836c4c2322724f8d","modified":1663391290321},{"_id":"public/css/components/article.css","hash":"3a1316dbf86a4f52cf8da789f3a13e94504dee76","modified":1663391290321},{"_id":"public/css/components/footer.css","hash":"602def895fd52f288b6e93932284aa2e52b7fee0","modified":1663391290321},{"_id":"public/css/components/archive.css","hash":"cea7d6edd8221c00602a799e67046365b2ad929e","modified":1663391290321},{"_id":"public/css/components/layout.css","hash":"7bffe71c7aba90b2fc5bc6dc1457db50018c7a6f","modified":1663391290321},{"_id":"public/css/components/header.css","hash":"51f8a4c736f3b180a7c4c8f804d8060031df6a34","modified":1663391290321},{"_id":"public/css/components/icon.css","hash":"cdaf1a152184ff7def760f14095e4a2fa16cd6bd","modified":1663391290321},{"_id":"public/css/components/pagination.css","hash":"88f7519c0c8ff96b436413528d5f568a4f3d2177","modified":1663391290321},{"_id":"public/css/components/syntax.css","hash":"80de949e0928eb18957f63e7435877085ca626fb","modified":1663391290321},{"_id":"public/css/components/tags.css","hash":"1566e94c23ae19dbfc7d2cf433e68242ed657dea","modified":1663391290321},{"_id":"public/css/components/responsive.css","hash":"216eb94fc69007de995fc8d382670ba00a9574e8","modified":1663391290321},{"_id":"public/css/style.css","hash":"9be8fa31f5f484cab1cb4fd4752ea15619580271","modified":1663391290321},{"_id":"public/2018/10/22/2018-10-22-IntrotoPro1/Est_S2VS.jpg","hash":"8aa9ca8c8eff24b2a06ba205d1af7c90c2434a47","modified":1663391290321},{"_id":"public/2019/01/04/2019-01-04-PyCUDAseries1/vsinstaller.png","hash":"00caf651a329fb3185dc12e1a67b0eabf91875be","modified":1663391290321},{"_id":"public/2019/06/21/2019-06-21-ABCalgorithm/modelseleSMC.png","hash":"084d79b8a6540c7aabcd7d285808b1340be9bc77","modified":1663391290321},{"_id":"public/2018/10/22/2018-10-22-IntrotoPro1/Trees_S2.jpg","hash":"1b861d7249e51042282ca283eaaca2a7ca6290ba","modified":1663391290321},{"_id":"public/2020/03/18/2020-03-18-generalABC/setup_model1.gif","hash":"41faa38bfa1cf77516dc7d2021d9a1b280fdb05c","modified":1663391290321},{"_id":"public/2020/03/18/2020-03-18-generalABC/setup_model2.gif","hash":"cfe5c89a2b130ee3022944b95bf48a184bf855bb","modified":1663391290321},{"_id":"public/2019/02/08/2019-02-08-Machinelearningseries2/step2.png","hash":"f083cc62bdbceaa7841d58b5ca6391b98c75b67d","modified":1663391290321},{"_id":"public/2019/02/08/2019-02-08-Machinelearningseries2/step4.png","hash":"711f5160a7362eccb039cf22c6f0f6247732db15","modified":1663391290321},{"_id":"public/2019/02/08/2019-02-08-Machinelearningseries2/step1.png","hash":"0651aeec6e745d56e82cbce37c772860e19b958f","modified":1663391290321},{"_id":"public/2019/02/08/2019-02-08-Machinelearningseries2/step3.png","hash":"649ae940377bf729b5997e82435eca95462b108e","modified":1663391290321},{"_id":"public/2019/02/08/2019-02-08-Machinelearningseries2/step7.png","hash":"8e86e2988358ba7ca17eff5b97c27560b8d73e31","modified":1663391290321},{"_id":"public/2019/02/08/2019-02-08-Machinelearningseries2/step5.png","hash":"a63831c50ca8613ffa826fc6e07a6f3b75eda72c","modified":1663391290321},{"_id":"public/2019/02/08/2019-02-08-Machinelearningseries2/step8.png","hash":"3c17f96e1ae34c613775cfa48b88d2347ce32143","modified":1663391290321},{"_id":"public/2019/02/08/2019-02-08-Machinelearningseries2/step6.png","hash":"35a833df81cbb285569edf65deeede0394bd749b","modified":1663391290321},{"_id":"public/2019/06/21/2019-06-21-TPmodel/guixianren1.jpg","hash":"ed62f2db9f2ba7b6257feaabca909a4560b5b4b1","modified":1663391290321},{"_id":"public/2021/03/21/2021-03-21-Blender/Step1.png","hash":"7fd912173f7fde84f28f24c8ed72cc80929e4cc0","modified":1663391290321},{"_id":"public/2021/03/21/2021-03-21-Blender/Step3.png","hash":"10f0721ec4100781f58df5cec12278897433505f","modified":1663391290321},{"_id":"public/2021/03/21/2021-03-21-Blender/Step2.png","hash":"8ec13ee36557bd2573d3932aa0ed48dcf0b86ab7","modified":1663391290321},{"_id":"public/2021/03/21/2021-03-21-Blender/smallworld.mkv","hash":"8d37ac6ff33c1125ad592e60a7b10a1a0c44a080","modified":1663391290321},{"_id":"public/2021/03/21/2021-03-21-Blender/smallworld.mp4","hash":"16c9248a1135d25c4908056bbb3722f2a25f69c0","modified":1663391290321},{"_id":"public/2019/06/21/2019-06-21-TPmodel/guixianren_s.png","hash":"ac23a18f63625f176858319f7aa82cd470b7b97e","modified":1663391290321},{"_id":"public/2019/06/21/2019-06-21-ABCalgorithm/MCMC3chains_test3.mp4","hash":"15749ae0ca8e6e6541d54680466d0976454fd81e","modified":1663391290321},{"_id":"public/2019/06/21/2019-06-21-TPmodel/singlespecies5.mp4","hash":"8df799aec096d3ac68b64302b0124567dd866084","modified":1663391290321},{"_id":"public/2019/06/21/2019-06-21-TPmodel/multi6species15.mp4","hash":"2361444126185c5a4cad48a95c6acef6415f4fc5","modified":1663391290321}],"Category":[{"name":"Blogging","_id":"cl85g865k00044gkrhlv40hho"},{"name":"Research","_id":"cl85g865o000a4gkr7r74ai3a"},{"name":"Blogging tech","parent":"cl85g865k00044gkrhlv40hho","_id":"cl85g865t000n4gkrd4zeab98"},{"name":"Numerical method","parent":"cl85g865o000a4gkr7r74ai3a","_id":"cl85g865w000y4gkr2d7ofey4"},{"name":"Phd projects","parent":"cl85g865o000a4gkr7r74ai3a","_id":"cl85g865x00144gkr82s18vrl"},{"name":"Bash","parent":"cl85g865o000a4gkr7r74ai3a","_id":"cl85g865z001a4gkr5g115raf"},{"name":"R","parent":"cl85g865o000a4gkr7r74ai3a","_id":"cl85g8660001h4gkreg3iaviq"},{"name":"Stochastic differential equations","parent":"cl85g865o000a4gkr7r74ai3a","_id":"cl85g8661001p4gkrbhmk04yj"},{"name":"Data visualization","parent":"cl85g865o000a4gkr7r74ai3a","_id":"cl85g8663001t4gkreydo97xp"},{"name":"GPU programming","parent":"cl85g865o000a4gkr7r74ai3a","_id":"cl85g866500254gkrfaq921nq"},{"name":"Machine learning","parent":"cl85g865o000a4gkr7r74ai3a","_id":"cl85g8667002n4gkr59ur5at0"},{"name":"Algorithm","parent":"cl85g865o000a4gkr7r74ai3a","_id":"cl85g8668002y4gkrei7y9g4x"},{"name":"trait-population model","parent":"cl85g865x00144gkr82s18vrl","_id":"cl85g866900304gkr3ih5hfi8"},{"name":"sed","parent":"cl85g865z001a4gkr5g115raf","_id":"cl85g866900334gkra0uh6i4m"},{"name":"Python","parent":"cl85g865o000a4gkr7r74ai3a","_id":"cl85g866900384gkr37xx56fc"},{"name":"Modeling","parent":"cl85g865o000a4gkr7r74ai3a","_id":"cl85g866a003i4gkragpy0lti"},{"name":"R","parent":"cl85g8663001t4gkreydo97xp","_id":"cl85g866a003p4gkraxadd4ew"},{"name":"phylogeny function","parent":"cl85g8660001h4gkreg3iaviq","_id":"cl85g866b003z4gkra3rg7pyc"},{"name":"pyCUDA","parent":"cl85g866500254gkrfaq921nq","_id":"cl85g866b00494gkrb34757ug"},{"name":"Deep learning","parent":"cl85g8667002n4gkr59ur5at0","_id":"cl85g866d00514gkrfm7v9t8t"},{"name":"ABC","parent":"cl85g8668002y4gkrei7y9g4x","_id":"cl85g866e005h4gkr4583dupr"},{"name":"GUI","parent":"cl85g866900384gkr37xx56fc","_id":"cl85g866e005l4gkra7jygnun"},{"name":"ggradar2","parent":"cl85g866a003p4gkraxadd4ew","_id":"cl85g866f005w4gkrgrcchzmm"},{"name":"BB life","_id":"cl85g866t009m4gkr68d25750"}],"Data":[],"Page":[{"title":"About me","date":"2018-10-23T00:08:14.000Z","_content":"I am Liang Xu, a PhD student in theoretical biology in University of Groningen. I am focusing on modeling species interactions in macro eco-evolutionary science. I am interested in mathematical models as well as deep learning. You can find my CV [**HERE**](./Liang_CV.pdf).\n\n## Research Interest\n A major challenge in ecology is the need for a better theoretical framework for understanding how species assemblages (ecological communities) arise, why some are species-rich and others species-poor, and why some species are present or dominant whereas others are not. I am interested in how to construct theoretical models to mimic the evolutionary processes and invent efficient tools with explanatory power to the evolutionary issues. This field involves mathematical modeling, Eco-evolutionary science, \n\n## Education\n**2015 - 2020**  University of Groningen. PhD in Eco-evolution; \n                      **Dissertation thesis**: [Modelling species interactions in macroevolution and macroecology](https://doi.org/10.33612/diss.125954510).\n\n**2008 - 2010** Hong Kong University. Master of Philosophy in Mathematics; Epidemic models of virus infection\n\n**2004 - 2008** Beijing Normal University. Bachelor in Mathematics\n\n## Work Experience\n**2010 - 2015** Chongqing University of Technology & Sciences. Lecturer in Department of Mathematics and Physics.\n\n## PhD Projects \n* **Inferring local diversity-dependence**. \nIt is still hotly debated that whether there exists ecological limit to diversity. A diversity-dependent diversification model has been developed to infer diversity-dependent signal. However, the model ignores local information. In this project, we aim to model the evolutionary processes incorporating the local details and check that if we can still detect the local diversity-dependence. \n* **Inferring the effect of species interactions on trait evolution**. \n  Ecology and evolution jointly help to form the pattern of traits of species. We construct an eco-evolutionary framework combing both ecological interaction and evolutionary history to describe how traits of species evolve under environmental stabilizing selection and species interactions. \n* **A spatial phylogenetic Jancen-Connell extension to the neutral theory of species diversity**.\n  The neutral theory of species diversity opens a new window to explain species assembly. However, the neutral assumption that all changes in distribution and abundance occur because of purely random variation in births, deaths, migration and speciation violates the recognition of the importance in species differences. Here, we focus on tree species and develop a spatial phylogenetic Jansen-Connell extension to the neutral theory. We aim to explore to what extent the additional mechanism indeed affects species assembly.\n\n## Publication\n**Xu, L.**, & Etienne, R. S. (2018). Detecting local diversity-dependence in diversification. Evolution, 72(6), 1294-1305. DOI: 10.1111/evo.13482 \n\n**Xu, L.**, S. van Doorn, H. Hildenbrandt and R. S. Etienne (2020). Inferring the effect of species interactions on trait evolution. Systematic Biology. In press.\n\n**Xu, L.**, H. Hildenbrandt and R. S. Etienne (2020). Incorporating eco-evolutionary interactions into a spatially explicit phylogenetic Janzen-Connell model predicts realistic macroecological and macroevolutionary patterns. To be submitted.","source":"about/index.md","raw":"---\ntitle: About me\ndate: 2018-10-22 17:08:14\n---\nI am Liang Xu, a PhD student in theoretical biology in University of Groningen. I am focusing on modeling species interactions in macro eco-evolutionary science. I am interested in mathematical models as well as deep learning. You can find my CV [**HERE**](./Liang_CV.pdf).\n\n## Research Interest\n A major challenge in ecology is the need for a better theoretical framework for understanding how species assemblages (ecological communities) arise, why some are species-rich and others species-poor, and why some species are present or dominant whereas others are not. I am interested in how to construct theoretical models to mimic the evolutionary processes and invent efficient tools with explanatory power to the evolutionary issues. This field involves mathematical modeling, Eco-evolutionary science, \n\n## Education\n**2015 - 2020**  University of Groningen. PhD in Eco-evolution; \n                      **Dissertation thesis**: [Modelling species interactions in macroevolution and macroecology](https://doi.org/10.33612/diss.125954510).\n\n**2008 - 2010** Hong Kong University. Master of Philosophy in Mathematics; Epidemic models of virus infection\n\n**2004 - 2008** Beijing Normal University. Bachelor in Mathematics\n\n## Work Experience\n**2010 - 2015** Chongqing University of Technology & Sciences. Lecturer in Department of Mathematics and Physics.\n\n## PhD Projects \n* **Inferring local diversity-dependence**. \nIt is still hotly debated that whether there exists ecological limit to diversity. A diversity-dependent diversification model has been developed to infer diversity-dependent signal. However, the model ignores local information. In this project, we aim to model the evolutionary processes incorporating the local details and check that if we can still detect the local diversity-dependence. \n* **Inferring the effect of species interactions on trait evolution**. \n  Ecology and evolution jointly help to form the pattern of traits of species. We construct an eco-evolutionary framework combing both ecological interaction and evolutionary history to describe how traits of species evolve under environmental stabilizing selection and species interactions. \n* **A spatial phylogenetic Jancen-Connell extension to the neutral theory of species diversity**.\n  The neutral theory of species diversity opens a new window to explain species assembly. However, the neutral assumption that all changes in distribution and abundance occur because of purely random variation in births, deaths, migration and speciation violates the recognition of the importance in species differences. Here, we focus on tree species and develop a spatial phylogenetic Jansen-Connell extension to the neutral theory. We aim to explore to what extent the additional mechanism indeed affects species assembly.\n\n## Publication\n**Xu, L.**, & Etienne, R. S. (2018). Detecting local diversity-dependence in diversification. Evolution, 72(6), 1294-1305. DOI: 10.1111/evo.13482 \n\n**Xu, L.**, S. van Doorn, H. Hildenbrandt and R. S. Etienne (2020). Inferring the effect of species interactions on trait evolution. Systematic Biology. In press.\n\n**Xu, L.**, H. Hildenbrandt and R. S. Etienne (2020). Incorporating eco-evolutionary interactions into a spatially explicit phylogenetic Janzen-Connell model predicts realistic macroecological and macroevolutionary patterns. To be submitted.","updated":"2022-09-17T02:04:05.658Z","path":"about/index.html","comments":1,"layout":"page","_id":"cl85g865e00004gkr284kcnpi","content":"<p>I am Liang Xu, a PhD student in theoretical biology in University of Groningen. I am focusing on modeling species interactions in macro eco-evolutionary science. I am interested in mathematical models as well as deep learning. You can find my CV <a href=\"./Liang_CV.pdf\"><strong>HERE</strong></a>.</p>\n<h2 id=\"Research-Interest\"><a href=\"#Research-Interest\" class=\"headerlink\" title=\"Research Interest\"></a>Research Interest</h2><p> A major challenge in ecology is the need for a better theoretical framework for understanding how species assemblages (ecological communities) arise, why some are species-rich and others species-poor, and why some species are present or dominant whereas others are not. I am interested in how to construct theoretical models to mimic the evolutionary processes and invent efficient tools with explanatory power to the evolutionary issues. This field involves mathematical modeling, Eco-evolutionary science, </p>\n<h2 id=\"Education\"><a href=\"#Education\" class=\"headerlink\" title=\"Education\"></a>Education</h2><p><strong>2015 - 2020</strong>  University of Groningen. PhD in Eco-evolution;<br>                      <strong>Dissertation thesis</strong>: <a href=\"https://doi.org/10.33612/diss.125954510\">Modelling species interactions in macroevolution and macroecology</a>.</p>\n<p><strong>2008 - 2010</strong> Hong Kong University. Master of Philosophy in Mathematics; Epidemic models of virus infection</p>\n<p><strong>2004 - 2008</strong> Beijing Normal University. Bachelor in Mathematics</p>\n<h2 id=\"Work-Experience\"><a href=\"#Work-Experience\" class=\"headerlink\" title=\"Work Experience\"></a>Work Experience</h2><p><strong>2010 - 2015</strong> Chongqing University of Technology &amp; Sciences. Lecturer in Department of Mathematics and Physics.</p>\n<h2 id=\"PhD-Projects\"><a href=\"#PhD-Projects\" class=\"headerlink\" title=\"PhD Projects\"></a>PhD Projects</h2><ul>\n<li><strong>Inferring local diversity-dependence</strong>.<br>It is still hotly debated that whether there exists ecological limit to diversity. A diversity-dependent diversification model has been developed to infer diversity-dependent signal. However, the model ignores local information. In this project, we aim to model the evolutionary processes incorporating the local details and check that if we can still detect the local diversity-dependence. </li>\n<li><strong>Inferring the effect of species interactions on trait evolution</strong>.<br>Ecology and evolution jointly help to form the pattern of traits of species. We construct an eco-evolutionary framework combing both ecological interaction and evolutionary history to describe how traits of species evolve under environmental stabilizing selection and species interactions. </li>\n<li><strong>A spatial phylogenetic Jancen-Connell extension to the neutral theory of species diversity</strong>.<br>The neutral theory of species diversity opens a new window to explain species assembly. However, the neutral assumption that all changes in distribution and abundance occur because of purely random variation in births, deaths, migration and speciation violates the recognition of the importance in species differences. Here, we focus on tree species and develop a spatial phylogenetic Jansen-Connell extension to the neutral theory. We aim to explore to what extent the additional mechanism indeed affects species assembly.</li>\n</ul>\n<h2 id=\"Publication\"><a href=\"#Publication\" class=\"headerlink\" title=\"Publication\"></a>Publication</h2><p><strong>Xu, L.</strong>, &amp; Etienne, R. S. (2018). Detecting local diversity-dependence in diversification. Evolution, 72(6), 1294-1305. DOI: 10.1111&#x2F;evo.13482 </p>\n<p><strong>Xu, L.</strong>, S. van Doorn, H. Hildenbrandt and R. S. Etienne (2020). Inferring the effect of species interactions on trait evolution. Systematic Biology. In press.</p>\n<p><strong>Xu, L.</strong>, H. Hildenbrandt and R. S. Etienne (2020). Incorporating eco-evolutionary interactions into a spatially explicit phylogenetic Janzen-Connell model predicts realistic macroecological and macroevolutionary patterns. To be submitted.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>I am Liang Xu, a PhD student in theoretical biology in University of Groningen. I am focusing on modeling species interactions in macro eco-evolutionary science. I am interested in mathematical models as well as deep learning. You can find my CV <a href=\"./Liang_CV.pdf\"><strong>HERE</strong></a>.</p>\n<h2 id=\"Research-Interest\"><a href=\"#Research-Interest\" class=\"headerlink\" title=\"Research Interest\"></a>Research Interest</h2><p> A major challenge in ecology is the need for a better theoretical framework for understanding how species assemblages (ecological communities) arise, why some are species-rich and others species-poor, and why some species are present or dominant whereas others are not. I am interested in how to construct theoretical models to mimic the evolutionary processes and invent efficient tools with explanatory power to the evolutionary issues. This field involves mathematical modeling, Eco-evolutionary science, </p>\n<h2 id=\"Education\"><a href=\"#Education\" class=\"headerlink\" title=\"Education\"></a>Education</h2><p><strong>2015 - 2020</strong>  University of Groningen. PhD in Eco-evolution;<br>                      <strong>Dissertation thesis</strong>: <a href=\"https://doi.org/10.33612/diss.125954510\">Modelling species interactions in macroevolution and macroecology</a>.</p>\n<p><strong>2008 - 2010</strong> Hong Kong University. Master of Philosophy in Mathematics; Epidemic models of virus infection</p>\n<p><strong>2004 - 2008</strong> Beijing Normal University. Bachelor in Mathematics</p>\n<h2 id=\"Work-Experience\"><a href=\"#Work-Experience\" class=\"headerlink\" title=\"Work Experience\"></a>Work Experience</h2><p><strong>2010 - 2015</strong> Chongqing University of Technology &amp; Sciences. Lecturer in Department of Mathematics and Physics.</p>\n<h2 id=\"PhD-Projects\"><a href=\"#PhD-Projects\" class=\"headerlink\" title=\"PhD Projects\"></a>PhD Projects</h2><ul>\n<li><strong>Inferring local diversity-dependence</strong>.<br>It is still hotly debated that whether there exists ecological limit to diversity. A diversity-dependent diversification model has been developed to infer diversity-dependent signal. However, the model ignores local information. In this project, we aim to model the evolutionary processes incorporating the local details and check that if we can still detect the local diversity-dependence. </li>\n<li><strong>Inferring the effect of species interactions on trait evolution</strong>.<br>Ecology and evolution jointly help to form the pattern of traits of species. We construct an eco-evolutionary framework combing both ecological interaction and evolutionary history to describe how traits of species evolve under environmental stabilizing selection and species interactions. </li>\n<li><strong>A spatial phylogenetic Jancen-Connell extension to the neutral theory of species diversity</strong>.<br>The neutral theory of species diversity opens a new window to explain species assembly. However, the neutral assumption that all changes in distribution and abundance occur because of purely random variation in births, deaths, migration and speciation violates the recognition of the importance in species differences. Here, we focus on tree species and develop a spatial phylogenetic Jansen-Connell extension to the neutral theory. We aim to explore to what extent the additional mechanism indeed affects species assembly.</li>\n</ul>\n<h2 id=\"Publication\"><a href=\"#Publication\" class=\"headerlink\" title=\"Publication\"></a>Publication</h2><p><strong>Xu, L.</strong>, &amp; Etienne, R. S. (2018). Detecting local diversity-dependence in diversification. Evolution, 72(6), 1294-1305. DOI: 10.1111&#x2F;evo.13482 </p>\n<p><strong>Xu, L.</strong>, S. van Doorn, H. Hildenbrandt and R. S. Etienne (2020). Inferring the effect of species interactions on trait evolution. Systematic Biology. In press.</p>\n<p><strong>Xu, L.</strong>, H. Hildenbrandt and R. S. Etienne (2020). Incorporating eco-evolutionary interactions into a spatially explicit phylogenetic Janzen-Connell model predicts realistic macroecological and macroevolutionary patterns. To be submitted.</p>\n"},{"title":"categories","date":"2018-10-23T00:11:12.000Z","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-10-22 17:11:12\nlayout: \"categories\"\n---\n","updated":"2022-09-17T04:52:56.210Z","path":"categories/index.html","comments":1,"_id":"cl85g865i00024gkrec4u65zn","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"All tags","date":"2018-10-23T00:04:18.000Z","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: All tags\ndate: 2018-10-22 17:04:18\nlayout: \"tags\"\n---\n","updated":"2022-09-17T04:53:00.641Z","path":"tags/index.html","comments":1,"_id":"cl85g865l00064gkr0vp61rdn","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Blogging tech","date":"2018-10-23T07:00:00.000Z","_content":"\nI am using [hexo](https://hexo.io/zh-cn/index.html) for blogging. The blog website is built on my personal [Github Page](https://xl0418.github.io/). The theme of the blog is [next](https://theme-next.iissnan.com/) which is a powerful tool to customize the blog. Here I would like to share/archive some useful tech for future use. \n\n<!--more-->\n\n## Optimizing the theme\nTwo posts are recommended here on [zhihu](https://zhuanlan.zhihu.com/p/30836436) and [CSDN](https://blog.csdn.net/qq_33699981/article/details/72716951). They almost contain all the custom adjustments for the theme. Of course, the official website [next](https://theme-next.iissnan.com/) is a good choice as well. \nAdvance tech to make your blog prettier is on this [website](https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html). Huge amount of tips and tricks are shown. \n\n## Materials\nTo look for some materials like pictures, icons, you can find a lot form [easyicon](https://www.easyicon.net/) and [fontawesome](https://fontawesome.com/) **for free**.","source":"_posts/2018-10-23-Blogging tech.md","raw":"---\ntitle: Blogging tech\ncategories: [Blogging, Blogging tech]\ntags: [Tech]\ndate: 2018-10-23\n\n---\n\nI am using [hexo](https://hexo.io/zh-cn/index.html) for blogging. The blog website is built on my personal [Github Page](https://xl0418.github.io/). The theme of the blog is [next](https://theme-next.iissnan.com/) which is a powerful tool to customize the blog. Here I would like to share/archive some useful tech for future use. \n\n<!--more-->\n\n## Optimizing the theme\nTwo posts are recommended here on [zhihu](https://zhuanlan.zhihu.com/p/30836436) and [CSDN](https://blog.csdn.net/qq_33699981/article/details/72716951). They almost contain all the custom adjustments for the theme. Of course, the official website [next](https://theme-next.iissnan.com/) is a good choice as well. \nAdvance tech to make your blog prettier is on this [website](https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html). Huge amount of tips and tricks are shown. \n\n## Materials\nTo look for some materials like pictures, icons, you can find a lot form [easyicon](https://www.easyicon.net/) and [fontawesome](https://fontawesome.com/) **for free**.","slug":"2018-10-23-Blogging tech","published":1,"updated":"2022-09-17T02:04:05.116Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl85g865g00014gkr7ues6xzi","content":"<p>I am using <a href=\"https://hexo.io/zh-cn/index.html\">hexo</a> for blogging. The blog website is built on my personal <a href=\"https://xl0418.github.io/\">Github Page</a>. The theme of the blog is <a href=\"https://theme-next.iissnan.com/\">next</a> which is a powerful tool to customize the blog. Here I would like to share&#x2F;archive some useful tech for future use. </p>\n<span id=\"more\"></span>\n\n<h2 id=\"Optimizing-the-theme\"><a href=\"#Optimizing-the-theme\" class=\"headerlink\" title=\"Optimizing the theme\"></a>Optimizing the theme</h2><p>Two posts are recommended here on <a href=\"https://zhuanlan.zhihu.com/p/30836436\">zhihu</a> and <a href=\"https://blog.csdn.net/qq_33699981/article/details/72716951\">CSDN</a>. They almost contain all the custom adjustments for the theme. Of course, the official website <a href=\"https://theme-next.iissnan.com/\">next</a> is a good choice as well.<br>Advance tech to make your blog prettier is on this <a href=\"https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html\">website</a>. Huge amount of tips and tricks are shown. </p>\n<h2 id=\"Materials\"><a href=\"#Materials\" class=\"headerlink\" title=\"Materials\"></a>Materials</h2><p>To look for some materials like pictures, icons, you can find a lot form <a href=\"https://www.easyicon.net/\">easyicon</a> and <a href=\"https://fontawesome.com/\">fontawesome</a> <strong>for free</strong>.</p>\n","site":{"data":{}},"excerpt":"<p>I am using <a href=\"https://hexo.io/zh-cn/index.html\">hexo</a> for blogging. The blog website is built on my personal <a href=\"https://xl0418.github.io/\">Github Page</a>. The theme of the blog is <a href=\"https://theme-next.iissnan.com/\">next</a> which is a powerful tool to customize the blog. Here I would like to share&#x2F;archive some useful tech for future use. </p>","more":"<h2 id=\"Optimizing-the-theme\"><a href=\"#Optimizing-the-theme\" class=\"headerlink\" title=\"Optimizing the theme\"></a>Optimizing the theme</h2><p>Two posts are recommended here on <a href=\"https://zhuanlan.zhihu.com/p/30836436\">zhihu</a> and <a href=\"https://blog.csdn.net/qq_33699981/article/details/72716951\">CSDN</a>. They almost contain all the custom adjustments for the theme. Of course, the official website <a href=\"https://theme-next.iissnan.com/\">next</a> is a good choice as well.<br>Advance tech to make your blog prettier is on this <a href=\"https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html\">website</a>. Huge amount of tips and tricks are shown. </p>\n<h2 id=\"Materials\"><a href=\"#Materials\" class=\"headerlink\" title=\"Materials\"></a>Materials</h2><p>To look for some materials like pictures, icons, you can find a lot form <a href=\"https://www.easyicon.net/\">easyicon</a> and <a href=\"https://fontawesome.com/\">fontawesome</a> <strong>for free</strong>.</p>"},{"title":"PhD Project 1-Detecting local diversity-dependence in diversification","date":"2018-10-22T07:00:00.000Z","_content":"\nWelcome to [Liang&apos;s blog](https://xl0418.github.io/)! This is my first PhD project since 2015 joining [Etienne&apos;s lab](https://www.rug.nl/staff/r.s.etienne/). You will find a brief introduction to this project. The code for the model can be found on my [GitHub](https://github.com/xl0418/code).\n\nThis my first formal research project starting from December of 2015 to February 2018 when the paper gets published. It seems to take quite a long time. Because I spent some time to switch from mathematics to evolutionary science and writing paper costs time as well. Anyway, to commemorate the first paper. \n\n<!--more-->\n## Abstract\nWhether there are ecological limits to species diversification is a hotly debated topic. Molecular phylogenies show slowdowns in lineage accumulation, suggesting that speciation rates decline with increasing diversity. A maximum likelihood method to detect diversity-dependent diversification from phylogenetic branching times exists, but it assumes that diversity-dependence is a global phenomenon and therefore ignores that the underlying species interactions are mostly local, and not all species in the phylogeny co-occur locally. Here, we explore whether this maximum likelihood method based on the non-spatial diversity-dependence model can detect local diversity-dependence, by applying it to phylogenies, simulated with a spatial stochastic model of local-diversity-dependent speciation, extinction and dispersal between two local communities. We find that type I errors (falsely detecting diversity-dependence) are low, and the power to detect diversity-dependence is high when dispersal rates are not too low. Interestingly, when dispersal is high the power to detect diversity-dependence is even higher than in the non-spatial model. Moreover, estimates of intrinsic speciation rate, extinction rate and ecological limit strongly depend on dispersal rate. We conclude that the non-spatial diversity-dependent approach can be used to detect diversity-dependence in clades of species that live in not too disconnected areas, but parameter estimates must be interpreted cautiously.\n\n## Model\nWe have developed a spatial diversity-dependent diversification model to explore if the global version of the diversity-dependence approach could detect the diversity-dependent signal on the spatial scenario. \n\n## Generating trees\nThe idea is simple. For simplicity, we build a two-location model and let species evolve (speciate: give birth to a new species/ extinction: one species goes extinct) in the regime. A pack of generated trees under different speciation rates and extinction rates and dispersal rates is like this (Scenario 2, see details in our paper):\n![Generating trees](2018-10-22-IntrotoPro1/Trees_S2.jpg)\n\n## Applying the bootstrapping analysis\nWe exploit the bootstrapping analysis to examine the power of the global approah to detect the signal of diversity-dependence on the spatial structered trees. The following tables show the power of the global tool for signal detection under different parameter combinations and scenarios.\n![Power of the method](2018-10-22-IntrotoPro1/Powertable.jpg)\n\n## Parameter inference\nAs due to the complexity of the model, an analytical likelihood function is not possible to achieve. Therefore, we test if the global likelihood approach can recover the parameters on the spatial model or show some patterns.\n![Parameter inference](2018-10-22-IntrotoPro1/Est_S2VS.jpg)\n\n## Conclusion\nFrom the results above, the conclusion is clear. Please see our paper:-)\n\n## Reference\nXu, L., & Etienne, R. S. (2018). Detecting local diversity-dependence in diversification. Evolution, 72(6), 1294-1305. DOI: 10.1111/evo.13482 \n  \nEtienne, R. S., Pigot, A. L., & Phillimore, A. B. (2016). How reliably can we infer diversity-dependent diversification from phylogenies? Methods in ecology and evolution, 7(9), 1092-1099. DOI: 10.1111/2041-210X.12565\n\nEtienne, R. S., Haegeman, B., Stadler, T., Aze, T., Pearson, P. N., Purvis, A., & Phillimore, A. B. (2012). Diversity-dependence brings molecular phylogenies closer to agreement with the fossil record. Proceedings of the Royal Society of London. Series B, Biological Sciences, 279(1732), 1300-1309. DOI: 10.1098/rspb.2011.1439\n","source":"_posts/2018-10-22-IntrotoPro1.md","raw":"---\ntitle: PhD Project 1-Detecting local diversity-dependence in diversification\ncategories: [Research,Phd projects]\ntags: [evolution,mathematical modeling,diversity-dependence]\ndate: 2018-10-22\n\n---\n\nWelcome to [Liang&apos;s blog](https://xl0418.github.io/)! This is my first PhD project since 2015 joining [Etienne&apos;s lab](https://www.rug.nl/staff/r.s.etienne/). You will find a brief introduction to this project. The code for the model can be found on my [GitHub](https://github.com/xl0418/code).\n\nThis my first formal research project starting from December of 2015 to February 2018 when the paper gets published. It seems to take quite a long time. Because I spent some time to switch from mathematics to evolutionary science and writing paper costs time as well. Anyway, to commemorate the first paper. \n\n<!--more-->\n## Abstract\nWhether there are ecological limits to species diversification is a hotly debated topic. Molecular phylogenies show slowdowns in lineage accumulation, suggesting that speciation rates decline with increasing diversity. A maximum likelihood method to detect diversity-dependent diversification from phylogenetic branching times exists, but it assumes that diversity-dependence is a global phenomenon and therefore ignores that the underlying species interactions are mostly local, and not all species in the phylogeny co-occur locally. Here, we explore whether this maximum likelihood method based on the non-spatial diversity-dependence model can detect local diversity-dependence, by applying it to phylogenies, simulated with a spatial stochastic model of local-diversity-dependent speciation, extinction and dispersal between two local communities. We find that type I errors (falsely detecting diversity-dependence) are low, and the power to detect diversity-dependence is high when dispersal rates are not too low. Interestingly, when dispersal is high the power to detect diversity-dependence is even higher than in the non-spatial model. Moreover, estimates of intrinsic speciation rate, extinction rate and ecological limit strongly depend on dispersal rate. We conclude that the non-spatial diversity-dependent approach can be used to detect diversity-dependence in clades of species that live in not too disconnected areas, but parameter estimates must be interpreted cautiously.\n\n## Model\nWe have developed a spatial diversity-dependent diversification model to explore if the global version of the diversity-dependence approach could detect the diversity-dependent signal on the spatial scenario. \n\n## Generating trees\nThe idea is simple. For simplicity, we build a two-location model and let species evolve (speciate: give birth to a new species/ extinction: one species goes extinct) in the regime. A pack of generated trees under different speciation rates and extinction rates and dispersal rates is like this (Scenario 2, see details in our paper):\n![Generating trees](2018-10-22-IntrotoPro1/Trees_S2.jpg)\n\n## Applying the bootstrapping analysis\nWe exploit the bootstrapping analysis to examine the power of the global approah to detect the signal of diversity-dependence on the spatial structered trees. The following tables show the power of the global tool for signal detection under different parameter combinations and scenarios.\n![Power of the method](2018-10-22-IntrotoPro1/Powertable.jpg)\n\n## Parameter inference\nAs due to the complexity of the model, an analytical likelihood function is not possible to achieve. Therefore, we test if the global likelihood approach can recover the parameters on the spatial model or show some patterns.\n![Parameter inference](2018-10-22-IntrotoPro1/Est_S2VS.jpg)\n\n## Conclusion\nFrom the results above, the conclusion is clear. Please see our paper:-)\n\n## Reference\nXu, L., & Etienne, R. S. (2018). Detecting local diversity-dependence in diversification. Evolution, 72(6), 1294-1305. DOI: 10.1111/evo.13482 \n  \nEtienne, R. S., Pigot, A. L., & Phillimore, A. B. (2016). How reliably can we infer diversity-dependent diversification from phylogenies? Methods in ecology and evolution, 7(9), 1092-1099. DOI: 10.1111/2041-210X.12565\n\nEtienne, R. S., Haegeman, B., Stadler, T., Aze, T., Pearson, P. N., Purvis, A., & Phillimore, A. B. (2012). Diversity-dependence brings molecular phylogenies closer to agreement with the fossil record. Proceedings of the Royal Society of London. Series B, Biological Sciences, 279(1732), 1300-1309. DOI: 10.1098/rspb.2011.1439\n","slug":"2018-10-22-IntrotoPro1","published":1,"updated":"2022-09-17T04:52:17.351Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl85g865i00034gkr2j0v09x9","content":"<p>Welcome to <a href=\"https://xl0418.github.io/\">Liang&amp;apos;s blog</a>! This is my first PhD project since 2015 joining <a href=\"https://www.rug.nl/staff/r.s.etienne/\">Etienne&amp;apos;s lab</a>. You will find a brief introduction to this project. The code for the model can be found on my <a href=\"https://github.com/xl0418/code\">GitHub</a>.</p>\n<p>This my first formal research project starting from December of 2015 to February 2018 when the paper gets published. It seems to take quite a long time. Because I spent some time to switch from mathematics to evolutionary science and writing paper costs time as well. Anyway, to commemorate the first paper. </p>\n<span id=\"more\"></span>\n<h2 id=\"Abstract\"><a href=\"#Abstract\" class=\"headerlink\" title=\"Abstract\"></a>Abstract</h2><p>Whether there are ecological limits to species diversification is a hotly debated topic. Molecular phylogenies show slowdowns in lineage accumulation, suggesting that speciation rates decline with increasing diversity. A maximum likelihood method to detect diversity-dependent diversification from phylogenetic branching times exists, but it assumes that diversity-dependence is a global phenomenon and therefore ignores that the underlying species interactions are mostly local, and not all species in the phylogeny co-occur locally. Here, we explore whether this maximum likelihood method based on the non-spatial diversity-dependence model can detect local diversity-dependence, by applying it to phylogenies, simulated with a spatial stochastic model of local-diversity-dependent speciation, extinction and dispersal between two local communities. We find that type I errors (falsely detecting diversity-dependence) are low, and the power to detect diversity-dependence is high when dispersal rates are not too low. Interestingly, when dispersal is high the power to detect diversity-dependence is even higher than in the non-spatial model. Moreover, estimates of intrinsic speciation rate, extinction rate and ecological limit strongly depend on dispersal rate. We conclude that the non-spatial diversity-dependent approach can be used to detect diversity-dependence in clades of species that live in not too disconnected areas, but parameter estimates must be interpreted cautiously.</p>\n<h2 id=\"Model\"><a href=\"#Model\" class=\"headerlink\" title=\"Model\"></a>Model</h2><p>We have developed a spatial diversity-dependent diversification model to explore if the global version of the diversity-dependence approach could detect the diversity-dependent signal on the spatial scenario. </p>\n<h2 id=\"Generating-trees\"><a href=\"#Generating-trees\" class=\"headerlink\" title=\"Generating trees\"></a>Generating trees</h2><p>The idea is simple. For simplicity, we build a two-location model and let species evolve (speciate: give birth to a new species&#x2F; extinction: one species goes extinct) in the regime. A pack of generated trees under different speciation rates and extinction rates and dispersal rates is like this (Scenario 2, see details in our paper):<br><img src=\"/2018-10-22-IntrotoPro1/Trees_S2.jpg\" alt=\"Generating trees\"></p>\n<h2 id=\"Applying-the-bootstrapping-analysis\"><a href=\"#Applying-the-bootstrapping-analysis\" class=\"headerlink\" title=\"Applying the bootstrapping analysis\"></a>Applying the bootstrapping analysis</h2><p>We exploit the bootstrapping analysis to examine the power of the global approah to detect the signal of diversity-dependence on the spatial structered trees. The following tables show the power of the global tool for signal detection under different parameter combinations and scenarios.<br><img src=\"/2018-10-22-IntrotoPro1/Powertable.jpg\" alt=\"Power of the method\"></p>\n<h2 id=\"Parameter-inference\"><a href=\"#Parameter-inference\" class=\"headerlink\" title=\"Parameter inference\"></a>Parameter inference</h2><p>As due to the complexity of the model, an analytical likelihood function is not possible to achieve. Therefore, we test if the global likelihood approach can recover the parameters on the spatial model or show some patterns.<br><img src=\"/2018-10-22-IntrotoPro1/Est_S2VS.jpg\" alt=\"Parameter inference\"></p>\n<h2 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h2><p>From the results above, the conclusion is clear. Please see our paper:-)</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p>Xu, L., &amp; Etienne, R. S. (2018). Detecting local diversity-dependence in diversification. Evolution, 72(6), 1294-1305. DOI: 10.1111&#x2F;evo.13482 </p>\n<p>Etienne, R. S., Pigot, A. L., &amp; Phillimore, A. B. (2016). How reliably can we infer diversity-dependent diversification from phylogenies? Methods in ecology and evolution, 7(9), 1092-1099. DOI: 10.1111&#x2F;2041-210X.12565</p>\n<p>Etienne, R. S., Haegeman, B., Stadler, T., Aze, T., Pearson, P. N., Purvis, A., &amp; Phillimore, A. B. (2012). Diversity-dependence brings molecular phylogenies closer to agreement with the fossil record. Proceedings of the Royal Society of London. Series B, Biological Sciences, 279(1732), 1300-1309. DOI: 10.1098&#x2F;rspb.2011.1439</p>\n","site":{"data":{}},"excerpt":"<p>Welcome to <a href=\"https://xl0418.github.io/\">Liang&amp;apos;s blog</a>! This is my first PhD project since 2015 joining <a href=\"https://www.rug.nl/staff/r.s.etienne/\">Etienne&amp;apos;s lab</a>. You will find a brief introduction to this project. The code for the model can be found on my <a href=\"https://github.com/xl0418/code\">GitHub</a>.</p>\n<p>This my first formal research project starting from December of 2015 to February 2018 when the paper gets published. It seems to take quite a long time. Because I spent some time to switch from mathematics to evolutionary science and writing paper costs time as well. Anyway, to commemorate the first paper. </p>","more":"<h2 id=\"Abstract\"><a href=\"#Abstract\" class=\"headerlink\" title=\"Abstract\"></a>Abstract</h2><p>Whether there are ecological limits to species diversification is a hotly debated topic. Molecular phylogenies show slowdowns in lineage accumulation, suggesting that speciation rates decline with increasing diversity. A maximum likelihood method to detect diversity-dependent diversification from phylogenetic branching times exists, but it assumes that diversity-dependence is a global phenomenon and therefore ignores that the underlying species interactions are mostly local, and not all species in the phylogeny co-occur locally. Here, we explore whether this maximum likelihood method based on the non-spatial diversity-dependence model can detect local diversity-dependence, by applying it to phylogenies, simulated with a spatial stochastic model of local-diversity-dependent speciation, extinction and dispersal between two local communities. We find that type I errors (falsely detecting diversity-dependence) are low, and the power to detect diversity-dependence is high when dispersal rates are not too low. Interestingly, when dispersal is high the power to detect diversity-dependence is even higher than in the non-spatial model. Moreover, estimates of intrinsic speciation rate, extinction rate and ecological limit strongly depend on dispersal rate. We conclude that the non-spatial diversity-dependent approach can be used to detect diversity-dependence in clades of species that live in not too disconnected areas, but parameter estimates must be interpreted cautiously.</p>\n<h2 id=\"Model\"><a href=\"#Model\" class=\"headerlink\" title=\"Model\"></a>Model</h2><p>We have developed a spatial diversity-dependent diversification model to explore if the global version of the diversity-dependence approach could detect the diversity-dependent signal on the spatial scenario. </p>\n<h2 id=\"Generating-trees\"><a href=\"#Generating-trees\" class=\"headerlink\" title=\"Generating trees\"></a>Generating trees</h2><p>The idea is simple. For simplicity, we build a two-location model and let species evolve (speciate: give birth to a new species&#x2F; extinction: one species goes extinct) in the regime. A pack of generated trees under different speciation rates and extinction rates and dispersal rates is like this (Scenario 2, see details in our paper):<br><img src=\"/2018-10-22-IntrotoPro1/Trees_S2.jpg\" alt=\"Generating trees\"></p>\n<h2 id=\"Applying-the-bootstrapping-analysis\"><a href=\"#Applying-the-bootstrapping-analysis\" class=\"headerlink\" title=\"Applying the bootstrapping analysis\"></a>Applying the bootstrapping analysis</h2><p>We exploit the bootstrapping analysis to examine the power of the global approah to detect the signal of diversity-dependence on the spatial structered trees. The following tables show the power of the global tool for signal detection under different parameter combinations and scenarios.<br><img src=\"/2018-10-22-IntrotoPro1/Powertable.jpg\" alt=\"Power of the method\"></p>\n<h2 id=\"Parameter-inference\"><a href=\"#Parameter-inference\" class=\"headerlink\" title=\"Parameter inference\"></a>Parameter inference</h2><p>As due to the complexity of the model, an analytical likelihood function is not possible to achieve. Therefore, we test if the global likelihood approach can recover the parameters on the spatial model or show some patterns.<br><img src=\"/2018-10-22-IntrotoPro1/Est_S2VS.jpg\" alt=\"Parameter inference\"></p>\n<h2 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h2><p>From the results above, the conclusion is clear. Please see our paper:-)</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p>Xu, L., &amp; Etienne, R. S. (2018). Detecting local diversity-dependence in diversification. Evolution, 72(6), 1294-1305. DOI: 10.1111&#x2F;evo.13482 </p>\n<p>Etienne, R. S., Pigot, A. L., &amp; Phillimore, A. B. (2016). How reliably can we infer diversity-dependent diversification from phylogenies? Methods in ecology and evolution, 7(9), 1092-1099. DOI: 10.1111&#x2F;2041-210X.12565</p>\n<p>Etienne, R. S., Haegeman, B., Stadler, T., Aze, T., Pearson, P. N., Purvis, A., &amp; Phillimore, A. B. (2012). Diversity-dependence brings molecular phylogenies closer to agreement with the fossil record. Proceedings of the Royal Society of London. Series B, Biological Sciences, 279(1732), 1300-1309. DOI: 10.1098&#x2F;rspb.2011.1439</p>"},{"title":"Deriving the Fokker-Planck equation from a stochastic differential equation","date":"2018-10-24T07:00:00.000Z","_content":"\nWriting a periodic progress report is a good way to record the process that you gain knowledge. Reviewing my progress reports in the last 3 years, it recovers my memory about the knowledge and technologies that I almost forgot as I rarely use them. From this post on, I would like to give them a review and share on the blog. Hope it can help people who are interest in and one can help me if I am wrong at somewhere. \n\n<!--more-->\n\n## Derivation\nHere I briefly present the derivation for the Fokker-Planck equation from a stochastic differential equation.\n\nGiven the stochastic process \n\n$$\ndx=a(x,t)dt+b(x,t)dW_{t}\n$$\n\nwhere \\\\(W_{t}\\\\) is a Wiener process. By Ito lemma, for any twice-differentiable scalar function \\\\(f(x)\\\\) we have \n\n$$\ndf(x)=\\left\\(a(x,t)f'(x)+\\frac{1}{2}b^{2}(x,t)f''(x)\\right\\)dt+b(x,t)f'(x)dW_{t}\n$$\n\nThe expectation of \\\\(f(x,t)\\\\) yields\n\n$$\nE(f(x))=\\int f(x)p(x,t)dx\n$$\n\nand take the derivative\n\n$$\n\\frac{dE(f(x))}{dt}=\\frac{d\\int f(x)p(x,t)dx}{dt}=\\int f(x)\\frac{\\partial p(x,t)}{\\partial t}dx \\tag{1}\n$$\n\nAlso, we could plug Eq.[1] in the expectation of \\\\(f(x)\\\\) and take the derivative yields\n\n$$\n\\frac{dE(f(x))}{dt}=\\frac{E(df(x))}{dt}=E\\left\\(a(x,t)f'(x)+\\frac{1}{2}b^{2}(x,t)f''(x)\\right\\) \\tag{2}\n$$\n\nFrom that Eq.[1] and Eq.[2] are identical, we have\n\n$$\n\\begin{align}\n\\int f(x)\\frac{\\partial p(x,t)}{\\partial t}dx\t&=\\int\\left\\(a(x,t)f'(x)+\\frac{1}{2}b^{2}(x,t)f''(x)\\right\\)p(x,t)dx \\\\\\\\\n\t& =\\int a(x,t)f'(x)p(x,t)dx+\\frac{1}{2}\\int b^{2}(x,t)f''(x)p(x,t)dx  \\\\\\\\\n\t& =-\\int f(x)\\frac{\\partial a(x,t)p(x,t)}{\\partial x}dx+\\frac{1}{2}\\int f(x)\\frac{\\partial^{2}b^{2}(x,t)p(x,t)}{\\partial x^{2}}dx  \\\\\\\\\n\t& =\\int f(x)\\left\\(-\\frac{\\partial a(x,t)p(x,t)}{\\partial x}+\\frac{1}{2}\\frac{\\partial^{2}b^{2}(x,t)p(x,t)}{\\partial x^{2}}\\right\\)dx\n\\end{align}\n$$\n\nAs \\\\(f(x)\\\\) is arbitrary, we obtain the Fokker-Planck equation in one dimension\n\n$$\n\\frac{\\partial p(x,t)}{\\partial t}=-\\frac{\\partial a(x,t)p(x,t)}{\\partial x}+\\frac{1}{2}\\frac{\\partial^{2}b^{2}(x,t)p(x,t)}{\\partial x^{2}}\n$$\n\n<script type=\"text/javascript\" src=\"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default\"></script>","source":"_posts/2018-10-24-derivingFPequ.md","raw":"---\ntitle: Deriving the Fokker-Planck equation from a stochastic differential equation\ncategories: [Research, Stochastic differential equations]\ntags: [the Fokker-Planck equation,stochastic differential equation,mathematical modeling,math]\ndate: 2018-10-24\n\n---\n\nWriting a periodic progress report is a good way to record the process that you gain knowledge. Reviewing my progress reports in the last 3 years, it recovers my memory about the knowledge and technologies that I almost forgot as I rarely use them. From this post on, I would like to give them a review and share on the blog. Hope it can help people who are interest in and one can help me if I am wrong at somewhere. \n\n<!--more-->\n\n## Derivation\nHere I briefly present the derivation for the Fokker-Planck equation from a stochastic differential equation.\n\nGiven the stochastic process \n\n$$\ndx=a(x,t)dt+b(x,t)dW_{t}\n$$\n\nwhere \\\\(W_{t}\\\\) is a Wiener process. By Ito lemma, for any twice-differentiable scalar function \\\\(f(x)\\\\) we have \n\n$$\ndf(x)=\\left\\(a(x,t)f'(x)+\\frac{1}{2}b^{2}(x,t)f''(x)\\right\\)dt+b(x,t)f'(x)dW_{t}\n$$\n\nThe expectation of \\\\(f(x,t)\\\\) yields\n\n$$\nE(f(x))=\\int f(x)p(x,t)dx\n$$\n\nand take the derivative\n\n$$\n\\frac{dE(f(x))}{dt}=\\frac{d\\int f(x)p(x,t)dx}{dt}=\\int f(x)\\frac{\\partial p(x,t)}{\\partial t}dx \\tag{1}\n$$\n\nAlso, we could plug Eq.[1] in the expectation of \\\\(f(x)\\\\) and take the derivative yields\n\n$$\n\\frac{dE(f(x))}{dt}=\\frac{E(df(x))}{dt}=E\\left\\(a(x,t)f'(x)+\\frac{1}{2}b^{2}(x,t)f''(x)\\right\\) \\tag{2}\n$$\n\nFrom that Eq.[1] and Eq.[2] are identical, we have\n\n$$\n\\begin{align}\n\\int f(x)\\frac{\\partial p(x,t)}{\\partial t}dx\t&=\\int\\left\\(a(x,t)f'(x)+\\frac{1}{2}b^{2}(x,t)f''(x)\\right\\)p(x,t)dx \\\\\\\\\n\t& =\\int a(x,t)f'(x)p(x,t)dx+\\frac{1}{2}\\int b^{2}(x,t)f''(x)p(x,t)dx  \\\\\\\\\n\t& =-\\int f(x)\\frac{\\partial a(x,t)p(x,t)}{\\partial x}dx+\\frac{1}{2}\\int f(x)\\frac{\\partial^{2}b^{2}(x,t)p(x,t)}{\\partial x^{2}}dx  \\\\\\\\\n\t& =\\int f(x)\\left\\(-\\frac{\\partial a(x,t)p(x,t)}{\\partial x}+\\frac{1}{2}\\frac{\\partial^{2}b^{2}(x,t)p(x,t)}{\\partial x^{2}}\\right\\)dx\n\\end{align}\n$$\n\nAs \\\\(f(x)\\\\) is arbitrary, we obtain the Fokker-Planck equation in one dimension\n\n$$\n\\frac{\\partial p(x,t)}{\\partial t}=-\\frac{\\partial a(x,t)p(x,t)}{\\partial x}+\\frac{1}{2}\\frac{\\partial^{2}b^{2}(x,t)p(x,t)}{\\partial x^{2}}\n$$\n\n<script type=\"text/javascript\" src=\"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default\"></script>","slug":"2018-10-24-derivingFPequ","published":1,"updated":"2022-09-17T02:04:05.116Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl85g865l00074gkr2rek13ea","content":"<p>Writing a periodic progress report is a good way to record the process that you gain knowledge. Reviewing my progress reports in the last 3 years, it recovers my memory about the knowledge and technologies that I almost forgot as I rarely use them. From this post on, I would like to give them a review and share on the blog. Hope it can help people who are interest in and one can help me if I am wrong at somewhere. </p>\n<span id=\"more\"></span>\n\n<h2 id=\"Derivation\"><a href=\"#Derivation\" class=\"headerlink\" title=\"Derivation\"></a>Derivation</h2><p>Here I briefly present the derivation for the Fokker-Planck equation from a stochastic differential equation.</p>\n<p>Given the stochastic process </p>\n<p>$$<br>dx&#x3D;a(x,t)dt+b(x,t)dW_{t}<br>$$</p>\n<p>where \\(W_{t}\\) is a Wiener process. By Ito lemma, for any twice-differentiable scalar function \\(f(x)\\) we have </p>\n<p>$$<br>df(x)&#x3D;\\left(a(x,t)f’(x)+\\frac{1}{2}b^{2}(x,t)f’’(x)\\right)dt+b(x,t)f’(x)dW_{t}<br>$$</p>\n<p>The expectation of \\(f(x,t)\\) yields</p>\n<p>$$<br>E(f(x))&#x3D;\\int f(x)p(x,t)dx<br>$$</p>\n<p>and take the derivative</p>\n<p>$$<br>\\frac{dE(f(x))}{dt}&#x3D;\\frac{d\\int f(x)p(x,t)dx}{dt}&#x3D;\\int f(x)\\frac{\\partial p(x,t)}{\\partial t}dx \\tag{1}<br>$$</p>\n<p>Also, we could plug Eq.[1] in the expectation of \\(f(x)\\) and take the derivative yields</p>\n<p>$$<br>\\frac{dE(f(x))}{dt}&#x3D;\\frac{E(df(x))}{dt}&#x3D;E\\left(a(x,t)f’(x)+\\frac{1}{2}b^{2}(x,t)f’’(x)\\right) \\tag{2}<br>$$</p>\n<p>From that Eq.[1] and Eq.[2] are identical, we have</p>\n<p>$$<br>\\begin{align}<br>\\int f(x)\\frac{\\partial p(x,t)}{\\partial t}dx\t&amp;&#x3D;\\int\\left(a(x,t)f’(x)+\\frac{1}{2}b^{2}(x,t)f’’(x)\\right)p(x,t)dx \\\\<br>    &amp; &#x3D;\\int a(x,t)f’(x)p(x,t)dx+\\frac{1}{2}\\int b^{2}(x,t)f’’(x)p(x,t)dx  \\\\<br>    &amp; &#x3D;-\\int f(x)\\frac{\\partial a(x,t)p(x,t)}{\\partial x}dx+\\frac{1}{2}\\int f(x)\\frac{\\partial^{2}b^{2}(x,t)p(x,t)}{\\partial x^{2}}dx  \\\\<br>    &amp; &#x3D;\\int f(x)\\left(-\\frac{\\partial a(x,t)p(x,t)}{\\partial x}+\\frac{1}{2}\\frac{\\partial^{2}b^{2}(x,t)p(x,t)}{\\partial x^{2}}\\right)dx<br>\\end{align}<br>$$</p>\n<p>As \\(f(x)\\) is arbitrary, we obtain the Fokker-Planck equation in one dimension</p>\n<p>$$<br>\\frac{\\partial p(x,t)}{\\partial t}&#x3D;-\\frac{\\partial a(x,t)p(x,t)}{\\partial x}+\\frac{1}{2}\\frac{\\partial^{2}b^{2}(x,t)p(x,t)}{\\partial x^{2}}<br>$$</p>\n<script type=\"text/javascript\" src=\"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default\"></script>","site":{"data":{}},"excerpt":"<p>Writing a periodic progress report is a good way to record the process that you gain knowledge. Reviewing my progress reports in the last 3 years, it recovers my memory about the knowledge and technologies that I almost forgot as I rarely use them. From this post on, I would like to give them a review and share on the blog. Hope it can help people who are interest in and one can help me if I am wrong at somewhere. </p>","more":"<h2 id=\"Derivation\"><a href=\"#Derivation\" class=\"headerlink\" title=\"Derivation\"></a>Derivation</h2><p>Here I briefly present the derivation for the Fokker-Planck equation from a stochastic differential equation.</p>\n<p>Given the stochastic process </p>\n<p>$$<br>dx&#x3D;a(x,t)dt+b(x,t)dW_{t}<br>$$</p>\n<p>where \\(W_{t}\\) is a Wiener process. By Ito lemma, for any twice-differentiable scalar function \\(f(x)\\) we have </p>\n<p>$$<br>df(x)&#x3D;\\left(a(x,t)f’(x)+\\frac{1}{2}b^{2}(x,t)f’’(x)\\right)dt+b(x,t)f’(x)dW_{t}<br>$$</p>\n<p>The expectation of \\(f(x,t)\\) yields</p>\n<p>$$<br>E(f(x))&#x3D;\\int f(x)p(x,t)dx<br>$$</p>\n<p>and take the derivative</p>\n<p>$$<br>\\frac{dE(f(x))}{dt}&#x3D;\\frac{d\\int f(x)p(x,t)dx}{dt}&#x3D;\\int f(x)\\frac{\\partial p(x,t)}{\\partial t}dx \\tag{1}<br>$$</p>\n<p>Also, we could plug Eq.[1] in the expectation of \\(f(x)\\) and take the derivative yields</p>\n<p>$$<br>\\frac{dE(f(x))}{dt}&#x3D;\\frac{E(df(x))}{dt}&#x3D;E\\left(a(x,t)f’(x)+\\frac{1}{2}b^{2}(x,t)f’’(x)\\right) \\tag{2}<br>$$</p>\n<p>From that Eq.[1] and Eq.[2] are identical, we have</p>\n<p>$$<br>\\begin{align}<br>\\int f(x)\\frac{\\partial p(x,t)}{\\partial t}dx\t&amp;&#x3D;\\int\\left(a(x,t)f’(x)+\\frac{1}{2}b^{2}(x,t)f’’(x)\\right)p(x,t)dx \\\\<br>    &amp; &#x3D;\\int a(x,t)f’(x)p(x,t)dx+\\frac{1}{2}\\int b^{2}(x,t)f’’(x)p(x,t)dx  \\\\<br>    &amp; &#x3D;-\\int f(x)\\frac{\\partial a(x,t)p(x,t)}{\\partial x}dx+\\frac{1}{2}\\int f(x)\\frac{\\partial^{2}b^{2}(x,t)p(x,t)}{\\partial x^{2}}dx  \\\\<br>    &amp; &#x3D;\\int f(x)\\left(-\\frac{\\partial a(x,t)p(x,t)}{\\partial x}+\\frac{1}{2}\\frac{\\partial^{2}b^{2}(x,t)p(x,t)}{\\partial x^{2}}\\right)dx<br>\\end{align}<br>$$</p>\n<p>As \\(f(x)\\) is arbitrary, we obtain the Fokker-Planck equation in one dimension</p>\n<p>$$<br>\\frac{\\partial p(x,t)}{\\partial t}&#x3D;-\\frac{\\partial a(x,t)p(x,t)}{\\partial x}+\\frac{1}{2}\\frac{\\partial^{2}b^{2}(x,t)p(x,t)}{\\partial x^{2}}<br>$$</p>\n<script type=\"text/javascript\" src=\"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default\"></script>"},{"title":"phylo2L function","date":"2018-10-24T07:00:00.000Z","_content":"\nI guess this function is specially useful to [our group](https://www.rug.nl/staff/r.s.etienne/) in which we play with L table. \n\nL table is an alternative way to a phylo class for phylogenetic information storage. The function `L2phylo` has been implemented in the [DDD package](https://cran.r-project.org/web/packages/DDD/index.html) that converts an L table to a phylo class. This function `phylo2L` does the conversion the other way around. Thus, if you want to apply your model to an empirical data. This may be useful to you.\n\n<!--more-->\n\n`phylo2L` function can be found [here](https://github.com/xl0418/Code/blob/99133e6e5744be7382c038edc5701cd494d8e76c/Pro2/R_p2/phylo2L.R) if you want to improve the function. I have verified it by examining if \n\n```R  \nL=phylo2L(L2phylo(L))\n```\n\nNotice that `phylo2L` doesn't have the argument `dropextinct` as what `L2phylo` has. Because to my perspective L table should be consistent with the given phylo class. But if you have a full tree on hand and want to prune it, you can do it like this\n\n```R \nprune_phylo = L2phylo(phylo2L(full tree), dropextinct = TRUE)\nprune_L = phylo2L(prune_phylo)\n```\n\nOr you can use [`pruneL`](https://github.com/xl0418/Code/blob/f4dfd4acc15af6855572fb4659f396cea14bb83b/Pro2/R_p2/pruneL.R) function that I have developed to prune an L table. More details on `pruneL` function can be found in this [post](https://xl0418.github.io/2018/10/24/2018-10-24-pruneLfunction/).","source":"_posts/2018-10-24-phylo2Lfunction.md","raw":"---\ntitle: phylo2L function\ncategories: [Research,R,phylogeny function]\ntags: [phylogeny,phylo class,L table,DDD package,pruneL,phylo2L]\ndate: 2018-10-24\n\n---\n\nI guess this function is specially useful to [our group](https://www.rug.nl/staff/r.s.etienne/) in which we play with L table. \n\nL table is an alternative way to a phylo class for phylogenetic information storage. The function `L2phylo` has been implemented in the [DDD package](https://cran.r-project.org/web/packages/DDD/index.html) that converts an L table to a phylo class. This function `phylo2L` does the conversion the other way around. Thus, if you want to apply your model to an empirical data. This may be useful to you.\n\n<!--more-->\n\n`phylo2L` function can be found [here](https://github.com/xl0418/Code/blob/99133e6e5744be7382c038edc5701cd494d8e76c/Pro2/R_p2/phylo2L.R) if you want to improve the function. I have verified it by examining if \n\n```R  \nL=phylo2L(L2phylo(L))\n```\n\nNotice that `phylo2L` doesn't have the argument `dropextinct` as what `L2phylo` has. Because to my perspective L table should be consistent with the given phylo class. But if you have a full tree on hand and want to prune it, you can do it like this\n\n```R \nprune_phylo = L2phylo(phylo2L(full tree), dropextinct = TRUE)\nprune_L = phylo2L(prune_phylo)\n```\n\nOr you can use [`pruneL`](https://github.com/xl0418/Code/blob/f4dfd4acc15af6855572fb4659f396cea14bb83b/Pro2/R_p2/pruneL.R) function that I have developed to prune an L table. More details on `pruneL` function can be found in this [post](https://xl0418.github.io/2018/10/24/2018-10-24-pruneLfunction/).","slug":"2018-10-24-phylo2Lfunction","published":1,"updated":"2022-09-17T02:04:05.116Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl85g865m00084gkr7oephe2y","content":"<p>I guess this function is specially useful to <a href=\"https://www.rug.nl/staff/r.s.etienne/\">our group</a> in which we play with L table. </p>\n<p>L table is an alternative way to a phylo class for phylogenetic information storage. The function <code>L2phylo</code> has been implemented in the <a href=\"https://cran.r-project.org/web/packages/DDD/index.html\">DDD package</a> that converts an L table to a phylo class. This function <code>phylo2L</code> does the conversion the other way around. Thus, if you want to apply your model to an empirical data. This may be useful to you.</p>\n<span id=\"more\"></span>\n\n<p><code>phylo2L</code> function can be found <a href=\"https://github.com/xl0418/Code/blob/99133e6e5744be7382c038edc5701cd494d8e76c/Pro2/R_p2/phylo2L.R\">here</a> if you want to improve the function. I have verified it by examining if </p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">L<span class=\"operator\">=</span>phylo2L<span class=\"punctuation\">(</span>L2phylo<span class=\"punctuation\">(</span>L<span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>Notice that <code>phylo2L</code> doesn’t have the argument <code>dropextinct</code> as what <code>L2phylo</code> has. Because to my perspective L table should be consistent with the given phylo class. But if you have a full tree on hand and want to prune it, you can do it like this</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">prune_phylo <span class=\"operator\">=</span> L2phylo<span class=\"punctuation\">(</span>phylo2L<span class=\"punctuation\">(</span>full tree<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> dropextinct <span class=\"operator\">=</span> <span class=\"literal\">TRUE</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">prune_L <span class=\"operator\">=</span> phylo2L<span class=\"punctuation\">(</span>prune_phylo<span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>Or you can use <a href=\"https://github.com/xl0418/Code/blob/f4dfd4acc15af6855572fb4659f396cea14bb83b/Pro2/R_p2/pruneL.R\"><code>pruneL</code></a> function that I have developed to prune an L table. More details on <code>pruneL</code> function can be found in this <a href=\"https://xl0418.github.io/2018/10/24/2018-10-24-pruneLfunction/\">post</a>.</p>\n","site":{"data":{}},"excerpt":"<p>I guess this function is specially useful to <a href=\"https://www.rug.nl/staff/r.s.etienne/\">our group</a> in which we play with L table. </p>\n<p>L table is an alternative way to a phylo class for phylogenetic information storage. The function <code>L2phylo</code> has been implemented in the <a href=\"https://cran.r-project.org/web/packages/DDD/index.html\">DDD package</a> that converts an L table to a phylo class. This function <code>phylo2L</code> does the conversion the other way around. Thus, if you want to apply your model to an empirical data. This may be useful to you.</p>","more":"<p><code>phylo2L</code> function can be found <a href=\"https://github.com/xl0418/Code/blob/99133e6e5744be7382c038edc5701cd494d8e76c/Pro2/R_p2/phylo2L.R\">here</a> if you want to improve the function. I have verified it by examining if </p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">L<span class=\"operator\">=</span>phylo2L<span class=\"punctuation\">(</span>L2phylo<span class=\"punctuation\">(</span>L<span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>Notice that <code>phylo2L</code> doesn’t have the argument <code>dropextinct</code> as what <code>L2phylo</code> has. Because to my perspective L table should be consistent with the given phylo class. But if you have a full tree on hand and want to prune it, you can do it like this</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">prune_phylo <span class=\"operator\">=</span> L2phylo<span class=\"punctuation\">(</span>phylo2L<span class=\"punctuation\">(</span>full tree<span class=\"punctuation\">)</span><span class=\"punctuation\">,</span> dropextinct <span class=\"operator\">=</span> <span class=\"literal\">TRUE</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">prune_L <span class=\"operator\">=</span> phylo2L<span class=\"punctuation\">(</span>prune_phylo<span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>Or you can use <a href=\"https://github.com/xl0418/Code/blob/f4dfd4acc15af6855572fb4659f396cea14bb83b/Pro2/R_p2/pruneL.R\"><code>pruneL</code></a> function that I have developed to prune an L table. More details on <code>pruneL</code> function can be found in this <a href=\"https://xl0418.github.io/2018/10/24/2018-10-24-pruneLfunction/\">post</a>.</p>"},{"title":"pruneL function","date":"2018-10-24T07:00:00.000Z","_content":"\nI guess this function is specially useful to [our group](https://www.rug.nl/staff/r.s.etienne/) in which we play with L table. But might be less useful than `phylo2L` function :-)\n\nFollowing last post, this function `pruneL` prunes an L table by removing the extinct lineages.\n\n<!--more-->\n\n`pruneL` function can be found [here](https://github.com/xl0418/Code/blob/f4dfd4acc15af6855572fb4659f396cea14bb83b/Pro2/R_p2/pruneL.R) if you want to improve the function. There is a huge room for improvement. This version is only the first draft of the function. And I guess I should remove the argument `dropextinct`. It doesn't make any sense. What do you think?","source":"_posts/2018-10-24-pruneLfunction.md","raw":"---\ntitle: pruneL function\ncategories: [Research,R,phylogeny function]\ntags: [phylogeny,phylo class,L table,DDD package,pruneL,phylo2L]\ndate: 2018-10-24\n\n---\n\nI guess this function is specially useful to [our group](https://www.rug.nl/staff/r.s.etienne/) in which we play with L table. But might be less useful than `phylo2L` function :-)\n\nFollowing last post, this function `pruneL` prunes an L table by removing the extinct lineages.\n\n<!--more-->\n\n`pruneL` function can be found [here](https://github.com/xl0418/Code/blob/f4dfd4acc15af6855572fb4659f396cea14bb83b/Pro2/R_p2/pruneL.R) if you want to improve the function. There is a huge room for improvement. This version is only the first draft of the function. And I guess I should remove the argument `dropextinct`. It doesn't make any sense. What do you think?","slug":"2018-10-24-pruneLfunction","published":1,"updated":"2022-09-17T02:04:05.116Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl85g865n00094gkr361ueizd","content":"<p>I guess this function is specially useful to <a href=\"https://www.rug.nl/staff/r.s.etienne/\">our group</a> in which we play with L table. But might be less useful than <code>phylo2L</code> function :-)</p>\n<p>Following last post, this function <code>pruneL</code> prunes an L table by removing the extinct lineages.</p>\n<span id=\"more\"></span>\n\n<p><code>pruneL</code> function can be found <a href=\"https://github.com/xl0418/Code/blob/f4dfd4acc15af6855572fb4659f396cea14bb83b/Pro2/R_p2/pruneL.R\">here</a> if you want to improve the function. There is a huge room for improvement. This version is only the first draft of the function. And I guess I should remove the argument <code>dropextinct</code>. It doesn’t make any sense. What do you think?</p>\n","site":{"data":{}},"excerpt":"<p>I guess this function is specially useful to <a href=\"https://www.rug.nl/staff/r.s.etienne/\">our group</a> in which we play with L table. But might be less useful than <code>phylo2L</code> function :-)</p>\n<p>Following last post, this function <code>pruneL</code> prunes an L table by removing the extinct lineages.</p>","more":"<p><code>pruneL</code> function can be found <a href=\"https://github.com/xl0418/Code/blob/f4dfd4acc15af6855572fb4659f396cea14bb83b/Pro2/R_p2/pruneL.R\">here</a> if you want to improve the function. There is a huge room for improvement. This version is only the first draft of the function. And I guess I should remove the argument <code>dropextinct</code>. It doesn’t make any sense. What do you think?</p>"},{"title":"Partial least square regression","date":"2018-10-25T07:00:00.000Z","_content":"\nI found the following interpretation to partial least square regression is much better than mine. So I cited it as below:\n>\"Partial least squares regression (PLS regression) is a statistical method that bears some relation to principal components regression; instead of finding hyperplanes of maximum variance between the response and independent variables, it finds a linear regression model by projecting the predicted variables and the observable variables to a new space. Because both the X and Y data are projected to new spaces, the PLS family of methods are known as bilinear factor models. Partial least squares Discriminant Analysis (PLS-DA) is a variant used when the Y is categorical.\"\n>\n>---from [Wikipedia](https://en.wikipedia.org/wiki/Partial_least_squares_regression)\n\n\n\n<!--more-->\n\n## PLS algorithm\nFor record purpose, I am deriving the PLS algorithm in this post. \n\nConsider a linear regression problem in a vector format as in Eq.[eq:1] given an observed data, which is denoted by a vector \\\\(\\boldsymbol{x}^{T}=(x_{1},x_{2},\\cdots,x_{n})\\\\)\n\n$$\n\\begin{align}\ny\t&=b_{1}x_{1}+\\cdots+b_{n}x_{n}+e \\\\\\\\ \n\t&=\\boldsymbol{x}^{T}\\boldsymbol{b}+e \\tag{1}\n\\end{align}\n$$\n\nWe are aiming to work out the unknown regression coefficients vector \\\\(\\boldsymbol{b}\\\\) for future prediction of \\\\(y\\\\) once we have the observed data \\\\(\\boldsymbol{x}\\\\). To keep the prediction as accurate as possible, we will want to make the residual error e as small as possible. This is simply the whole idea of the linear regression method. So one solution is to use training samples, that is given m observations \\\\(\\boldsymbol{y}^{T}=(y_{1},\\cdots,y_{m}),X=[x_{ij}],i=1,\\cdots,m,j=1,\\cdots,n \\\\)\nto solve \\\\(\\boldsymbol{b}\\\\) out in terms of keeping the residual error sufficiently small\n\n$$\n\\begin{pmatrix}\ny_{1}\\\\\\\\\ny_{2}\\\\\\\\\n\\vdots\\\\\\\\\ny_{m}\n\\end{pmatrix}=\\begin{pmatrix}\nx_{11} & x_{12} & \\cdots & x_{1n}\\\\\\\\\nx_{21} & x_{22} & \\cdots & x_{2n}\\\\\\\\\n\\vdots & \\vdots & \\ddots & \\vdots\\\\\\\\\nx_{m1} & x_{m2} & \\cdots & x_{mn}\n\\end{pmatrix}\\begin{pmatrix}\nb_{1}\\\\\\\\\nb_{2}\\\\\\\\\n\\vdots\\\\\\\\\nb_{n}\n\\end{pmatrix}+\\begin{pmatrix}\ne_{1}\\\\\\\\\ne_{2}\\\\\\\\\n\\vdots\\\\\\\\\ne_{m}\n\\end{pmatrix}\\tag{2}\n$$\n\nFor comparability among different data, all the observations are assumed to be centered and normalized in advance. Now the problem is translated to an optimization problem, that is to find a least square solution for the regression coefficients such that the sum of the square errors of the residuals is minimized. For simplicity, I would like to use the matrix form for Eq.[2]\n\n$$\nY=X\\boldsymbol{b}+\\boldsymbol{e}. \\tag{3}\n$$\n\nWe want to find out \\\\(\\boldsymbol{b}\\\\) such that\n\n$$\nmin\\\\{\\boldsymbol{e}^{T}\\boldsymbol{e}\\\\}.\n$$\n\nThe least square solution for \\\\(\\boldsymbol{b}\\\\) is given by\n\n$$\n\\boldsymbol{b}=(X^{T}X)^{-1}X^{T}Y. \\tag{4}\n$$\n\nThe derivation is simply as follows:\n\n$$\nF_{\\boldsymbol{b}}=\\frac{1}{2}(X\\boldsymbol{b}-Y)^{T}(X\\boldsymbol{b}-Y) \\tag{5}\n$$\n\nSo the derivative of F_{\\boldsymbol{b}} yields\n\n$$\n\\begin{align}\n\\nabla_{\\boldsymbol{b}}F_{\\boldsymbol{b}}\t\n&=\\frac{1}{2}\\nabla_{\\boldsymbol{b}}(X\\boldsymbol{b}-Y)^{T}(X\\boldsymbol{b}-Y)\\\\\\\\\n\t&=\\frac{1}{2}\\nabla_{\\boldsymbol{b}}(\\boldsymbol{b}^{T}X^{T}-Y^{T})(X\\boldsymbol{b}-Y)\\\\\\\\\n\t&=\\frac{1}{2}\\nabla_{\\boldsymbol{b}}(\\boldsymbol{b}^{T}X^{T}X\\boldsymbol{b}-\\boldsymbol{b}^{T}X^{T}Y-Y^{T}X\\boldsymbol{b}+Y^{T}Y)\\\\\\\\\n\t&=\\frac{1}{2}\\nabla_{\\boldsymbol{b}}tr(\\boldsymbol{b}^{T}X^{T}X\\boldsymbol{b}-\\boldsymbol{b}^{T}X^{T}Y-Y^{T}X\\boldsymbol{b}+Y^{T}Y)\\\\\\\\\n\t&=\\frac{1}{2}\\nabla_{\\boldsymbol{b}}\\left\\(tr(\\boldsymbol{b}^{T}X^{T}X\\boldsymbol{b})-2tr(Y^{T}X\\boldsymbol{b})+tr(Y^{T}Y)\\right\\)\\\\\\\\\n\t&=X^{T}X\\boldsymbol{b}-X^{T}Y. \n\\end{align}\n$$\n\nBy setting the derivative to be 0, solution Eq.[4] is obtained.\nHowever, this least square solution may have problem when the training sample is not enough, that is m<n. In that case, the matrix \\\\(X^{T}X\\\\) doesn't have full rank which means it is nonsingular. \n\nTo solve this problem, we can project each measurement \\\\(\\boldsymbol{x_{i}}=(x_{i1},\\cdots,x_{in})\\\\) into a lower-dimensional subspace spanned by data \\\\(T=XW\\\\). We can think of this as forming a smaller set of features, each being the linear combination of the original set of features. These new features are also called “latent” variables. Therefore, the linear regression can be written as a linear regression system on the new latent variables\n\n$$\n\\begin{align}\nY &=TQ^{T}+F \\tag{6} \\\\\\\\\nX &=TP^{T}+E \\tag{7}\n\\end{align}\n$$\n\nwhere \\\\(P,Q\\\\) are the coefficient matrices and E,F are matrices of errors. As in partial least squares regression (PLSR), the weight matrix \\\\(W\\\\) reflects the covariance structure between the predictor and response variables. Hence, maximizing the covariance of the latent variables and the response variables \\\\(Cov(T,Y)\\\\) gives us the weight matrix \\\\(W\\\\). Once obtaining \\\\(W\\\\) and then constructing \\\\(T\\\\), \\\\(Q^{T}\\\\) is solved by the least squares solution Eq.[6]:\n\n$$\nQ^{T}=(T^{T}T)^{-1}T^{T}Y.\n$$\n\nPlug Eq.[eq:latent] into the regression equation Eq.[6], we obtain the solution of the matrix \\\\(\\boldsymbol{b}\\\\) of the coefficient in the model Eq.[3]\n\n$$\n\\boldsymbol{b}=W(T^{T}T)^{-1}T^{T}Y.\n$$\n\nSo this is the whole idea of PLS. A commonly used algorithm to compute PLSR is the nonlinear iterative partial least square (NIPALS) method. The steps are summarized as follows:\n\n\n**NIPALS**\n\n1. Normalize \\\\(m\\\\) training samples by \n\n$$\n\\begin{align}\nx_{ij} &=\\left(x_{ij}-\\bar{x} _{\\cdot\\ j}\\right)/ \\sigma _{x_{\\cdot\\ j}} \\\\\\\\\ny_{i} &=\\left(y_{i}-\\bar{y}\\right)/ \\sigma _{y}\\ \\text{for }i=1,\\cdots,m,j=1,\\cdots,n\n\\end{align}\n$$\n\n**Compute the scores**\n\n2. Compute the dominant eigenvector of \\\\(X_{0}^{T}Y_{0}Y_{0}^{T}X_{0}\\\\) and assign it to \\\\(w_{1}\\\\) (the step of maximizing the covariance). Normalize \\\\(w_{1}\\\\). The scores \\\\(t_{1}\\\\) of \\\\(X_{0}\\\\) yields\n\n$$\nt_{1}=X_{0}w_{1}.\n$$\n\nDo the same to \\\\(Y_{0}\\\\) and obtain a normalized vector \\\\(c_{1}\\\\). The scores \\\\(v_{1}\\\\) of \\\\(Y_{0}\\\\) yields\n\n$$\nv_{1}=Y_{0}c_{1}.\n$$\n\n\n**Compute the loadings**\n\n3. Based on the regression equations\n\n$$\n\\begin{align}\nX\t&=t_{1}p_{1}^{T}+E \\\\\\\\\nY\t&=t_{1}q_{1}^{T}+F,\n\\end{align}\n$$\n\nthe least square method gives us \n\n\n$$\n\\begin{align}\np_{1} &=\\frac{X^{T}t_{1}}{t_{1}t_{1}^{T}} \\\\\\\\\nq_{1} &=\\frac{Y^{T}t_{1}}{t_{1}t_{1}^{T}}.\n\\end{align}\n$$\n\n\n4. Check if \\\\(F\\\\) is sufficiently small. Otherwise, set \\\\(E\\\\) as \\\\(X_{1}\\\\), \\\\(F\\\\) as \\\\(Y_{1}\\\\). Repeat step 2-3. \n\n5. Finally, we obtain \n\n$$\n\\begin{align}\nX &=t_{1}p_{1}^{T}+t_{2}p_{2}^{T}+\\cdots+t_{n}p_{n}^{T}+E \\\\\\\\\nY &=t_{1}q_{1}^{T}+t_{2}q_{2}^{T}+\\cdots+t_{n}q_{n}^{T}+F\n\\end{align}\n$$\n\nwhich in a matrix format is as follows:\n\n$$\n\\begin{align}\nX &=TP^{T}+E \\\\\\\\\nY &=TQ^{T}+F \\\\\\\\\n\t&=XWQ^{T}+F \\\\\\\\\n\t&:=XB+F.\n\\end{align}\n$$\n\nSo, when we have a new data \\\\(x_{new}\\\\), to define the PLS components in our ABC-MCMC algorithm, we only need to compute \n\n$$\nt_{1}=x_{new}^{T}p_{1},t_{2}=x_{new}^{T}p_{2},\\cdots,t_{n}=x_{new}^{T}p_{n}\n$$\n\n\n<script type=\"text/javascript\" src=\"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default\"></script>","source":"_posts/2018-10-25-PLSR.md","raw":"---\ntitle: Partial least square regression\ncategories: [Research,Numerical method]\ntags: [regression,least square method,partial least square,math,machine learning]\ndate: 2018-10-25\n\n---\n\nI found the following interpretation to partial least square regression is much better than mine. So I cited it as below:\n>\"Partial least squares regression (PLS regression) is a statistical method that bears some relation to principal components regression; instead of finding hyperplanes of maximum variance between the response and independent variables, it finds a linear regression model by projecting the predicted variables and the observable variables to a new space. Because both the X and Y data are projected to new spaces, the PLS family of methods are known as bilinear factor models. Partial least squares Discriminant Analysis (PLS-DA) is a variant used when the Y is categorical.\"\n>\n>---from [Wikipedia](https://en.wikipedia.org/wiki/Partial_least_squares_regression)\n\n\n\n<!--more-->\n\n## PLS algorithm\nFor record purpose, I am deriving the PLS algorithm in this post. \n\nConsider a linear regression problem in a vector format as in Eq.[eq:1] given an observed data, which is denoted by a vector \\\\(\\boldsymbol{x}^{T}=(x_{1},x_{2},\\cdots,x_{n})\\\\)\n\n$$\n\\begin{align}\ny\t&=b_{1}x_{1}+\\cdots+b_{n}x_{n}+e \\\\\\\\ \n\t&=\\boldsymbol{x}^{T}\\boldsymbol{b}+e \\tag{1}\n\\end{align}\n$$\n\nWe are aiming to work out the unknown regression coefficients vector \\\\(\\boldsymbol{b}\\\\) for future prediction of \\\\(y\\\\) once we have the observed data \\\\(\\boldsymbol{x}\\\\). To keep the prediction as accurate as possible, we will want to make the residual error e as small as possible. This is simply the whole idea of the linear regression method. So one solution is to use training samples, that is given m observations \\\\(\\boldsymbol{y}^{T}=(y_{1},\\cdots,y_{m}),X=[x_{ij}],i=1,\\cdots,m,j=1,\\cdots,n \\\\)\nto solve \\\\(\\boldsymbol{b}\\\\) out in terms of keeping the residual error sufficiently small\n\n$$\n\\begin{pmatrix}\ny_{1}\\\\\\\\\ny_{2}\\\\\\\\\n\\vdots\\\\\\\\\ny_{m}\n\\end{pmatrix}=\\begin{pmatrix}\nx_{11} & x_{12} & \\cdots & x_{1n}\\\\\\\\\nx_{21} & x_{22} & \\cdots & x_{2n}\\\\\\\\\n\\vdots & \\vdots & \\ddots & \\vdots\\\\\\\\\nx_{m1} & x_{m2} & \\cdots & x_{mn}\n\\end{pmatrix}\\begin{pmatrix}\nb_{1}\\\\\\\\\nb_{2}\\\\\\\\\n\\vdots\\\\\\\\\nb_{n}\n\\end{pmatrix}+\\begin{pmatrix}\ne_{1}\\\\\\\\\ne_{2}\\\\\\\\\n\\vdots\\\\\\\\\ne_{m}\n\\end{pmatrix}\\tag{2}\n$$\n\nFor comparability among different data, all the observations are assumed to be centered and normalized in advance. Now the problem is translated to an optimization problem, that is to find a least square solution for the regression coefficients such that the sum of the square errors of the residuals is minimized. For simplicity, I would like to use the matrix form for Eq.[2]\n\n$$\nY=X\\boldsymbol{b}+\\boldsymbol{e}. \\tag{3}\n$$\n\nWe want to find out \\\\(\\boldsymbol{b}\\\\) such that\n\n$$\nmin\\\\{\\boldsymbol{e}^{T}\\boldsymbol{e}\\\\}.\n$$\n\nThe least square solution for \\\\(\\boldsymbol{b}\\\\) is given by\n\n$$\n\\boldsymbol{b}=(X^{T}X)^{-1}X^{T}Y. \\tag{4}\n$$\n\nThe derivation is simply as follows:\n\n$$\nF_{\\boldsymbol{b}}=\\frac{1}{2}(X\\boldsymbol{b}-Y)^{T}(X\\boldsymbol{b}-Y) \\tag{5}\n$$\n\nSo the derivative of F_{\\boldsymbol{b}} yields\n\n$$\n\\begin{align}\n\\nabla_{\\boldsymbol{b}}F_{\\boldsymbol{b}}\t\n&=\\frac{1}{2}\\nabla_{\\boldsymbol{b}}(X\\boldsymbol{b}-Y)^{T}(X\\boldsymbol{b}-Y)\\\\\\\\\n\t&=\\frac{1}{2}\\nabla_{\\boldsymbol{b}}(\\boldsymbol{b}^{T}X^{T}-Y^{T})(X\\boldsymbol{b}-Y)\\\\\\\\\n\t&=\\frac{1}{2}\\nabla_{\\boldsymbol{b}}(\\boldsymbol{b}^{T}X^{T}X\\boldsymbol{b}-\\boldsymbol{b}^{T}X^{T}Y-Y^{T}X\\boldsymbol{b}+Y^{T}Y)\\\\\\\\\n\t&=\\frac{1}{2}\\nabla_{\\boldsymbol{b}}tr(\\boldsymbol{b}^{T}X^{T}X\\boldsymbol{b}-\\boldsymbol{b}^{T}X^{T}Y-Y^{T}X\\boldsymbol{b}+Y^{T}Y)\\\\\\\\\n\t&=\\frac{1}{2}\\nabla_{\\boldsymbol{b}}\\left\\(tr(\\boldsymbol{b}^{T}X^{T}X\\boldsymbol{b})-2tr(Y^{T}X\\boldsymbol{b})+tr(Y^{T}Y)\\right\\)\\\\\\\\\n\t&=X^{T}X\\boldsymbol{b}-X^{T}Y. \n\\end{align}\n$$\n\nBy setting the derivative to be 0, solution Eq.[4] is obtained.\nHowever, this least square solution may have problem when the training sample is not enough, that is m<n. In that case, the matrix \\\\(X^{T}X\\\\) doesn't have full rank which means it is nonsingular. \n\nTo solve this problem, we can project each measurement \\\\(\\boldsymbol{x_{i}}=(x_{i1},\\cdots,x_{in})\\\\) into a lower-dimensional subspace spanned by data \\\\(T=XW\\\\). We can think of this as forming a smaller set of features, each being the linear combination of the original set of features. These new features are also called “latent” variables. Therefore, the linear regression can be written as a linear regression system on the new latent variables\n\n$$\n\\begin{align}\nY &=TQ^{T}+F \\tag{6} \\\\\\\\\nX &=TP^{T}+E \\tag{7}\n\\end{align}\n$$\n\nwhere \\\\(P,Q\\\\) are the coefficient matrices and E,F are matrices of errors. As in partial least squares regression (PLSR), the weight matrix \\\\(W\\\\) reflects the covariance structure between the predictor and response variables. Hence, maximizing the covariance of the latent variables and the response variables \\\\(Cov(T,Y)\\\\) gives us the weight matrix \\\\(W\\\\). Once obtaining \\\\(W\\\\) and then constructing \\\\(T\\\\), \\\\(Q^{T}\\\\) is solved by the least squares solution Eq.[6]:\n\n$$\nQ^{T}=(T^{T}T)^{-1}T^{T}Y.\n$$\n\nPlug Eq.[eq:latent] into the regression equation Eq.[6], we obtain the solution of the matrix \\\\(\\boldsymbol{b}\\\\) of the coefficient in the model Eq.[3]\n\n$$\n\\boldsymbol{b}=W(T^{T}T)^{-1}T^{T}Y.\n$$\n\nSo this is the whole idea of PLS. A commonly used algorithm to compute PLSR is the nonlinear iterative partial least square (NIPALS) method. The steps are summarized as follows:\n\n\n**NIPALS**\n\n1. Normalize \\\\(m\\\\) training samples by \n\n$$\n\\begin{align}\nx_{ij} &=\\left(x_{ij}-\\bar{x} _{\\cdot\\ j}\\right)/ \\sigma _{x_{\\cdot\\ j}} \\\\\\\\\ny_{i} &=\\left(y_{i}-\\bar{y}\\right)/ \\sigma _{y}\\ \\text{for }i=1,\\cdots,m,j=1,\\cdots,n\n\\end{align}\n$$\n\n**Compute the scores**\n\n2. Compute the dominant eigenvector of \\\\(X_{0}^{T}Y_{0}Y_{0}^{T}X_{0}\\\\) and assign it to \\\\(w_{1}\\\\) (the step of maximizing the covariance). Normalize \\\\(w_{1}\\\\). The scores \\\\(t_{1}\\\\) of \\\\(X_{0}\\\\) yields\n\n$$\nt_{1}=X_{0}w_{1}.\n$$\n\nDo the same to \\\\(Y_{0}\\\\) and obtain a normalized vector \\\\(c_{1}\\\\). The scores \\\\(v_{1}\\\\) of \\\\(Y_{0}\\\\) yields\n\n$$\nv_{1}=Y_{0}c_{1}.\n$$\n\n\n**Compute the loadings**\n\n3. Based on the regression equations\n\n$$\n\\begin{align}\nX\t&=t_{1}p_{1}^{T}+E \\\\\\\\\nY\t&=t_{1}q_{1}^{T}+F,\n\\end{align}\n$$\n\nthe least square method gives us \n\n\n$$\n\\begin{align}\np_{1} &=\\frac{X^{T}t_{1}}{t_{1}t_{1}^{T}} \\\\\\\\\nq_{1} &=\\frac{Y^{T}t_{1}}{t_{1}t_{1}^{T}}.\n\\end{align}\n$$\n\n\n4. Check if \\\\(F\\\\) is sufficiently small. Otherwise, set \\\\(E\\\\) as \\\\(X_{1}\\\\), \\\\(F\\\\) as \\\\(Y_{1}\\\\). Repeat step 2-3. \n\n5. Finally, we obtain \n\n$$\n\\begin{align}\nX &=t_{1}p_{1}^{T}+t_{2}p_{2}^{T}+\\cdots+t_{n}p_{n}^{T}+E \\\\\\\\\nY &=t_{1}q_{1}^{T}+t_{2}q_{2}^{T}+\\cdots+t_{n}q_{n}^{T}+F\n\\end{align}\n$$\n\nwhich in a matrix format is as follows:\n\n$$\n\\begin{align}\nX &=TP^{T}+E \\\\\\\\\nY &=TQ^{T}+F \\\\\\\\\n\t&=XWQ^{T}+F \\\\\\\\\n\t&:=XB+F.\n\\end{align}\n$$\n\nSo, when we have a new data \\\\(x_{new}\\\\), to define the PLS components in our ABC-MCMC algorithm, we only need to compute \n\n$$\nt_{1}=x_{new}^{T}p_{1},t_{2}=x_{new}^{T}p_{2},\\cdots,t_{n}=x_{new}^{T}p_{n}\n$$\n\n\n<script type=\"text/javascript\" src=\"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default\"></script>","slug":"2018-10-25-PLSR","published":1,"updated":"2022-09-17T02:04:05.116Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl85g865p000d4gkr550h6ycp","content":"<p>I found the following interpretation to partial least square regression is much better than mine. So I cited it as below:</p>\n<blockquote>\n<p>“Partial least squares regression (PLS regression) is a statistical method that bears some relation to principal components regression; instead of finding hyperplanes of maximum variance between the response and independent variables, it finds a linear regression model by projecting the predicted variables and the observable variables to a new space. Because both the X and Y data are projected to new spaces, the PLS family of methods are known as bilinear factor models. Partial least squares Discriminant Analysis (PLS-DA) is a variant used when the Y is categorical.”</p>\n<p>—from <a href=\"https://en.wikipedia.org/wiki/Partial_least_squares_regression\">Wikipedia</a></p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"PLS-algorithm\"><a href=\"#PLS-algorithm\" class=\"headerlink\" title=\"PLS algorithm\"></a>PLS algorithm</h2><p>For record purpose, I am deriving the PLS algorithm in this post. </p>\n<p>Consider a linear regression problem in a vector format as in Eq.[eq:1] given an observed data, which is denoted by a vector \\(\\boldsymbol{x}^{T}&#x3D;(x_{1},x_{2},\\cdots,x_{n})\\)</p>\n<p>$$<br>\\begin{align}<br>y\t&amp;&#x3D;b_{1}x_{1}+\\cdots+b_{n}x_{n}+e \\\\<br>    &amp;&#x3D;\\boldsymbol{x}^{T}\\boldsymbol{b}+e \\tag{1}<br>\\end{align}<br>$$</p>\n<p>We are aiming to work out the unknown regression coefficients vector \\(\\boldsymbol{b}\\) for future prediction of \\(y\\) once we have the observed data \\(\\boldsymbol{x}\\). To keep the prediction as accurate as possible, we will want to make the residual error e as small as possible. This is simply the whole idea of the linear regression method. So one solution is to use training samples, that is given m observations \\(\\boldsymbol{y}^{T}&#x3D;(y_{1},\\cdots,y_{m}),X&#x3D;[x_{ij}],i&#x3D;1,\\cdots,m,j&#x3D;1,\\cdots,n \\)<br>to solve \\(\\boldsymbol{b}\\) out in terms of keeping the residual error sufficiently small</p>\n<p>$$<br>\\begin{pmatrix}<br>y_{1}\\\\<br>y_{2}\\\\<br>\\vdots\\\\<br>y_{m}<br>\\end{pmatrix}&#x3D;\\begin{pmatrix}<br>x_{11} &amp; x_{12} &amp; \\cdots &amp; x_{1n}\\\\<br>x_{21} &amp; x_{22} &amp; \\cdots &amp; x_{2n}\\\\<br>\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots\\\\<br>x_{m1} &amp; x_{m2} &amp; \\cdots &amp; x_{mn}<br>\\end{pmatrix}\\begin{pmatrix}<br>b_{1}\\\\<br>b_{2}\\\\<br>\\vdots\\\\<br>b_{n}<br>\\end{pmatrix}+\\begin{pmatrix}<br>e_{1}\\\\<br>e_{2}\\\\<br>\\vdots\\\\<br>e_{m}<br>\\end{pmatrix}\\tag{2}<br>$$</p>\n<p>For comparability among different data, all the observations are assumed to be centered and normalized in advance. Now the problem is translated to an optimization problem, that is to find a least square solution for the regression coefficients such that the sum of the square errors of the residuals is minimized. For simplicity, I would like to use the matrix form for Eq.[2]</p>\n<p>$$<br>Y&#x3D;X\\boldsymbol{b}+\\boldsymbol{e}. \\tag{3}<br>$$</p>\n<p>We want to find out \\(\\boldsymbol{b}\\) such that</p>\n<p>$$<br>min\\{\\boldsymbol{e}^{T}\\boldsymbol{e}\\}.<br>$$</p>\n<p>The least square solution for \\(\\boldsymbol{b}\\) is given by</p>\n<p>$$<br>\\boldsymbol{b}&#x3D;(X^{T}X)^{-1}X^{T}Y. \\tag{4}<br>$$</p>\n<p>The derivation is simply as follows:</p>\n<p>$$<br>F_{\\boldsymbol{b}}&#x3D;\\frac{1}{2}(X\\boldsymbol{b}-Y)^{T}(X\\boldsymbol{b}-Y) \\tag{5}<br>$$</p>\n<p>So the derivative of F_{\\boldsymbol{b}} yields</p>\n<p>$$<br>\\begin{align}<br>\\nabla_{\\boldsymbol{b}}F_{\\boldsymbol{b}}\t<br>&amp;&#x3D;\\frac{1}{2}\\nabla_{\\boldsymbol{b}}(X\\boldsymbol{b}-Y)^{T}(X\\boldsymbol{b}-Y)\\\\<br>    &amp;&#x3D;\\frac{1}{2}\\nabla_{\\boldsymbol{b}}(\\boldsymbol{b}^{T}X^{T}-Y^{T})(X\\boldsymbol{b}-Y)\\\\<br>    &amp;&#x3D;\\frac{1}{2}\\nabla_{\\boldsymbol{b}}(\\boldsymbol{b}^{T}X^{T}X\\boldsymbol{b}-\\boldsymbol{b}^{T}X^{T}Y-Y^{T}X\\boldsymbol{b}+Y^{T}Y)\\\\<br>    &amp;&#x3D;\\frac{1}{2}\\nabla_{\\boldsymbol{b}}tr(\\boldsymbol{b}^{T}X^{T}X\\boldsymbol{b}-\\boldsymbol{b}^{T}X^{T}Y-Y^{T}X\\boldsymbol{b}+Y^{T}Y)\\\\<br>    &amp;&#x3D;\\frac{1}{2}\\nabla_{\\boldsymbol{b}}\\left(tr(\\boldsymbol{b}^{T}X^{T}X\\boldsymbol{b})-2tr(Y^{T}X\\boldsymbol{b})+tr(Y^{T}Y)\\right)\\\\<br>    &amp;&#x3D;X^{T}X\\boldsymbol{b}-X^{T}Y.<br>\\end{align}<br>$$</p>\n<p>By setting the derivative to be 0, solution Eq.[4] is obtained.<br>However, this least square solution may have problem when the training sample is not enough, that is m&lt;n. In that case, the matrix \\(X^{T}X\\) doesn’t have full rank which means it is nonsingular. </p>\n<p>To solve this problem, we can project each measurement \\(\\boldsymbol{x_{i}}&#x3D;(x_{i1},\\cdots,x_{in})\\) into a lower-dimensional subspace spanned by data \\(T&#x3D;XW\\). We can think of this as forming a smaller set of features, each being the linear combination of the original set of features. These new features are also called “latent” variables. Therefore, the linear regression can be written as a linear regression system on the new latent variables</p>\n<p>$$<br>\\begin{align}<br>Y &amp;&#x3D;TQ^{T}+F \\tag{6} \\\\<br>X &amp;&#x3D;TP^{T}+E \\tag{7}<br>\\end{align}<br>$$</p>\n<p>where \\(P,Q\\) are the coefficient matrices and E,F are matrices of errors. As in partial least squares regression (PLSR), the weight matrix \\(W\\) reflects the covariance structure between the predictor and response variables. Hence, maximizing the covariance of the latent variables and the response variables \\(Cov(T,Y)\\) gives us the weight matrix \\(W\\). Once obtaining \\(W\\) and then constructing \\(T\\), \\(Q^{T}\\) is solved by the least squares solution Eq.[6]:</p>\n<p>$$<br>Q^{T}&#x3D;(T^{T}T)^{-1}T^{T}Y.<br>$$</p>\n<p>Plug Eq.[eq:latent] into the regression equation Eq.[6], we obtain the solution of the matrix \\(\\boldsymbol{b}\\) of the coefficient in the model Eq.[3]</p>\n<p>$$<br>\\boldsymbol{b}&#x3D;W(T^{T}T)^{-1}T^{T}Y.<br>$$</p>\n<p>So this is the whole idea of PLS. A commonly used algorithm to compute PLSR is the nonlinear iterative partial least square (NIPALS) method. The steps are summarized as follows:</p>\n<p><strong>NIPALS</strong></p>\n<ol>\n<li>Normalize \\(m\\) training samples by</li>\n</ol>\n<p>$$<br>\\begin{align}<br>x_{ij} &amp;&#x3D;\\left(x_{ij}-\\bar{x} <em>{\\cdot\\ j}\\right)&#x2F; \\sigma <em>{x</em>{\\cdot\\ j}} \\\\<br>y</em>{i} &amp;&#x3D;\\left(y_{i}-\\bar{y}\\right)&#x2F; \\sigma _{y}\\ \\text{for }i&#x3D;1,\\cdots,m,j&#x3D;1,\\cdots,n<br>\\end{align}<br>$$</p>\n<p><strong>Compute the scores</strong></p>\n<ol start=\"2\">\n<li>Compute the dominant eigenvector of \\(X_{0}^{T}Y_{0}Y_{0}^{T}X_{0}\\) and assign it to \\(w_{1}\\) (the step of maximizing the covariance). Normalize \\(w_{1}\\). The scores \\(t_{1}\\) of \\(X_{0}\\) yields</li>\n</ol>\n<p>$$<br>t_{1}&#x3D;X_{0}w_{1}.<br>$$</p>\n<p>Do the same to \\(Y_{0}\\) and obtain a normalized vector \\(c_{1}\\). The scores \\(v_{1}\\) of \\(Y_{0}\\) yields</p>\n<p>$$<br>v_{1}&#x3D;Y_{0}c_{1}.<br>$$</p>\n<p><strong>Compute the loadings</strong></p>\n<ol start=\"3\">\n<li>Based on the regression equations</li>\n</ol>\n<p>$$<br>\\begin{align}<br>X\t&amp;&#x3D;t_{1}p_{1}^{T}+E \\\\<br>Y\t&amp;&#x3D;t_{1}q_{1}^{T}+F,<br>\\end{align}<br>$$</p>\n<p>the least square method gives us </p>\n<p>$$<br>\\begin{align}<br>p_{1} &amp;&#x3D;\\frac{X^{T}t_{1}}{t_{1}t_{1}^{T}} \\\\<br>q_{1} &amp;&#x3D;\\frac{Y^{T}t_{1}}{t_{1}t_{1}^{T}}.<br>\\end{align}<br>$$</p>\n<ol start=\"4\">\n<li><p>Check if \\(F\\) is sufficiently small. Otherwise, set \\(E\\) as \\(X_{1}\\), \\(F\\) as \\(Y_{1}\\). Repeat step 2-3. </p>\n</li>\n<li><p>Finally, we obtain</p>\n</li>\n</ol>\n<p>$$<br>\\begin{align}<br>X &amp;&#x3D;t_{1}p_{1}^{T}+t_{2}p_{2}^{T}+\\cdots+t_{n}p_{n}^{T}+E \\\\<br>Y &amp;&#x3D;t_{1}q_{1}^{T}+t_{2}q_{2}^{T}+\\cdots+t_{n}q_{n}^{T}+F<br>\\end{align}<br>$$</p>\n<p>which in a matrix format is as follows:</p>\n<p>$$<br>\\begin{align}<br>X &amp;&#x3D;TP^{T}+E \\\\<br>Y &amp;&#x3D;TQ^{T}+F \\\\<br>    &amp;&#x3D;XWQ^{T}+F \\\\<br>    &amp;:&#x3D;XB+F.<br>\\end{align}<br>$$</p>\n<p>So, when we have a new data \\(x_{new}\\), to define the PLS components in our ABC-MCMC algorithm, we only need to compute </p>\n<p>$$<br>t_{1}&#x3D;x_{new}^{T}p_{1},t_{2}&#x3D;x_{new}^{T}p_{2},\\cdots,t_{n}&#x3D;x_{new}^{T}p_{n}<br>$$</p>\n<script type=\"text/javascript\" src=\"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default\"></script>","site":{"data":{}},"excerpt":"<p>I found the following interpretation to partial least square regression is much better than mine. So I cited it as below:</p>\n<blockquote>\n<p>“Partial least squares regression (PLS regression) is a statistical method that bears some relation to principal components regression; instead of finding hyperplanes of maximum variance between the response and independent variables, it finds a linear regression model by projecting the predicted variables and the observable variables to a new space. Because both the X and Y data are projected to new spaces, the PLS family of methods are known as bilinear factor models. Partial least squares Discriminant Analysis (PLS-DA) is a variant used when the Y is categorical.”</p>\n<p>—from <a href=\"https://en.wikipedia.org/wiki/Partial_least_squares_regression\">Wikipedia</a></p>\n</blockquote>","more":"<h2 id=\"PLS-algorithm\"><a href=\"#PLS-algorithm\" class=\"headerlink\" title=\"PLS algorithm\"></a>PLS algorithm</h2><p>For record purpose, I am deriving the PLS algorithm in this post. </p>\n<p>Consider a linear regression problem in a vector format as in Eq.[eq:1] given an observed data, which is denoted by a vector \\(\\boldsymbol{x}^{T}&#x3D;(x_{1},x_{2},\\cdots,x_{n})\\)</p>\n<p>$$<br>\\begin{align}<br>y\t&amp;&#x3D;b_{1}x_{1}+\\cdots+b_{n}x_{n}+e \\\\<br>    &amp;&#x3D;\\boldsymbol{x}^{T}\\boldsymbol{b}+e \\tag{1}<br>\\end{align}<br>$$</p>\n<p>We are aiming to work out the unknown regression coefficients vector \\(\\boldsymbol{b}\\) for future prediction of \\(y\\) once we have the observed data \\(\\boldsymbol{x}\\). To keep the prediction as accurate as possible, we will want to make the residual error e as small as possible. This is simply the whole idea of the linear regression method. So one solution is to use training samples, that is given m observations \\(\\boldsymbol{y}^{T}&#x3D;(y_{1},\\cdots,y_{m}),X&#x3D;[x_{ij}],i&#x3D;1,\\cdots,m,j&#x3D;1,\\cdots,n \\)<br>to solve \\(\\boldsymbol{b}\\) out in terms of keeping the residual error sufficiently small</p>\n<p>$$<br>\\begin{pmatrix}<br>y_{1}\\\\<br>y_{2}\\\\<br>\\vdots\\\\<br>y_{m}<br>\\end{pmatrix}&#x3D;\\begin{pmatrix}<br>x_{11} &amp; x_{12} &amp; \\cdots &amp; x_{1n}\\\\<br>x_{21} &amp; x_{22} &amp; \\cdots &amp; x_{2n}\\\\<br>\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots\\\\<br>x_{m1} &amp; x_{m2} &amp; \\cdots &amp; x_{mn}<br>\\end{pmatrix}\\begin{pmatrix}<br>b_{1}\\\\<br>b_{2}\\\\<br>\\vdots\\\\<br>b_{n}<br>\\end{pmatrix}+\\begin{pmatrix}<br>e_{1}\\\\<br>e_{2}\\\\<br>\\vdots\\\\<br>e_{m}<br>\\end{pmatrix}\\tag{2}<br>$$</p>\n<p>For comparability among different data, all the observations are assumed to be centered and normalized in advance. Now the problem is translated to an optimization problem, that is to find a least square solution for the regression coefficients such that the sum of the square errors of the residuals is minimized. For simplicity, I would like to use the matrix form for Eq.[2]</p>\n<p>$$<br>Y&#x3D;X\\boldsymbol{b}+\\boldsymbol{e}. \\tag{3}<br>$$</p>\n<p>We want to find out \\(\\boldsymbol{b}\\) such that</p>\n<p>$$<br>min\\{\\boldsymbol{e}^{T}\\boldsymbol{e}\\}.<br>$$</p>\n<p>The least square solution for \\(\\boldsymbol{b}\\) is given by</p>\n<p>$$<br>\\boldsymbol{b}&#x3D;(X^{T}X)^{-1}X^{T}Y. \\tag{4}<br>$$</p>\n<p>The derivation is simply as follows:</p>\n<p>$$<br>F_{\\boldsymbol{b}}&#x3D;\\frac{1}{2}(X\\boldsymbol{b}-Y)^{T}(X\\boldsymbol{b}-Y) \\tag{5}<br>$$</p>\n<p>So the derivative of F_{\\boldsymbol{b}} yields</p>\n<p>$$<br>\\begin{align}<br>\\nabla_{\\boldsymbol{b}}F_{\\boldsymbol{b}}\t<br>&amp;&#x3D;\\frac{1}{2}\\nabla_{\\boldsymbol{b}}(X\\boldsymbol{b}-Y)^{T}(X\\boldsymbol{b}-Y)\\\\<br>    &amp;&#x3D;\\frac{1}{2}\\nabla_{\\boldsymbol{b}}(\\boldsymbol{b}^{T}X^{T}-Y^{T})(X\\boldsymbol{b}-Y)\\\\<br>    &amp;&#x3D;\\frac{1}{2}\\nabla_{\\boldsymbol{b}}(\\boldsymbol{b}^{T}X^{T}X\\boldsymbol{b}-\\boldsymbol{b}^{T}X^{T}Y-Y^{T}X\\boldsymbol{b}+Y^{T}Y)\\\\<br>    &amp;&#x3D;\\frac{1}{2}\\nabla_{\\boldsymbol{b}}tr(\\boldsymbol{b}^{T}X^{T}X\\boldsymbol{b}-\\boldsymbol{b}^{T}X^{T}Y-Y^{T}X\\boldsymbol{b}+Y^{T}Y)\\\\<br>    &amp;&#x3D;\\frac{1}{2}\\nabla_{\\boldsymbol{b}}\\left(tr(\\boldsymbol{b}^{T}X^{T}X\\boldsymbol{b})-2tr(Y^{T}X\\boldsymbol{b})+tr(Y^{T}Y)\\right)\\\\<br>    &amp;&#x3D;X^{T}X\\boldsymbol{b}-X^{T}Y.<br>\\end{align}<br>$$</p>\n<p>By setting the derivative to be 0, solution Eq.[4] is obtained.<br>However, this least square solution may have problem when the training sample is not enough, that is m&lt;n. In that case, the matrix \\(X^{T}X\\) doesn’t have full rank which means it is nonsingular. </p>\n<p>To solve this problem, we can project each measurement \\(\\boldsymbol{x_{i}}&#x3D;(x_{i1},\\cdots,x_{in})\\) into a lower-dimensional subspace spanned by data \\(T&#x3D;XW\\). We can think of this as forming a smaller set of features, each being the linear combination of the original set of features. These new features are also called “latent” variables. Therefore, the linear regression can be written as a linear regression system on the new latent variables</p>\n<p>$$<br>\\begin{align}<br>Y &amp;&#x3D;TQ^{T}+F \\tag{6} \\\\<br>X &amp;&#x3D;TP^{T}+E \\tag{7}<br>\\end{align}<br>$$</p>\n<p>where \\(P,Q\\) are the coefficient matrices and E,F are matrices of errors. As in partial least squares regression (PLSR), the weight matrix \\(W\\) reflects the covariance structure between the predictor and response variables. Hence, maximizing the covariance of the latent variables and the response variables \\(Cov(T,Y)\\) gives us the weight matrix \\(W\\). Once obtaining \\(W\\) and then constructing \\(T\\), \\(Q^{T}\\) is solved by the least squares solution Eq.[6]:</p>\n<p>$$<br>Q^{T}&#x3D;(T^{T}T)^{-1}T^{T}Y.<br>$$</p>\n<p>Plug Eq.[eq:latent] into the regression equation Eq.[6], we obtain the solution of the matrix \\(\\boldsymbol{b}\\) of the coefficient in the model Eq.[3]</p>\n<p>$$<br>\\boldsymbol{b}&#x3D;W(T^{T}T)^{-1}T^{T}Y.<br>$$</p>\n<p>So this is the whole idea of PLS. A commonly used algorithm to compute PLSR is the nonlinear iterative partial least square (NIPALS) method. The steps are summarized as follows:</p>\n<p><strong>NIPALS</strong></p>\n<ol>\n<li>Normalize \\(m\\) training samples by</li>\n</ol>\n<p>$$<br>\\begin{align}<br>x_{ij} &amp;&#x3D;\\left(x_{ij}-\\bar{x} <em>{\\cdot\\ j}\\right)&#x2F; \\sigma <em>{x</em>{\\cdot\\ j}} \\\\<br>y</em>{i} &amp;&#x3D;\\left(y_{i}-\\bar{y}\\right)&#x2F; \\sigma _{y}\\ \\text{for }i&#x3D;1,\\cdots,m,j&#x3D;1,\\cdots,n<br>\\end{align}<br>$$</p>\n<p><strong>Compute the scores</strong></p>\n<ol start=\"2\">\n<li>Compute the dominant eigenvector of \\(X_{0}^{T}Y_{0}Y_{0}^{T}X_{0}\\) and assign it to \\(w_{1}\\) (the step of maximizing the covariance). Normalize \\(w_{1}\\). The scores \\(t_{1}\\) of \\(X_{0}\\) yields</li>\n</ol>\n<p>$$<br>t_{1}&#x3D;X_{0}w_{1}.<br>$$</p>\n<p>Do the same to \\(Y_{0}\\) and obtain a normalized vector \\(c_{1}\\). The scores \\(v_{1}\\) of \\(Y_{0}\\) yields</p>\n<p>$$<br>v_{1}&#x3D;Y_{0}c_{1}.<br>$$</p>\n<p><strong>Compute the loadings</strong></p>\n<ol start=\"3\">\n<li>Based on the regression equations</li>\n</ol>\n<p>$$<br>\\begin{align}<br>X\t&amp;&#x3D;t_{1}p_{1}^{T}+E \\\\<br>Y\t&amp;&#x3D;t_{1}q_{1}^{T}+F,<br>\\end{align}<br>$$</p>\n<p>the least square method gives us </p>\n<p>$$<br>\\begin{align}<br>p_{1} &amp;&#x3D;\\frac{X^{T}t_{1}}{t_{1}t_{1}^{T}} \\\\<br>q_{1} &amp;&#x3D;\\frac{Y^{T}t_{1}}{t_{1}t_{1}^{T}}.<br>\\end{align}<br>$$</p>\n<ol start=\"4\">\n<li><p>Check if \\(F\\) is sufficiently small. Otherwise, set \\(E\\) as \\(X_{1}\\), \\(F\\) as \\(Y_{1}\\). Repeat step 2-3. </p>\n</li>\n<li><p>Finally, we obtain</p>\n</li>\n</ol>\n<p>$$<br>\\begin{align}<br>X &amp;&#x3D;t_{1}p_{1}^{T}+t_{2}p_{2}^{T}+\\cdots+t_{n}p_{n}^{T}+E \\\\<br>Y &amp;&#x3D;t_{1}q_{1}^{T}+t_{2}q_{2}^{T}+\\cdots+t_{n}q_{n}^{T}+F<br>\\end{align}<br>$$</p>\n<p>which in a matrix format is as follows:</p>\n<p>$$<br>\\begin{align}<br>X &amp;&#x3D;TP^{T}+E \\\\<br>Y &amp;&#x3D;TQ^{T}+F \\\\<br>    &amp;&#x3D;XWQ^{T}+F \\\\<br>    &amp;:&#x3D;XB+F.<br>\\end{align}<br>$$</p>\n<p>So, when we have a new data \\(x_{new}\\), to define the PLS components in our ABC-MCMC algorithm, we only need to compute </p>\n<p>$$<br>t_{1}&#x3D;x_{new}^{T}p_{1},t_{2}&#x3D;x_{new}^{T}p_{2},\\cdots,t_{n}&#x3D;x_{new}^{T}p_{n}<br>$$</p>\n<script type=\"text/javascript\" src=\"http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default\"></script>"},{"title":"Sed:a fast way to extract information from data","date":"2018-10-29T07:00:00.000Z","_content":"\nIn the third project, a bunch of mega data are generated for analysis. However, the simulated data is too big to load in memory. Thus, I need to extract some information without opening the file. After quite a few time searching for a solution, `sed` command in bash language helps me out. More details about the third project is coming soon.\n\n<!--more-->\n\n## The data file\nThe data file contains a few snapshot on different time points. Some matrix are written in the file when a snapshot time is hit. These matrix may be very large according to the parameter settings you chose. What I want to extract is the matrix \\\\(\\boldsymbol{D}\\\\) and \\\\(\\boldsymbol{R}\\\\) at the end. \n\n![Raw data files.](2018-10-29-sed/rawdata.png)\n\n## Extracting the matrix\nFirstly, I extract all the \\\\(\\boldsymbol{D}\\\\)s, for example, from the data file. The following code does the thing for me.\n\n```bash\n#!/bin/bash\nfor j in {0..4};\ndo\nfor i in {0..4};\ndo \nsed -n '/D'{'length(D)+1'}' = \\[\\r/,/\\];/p' test\"$j$i\".m > Ds\"$j$i\".Rdata\necho $j$i' done'\ndone\ndone\n```\n\nAs you see, there are in total 25 data files I need to deal with. For each data file, `sed` finds the line starting with \"\\\\(D\\left\\\\{length(D)+1\\right\\\\} = [\\\\)\" till \"\\\\(];\\\\)\" from the file testji.m and writes/prints (\\\\(p\\\\)) all the matched lines to the file Dsji.Rdata. \n\n![All D matrix are extracted.](2018-10-29-sed/ds.png)\n\n## Replacing the last D matrix\nThen, I want to extract the last  \\\\(\\boldsymbol{D}\\\\) matrix. How can I do that? Use the following code:\n\n```bash\n#!/bin/bash\nfor j in {0..4};\ndo\nfor i in {0..4};\ndo \nA=$(grep -c 'D'{'length(D)+1'}' = \\[' Ds\"$j$i\".Rdata)\nB=$[$A-1]\nsed '/D'{'length(D)+1'}'/{G;s/\\nX\\{'$B'\\}//;tend;x;s/^/X/;x;P;d};p;d;:end;s/D'{'length(D)+1'}'/D/;:a;n;ba' Ds\"$j$i\".Rdata>Dt\"$j$i\".Rdata\nsed -n '/D = \\[\\r/,/\\];/p' Dt\"$j$i\".Rdata > D\"$j$i\".Rdata\n\nC=$(cat D\"$j$i\".Rdata |wc -l)\nC=$[$C-2]\nD=$[$C+1]\n\nsed -i -e 's/D = \\[/D = structure(c(/' -e 's/\\];/),.Dim=c('$(echo $C)','$(echo $C)'))/' -e 's/;/ /g' -e '2,${s/ /,/g}' -e '2,${s/,,/ /g}' -e '3,'$(echo $D)'{s/^/,/g}' D\"$j$i\".Rdata\necho $j$i' done'\ndone\ndone\n```\n\nThe command `grep` returns the number of the replicates of the line \"\\\\(D\\left\\\\{length(D)+1\\right\\\\} = [\\\\)\". Then `sed` replaces the head of the last matrix with \\\\(D\\\\) and extracts this matrix out and writes into file Dij.Rdata. As I want to work in R with these results, I reformat the structure of the results to fit the matrix format in R which is something like:\n\n```R\nD = structure(c(1,0,0,1),.Dim=c(2,2))\n```\n\nAt last, I can directly `source` the file in R and read the matrix. \n\n![The last D matrix is captured.](2018-10-29-sed/d.png)\n\n## Details in sed\nThe first `sed` in the second script is the key part in this function. \n\n```bash\nsed '/D'{'length(D)+1'}'/{G;s/\\nX\\{'$B'\\}//;tend;x;s/^/X/;x;P;d};p;d;:end;s/D'{'length(D)+1'}'/D/;:a;n;ba' Ds\"$j$i\".Rdata>Dt\"$j$i\".Rdata\n```\n\nI don't fully understand what every letter in this command means. In this [answer](https://superuser.com/questions/394282/sed-perform-only-first-nth-matched-replacement), the author explained the idea is to store a \\\\(X\\\\) at each match in the holdspace, and when all the \\\\(X\\\\)s are there, loop till the end of file. If you know more, please comment after the post. Thanks!\n\nThe third `sed` reformats the matrix to fit in R. `-e` executes several commands in one line. \n\n```bash\nsed -i -e 's/D = \\[/D = structure(c(/' -e 's/\\];/),.Dim=c('$(echo $C)','$(echo $C)'))/' -e 's/;/ /g' -e '2,${s/ /,/g}' -e '2,${s/,,/ /g}' -e '3,'$(echo $D)'{s/^/,/g}' D\"$j$i\".Rdata\n```\n\nThe first segment replaces \"\\\\(D = [ \\\\)\" with \"\\\\(D = structure(c( \\\\)\" while the second replaces the tail \"];\" with \"(,.Dim=c(row,col)\". Then all the signs \";\" are substituted by space and the single space is substituted by \",\" from the second line to the end. Following the replacement of \",,\" by space from the second line and add \",\" at the beginning of the line from the third line on. Finally, a standard matrix form is rebuilt.  \n\nBTW, a good tutorial can be found [here](http://www.grymoire.com/Unix/Sed.html). Have fun! ","source":"_posts/2018-10-29-sed.md","raw":"---\ntitle: \"Sed:a fast way to extract information from data\" \ncategories: [Research, Bash, sed]\ntags: [project 3, bash, mega data, extract information]\ndate: 2018-10-29\n\n---\n\nIn the third project, a bunch of mega data are generated for analysis. However, the simulated data is too big to load in memory. Thus, I need to extract some information without opening the file. After quite a few time searching for a solution, `sed` command in bash language helps me out. More details about the third project is coming soon.\n\n<!--more-->\n\n## The data file\nThe data file contains a few snapshot on different time points. Some matrix are written in the file when a snapshot time is hit. These matrix may be very large according to the parameter settings you chose. What I want to extract is the matrix \\\\(\\boldsymbol{D}\\\\) and \\\\(\\boldsymbol{R}\\\\) at the end. \n\n![Raw data files.](2018-10-29-sed/rawdata.png)\n\n## Extracting the matrix\nFirstly, I extract all the \\\\(\\boldsymbol{D}\\\\)s, for example, from the data file. The following code does the thing for me.\n\n```bash\n#!/bin/bash\nfor j in {0..4};\ndo\nfor i in {0..4};\ndo \nsed -n '/D'{'length(D)+1'}' = \\[\\r/,/\\];/p' test\"$j$i\".m > Ds\"$j$i\".Rdata\necho $j$i' done'\ndone\ndone\n```\n\nAs you see, there are in total 25 data files I need to deal with. For each data file, `sed` finds the line starting with \"\\\\(D\\left\\\\{length(D)+1\\right\\\\} = [\\\\)\" till \"\\\\(];\\\\)\" from the file testji.m and writes/prints (\\\\(p\\\\)) all the matched lines to the file Dsji.Rdata. \n\n![All D matrix are extracted.](2018-10-29-sed/ds.png)\n\n## Replacing the last D matrix\nThen, I want to extract the last  \\\\(\\boldsymbol{D}\\\\) matrix. How can I do that? Use the following code:\n\n```bash\n#!/bin/bash\nfor j in {0..4};\ndo\nfor i in {0..4};\ndo \nA=$(grep -c 'D'{'length(D)+1'}' = \\[' Ds\"$j$i\".Rdata)\nB=$[$A-1]\nsed '/D'{'length(D)+1'}'/{G;s/\\nX\\{'$B'\\}//;tend;x;s/^/X/;x;P;d};p;d;:end;s/D'{'length(D)+1'}'/D/;:a;n;ba' Ds\"$j$i\".Rdata>Dt\"$j$i\".Rdata\nsed -n '/D = \\[\\r/,/\\];/p' Dt\"$j$i\".Rdata > D\"$j$i\".Rdata\n\nC=$(cat D\"$j$i\".Rdata |wc -l)\nC=$[$C-2]\nD=$[$C+1]\n\nsed -i -e 's/D = \\[/D = structure(c(/' -e 's/\\];/),.Dim=c('$(echo $C)','$(echo $C)'))/' -e 's/;/ /g' -e '2,${s/ /,/g}' -e '2,${s/,,/ /g}' -e '3,'$(echo $D)'{s/^/,/g}' D\"$j$i\".Rdata\necho $j$i' done'\ndone\ndone\n```\n\nThe command `grep` returns the number of the replicates of the line \"\\\\(D\\left\\\\{length(D)+1\\right\\\\} = [\\\\)\". Then `sed` replaces the head of the last matrix with \\\\(D\\\\) and extracts this matrix out and writes into file Dij.Rdata. As I want to work in R with these results, I reformat the structure of the results to fit the matrix format in R which is something like:\n\n```R\nD = structure(c(1,0,0,1),.Dim=c(2,2))\n```\n\nAt last, I can directly `source` the file in R and read the matrix. \n\n![The last D matrix is captured.](2018-10-29-sed/d.png)\n\n## Details in sed\nThe first `sed` in the second script is the key part in this function. \n\n```bash\nsed '/D'{'length(D)+1'}'/{G;s/\\nX\\{'$B'\\}//;tend;x;s/^/X/;x;P;d};p;d;:end;s/D'{'length(D)+1'}'/D/;:a;n;ba' Ds\"$j$i\".Rdata>Dt\"$j$i\".Rdata\n```\n\nI don't fully understand what every letter in this command means. In this [answer](https://superuser.com/questions/394282/sed-perform-only-first-nth-matched-replacement), the author explained the idea is to store a \\\\(X\\\\) at each match in the holdspace, and when all the \\\\(X\\\\)s are there, loop till the end of file. If you know more, please comment after the post. Thanks!\n\nThe third `sed` reformats the matrix to fit in R. `-e` executes several commands in one line. \n\n```bash\nsed -i -e 's/D = \\[/D = structure(c(/' -e 's/\\];/),.Dim=c('$(echo $C)','$(echo $C)'))/' -e 's/;/ /g' -e '2,${s/ /,/g}' -e '2,${s/,,/ /g}' -e '3,'$(echo $D)'{s/^/,/g}' D\"$j$i\".Rdata\n```\n\nThe first segment replaces \"\\\\(D = [ \\\\)\" with \"\\\\(D = structure(c( \\\\)\" while the second replaces the tail \"];\" with \"(,.Dim=c(row,col)\". Then all the signs \";\" are substituted by space and the single space is substituted by \",\" from the second line to the end. Following the replacement of \",,\" by space from the second line and add \",\" at the beginning of the line from the third line on. Finally, a standard matrix form is rebuilt.  \n\nBTW, a good tutorial can be found [here](http://www.grymoire.com/Unix/Sed.html). Have fun! ","slug":"2018-10-29-sed","published":1,"updated":"2022-09-17T02:04:05.116Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl85g865p000e4gkr7tfnhozw","content":"<p>In the third project, a bunch of mega data are generated for analysis. However, the simulated data is too big to load in memory. Thus, I need to extract some information without opening the file. After quite a few time searching for a solution, <code>sed</code> command in bash language helps me out. More details about the third project is coming soon.</p>\n<span id=\"more\"></span>\n\n<h2 id=\"The-data-file\"><a href=\"#The-data-file\" class=\"headerlink\" title=\"The data file\"></a>The data file</h2><p>The data file contains a few snapshot on different time points. Some matrix are written in the file when a snapshot time is hit. These matrix may be very large according to the parameter settings you chose. What I want to extract is the matrix \\(\\boldsymbol{D}\\) and \\(\\boldsymbol{R}\\) at the end. </p>\n<p><img src=\"/2018-10-29-sed/rawdata.png\" alt=\"Raw data files.\"></p>\n<h2 id=\"Extracting-the-matrix\"><a href=\"#Extracting-the-matrix\" class=\"headerlink\" title=\"Extracting the matrix\"></a>Extracting the matrix</h2><p>Firstly, I extract all the \\(\\boldsymbol{D}\\)s, for example, from the data file. The following code does the thing for me.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> &#123;0..4&#125;;</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> &#123;0..4&#125;;</span><br><span class=\"line\"><span class=\"keyword\">do</span> </span><br><span class=\"line\">sed -n <span class=\"string\">&#x27;/D&#x27;</span>&#123;<span class=\"string\">&#x27;length(D)+1&#x27;</span>&#125;<span class=\"string\">&#x27; = \\[\\r/,/\\];/p&#x27;</span> <span class=\"built_in\">test</span><span class=\"string\">&quot;$j<span class=\"variable\">$i</span>&quot;</span>.m &gt; Ds<span class=\"string\">&quot;$j<span class=\"variable\">$i</span>&quot;</span>.Rdata</span><br><span class=\"line\"><span class=\"built_in\">echo</span> $j<span class=\"variable\">$i</span><span class=\"string\">&#x27; done&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<p>As you see, there are in total 25 data files I need to deal with. For each data file, <code>sed</code> finds the line starting with “\\(D\\left\\{length(D)+1\\right\\} &#x3D; [\\)” till “\\(];\\)” from the file testji.m and writes&#x2F;prints (\\(p\\)) all the matched lines to the file Dsji.Rdata. </p>\n<p><img src=\"/2018-10-29-sed/ds.png\" alt=\"All D matrix are extracted.\"></p>\n<h2 id=\"Replacing-the-last-D-matrix\"><a href=\"#Replacing-the-last-D-matrix\" class=\"headerlink\" title=\"Replacing the last D matrix\"></a>Replacing the last D matrix</h2><p>Then, I want to extract the last  \\(\\boldsymbol{D}\\) matrix. How can I do that? Use the following code:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> &#123;0..4&#125;;</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> &#123;0..4&#125;;</span><br><span class=\"line\"><span class=\"keyword\">do</span> </span><br><span class=\"line\">A=$(grep -c <span class=\"string\">&#x27;D&#x27;</span>&#123;<span class=\"string\">&#x27;length(D)+1&#x27;</span>&#125;<span class=\"string\">&#x27; = \\[&#x27;</span> Ds<span class=\"string\">&quot;$j<span class=\"variable\">$i</span>&quot;</span>.Rdata)</span><br><span class=\"line\">B=$[<span class=\"variable\">$A</span>-1]</span><br><span class=\"line\">sed <span class=\"string\">&#x27;/D&#x27;</span>&#123;<span class=\"string\">&#x27;length(D)+1&#x27;</span>&#125;<span class=\"string\">&#x27;/&#123;G;s/\\nX\\&#123;&#x27;</span><span class=\"variable\">$B</span><span class=\"string\">&#x27;\\&#125;//;tend;x;s/^/X/;x;P;d&#125;;p;d;:end;s/D&#x27;</span>&#123;<span class=\"string\">&#x27;length(D)+1&#x27;</span>&#125;<span class=\"string\">&#x27;/D/;:a;n;ba&#x27;</span> Ds<span class=\"string\">&quot;$j<span class=\"variable\">$i</span>&quot;</span>.Rdata&gt;Dt<span class=\"string\">&quot;$j<span class=\"variable\">$i</span>&quot;</span>.Rdata</span><br><span class=\"line\">sed -n <span class=\"string\">&#x27;/D = \\[\\r/,/\\];/p&#x27;</span> Dt<span class=\"string\">&quot;$j<span class=\"variable\">$i</span>&quot;</span>.Rdata &gt; D<span class=\"string\">&quot;$j<span class=\"variable\">$i</span>&quot;</span>.Rdata</span><br><span class=\"line\"></span><br><span class=\"line\">C=$(<span class=\"built_in\">cat</span> D<span class=\"string\">&quot;$j<span class=\"variable\">$i</span>&quot;</span>.Rdata |<span class=\"built_in\">wc</span> -l)</span><br><span class=\"line\">C=$[<span class=\"variable\">$C</span>-2]</span><br><span class=\"line\">D=$[<span class=\"variable\">$C</span>+1]</span><br><span class=\"line\"></span><br><span class=\"line\">sed -i -e <span class=\"string\">&#x27;s/D = \\[/D = structure(c(/&#x27;</span> -e <span class=\"string\">&#x27;s/\\];/),.Dim=c(&#x27;</span>$(<span class=\"built_in\">echo</span> <span class=\"variable\">$C</span>)<span class=\"string\">&#x27;,&#x27;</span>$(<span class=\"built_in\">echo</span> <span class=\"variable\">$C</span>)<span class=\"string\">&#x27;))/&#x27;</span> -e <span class=\"string\">&#x27;s/;/ /g&#x27;</span> -e <span class=\"string\">&#x27;2,$&#123;s/ /,/g&#125;&#x27;</span> -e <span class=\"string\">&#x27;2,$&#123;s/,,/ /g&#125;&#x27;</span> -e <span class=\"string\">&#x27;3,&#x27;</span>$(<span class=\"built_in\">echo</span> <span class=\"variable\">$D</span>)<span class=\"string\">&#x27;&#123;s/^/,/g&#125;&#x27;</span> D<span class=\"string\">&quot;$j<span class=\"variable\">$i</span>&quot;</span>.Rdata</span><br><span class=\"line\"><span class=\"built_in\">echo</span> $j<span class=\"variable\">$i</span><span class=\"string\">&#x27; done&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<p>The command <code>grep</code> returns the number of the replicates of the line “\\(D\\left\\{length(D)+1\\right\\} &#x3D; [\\)”. Then <code>sed</code> replaces the head of the last matrix with \\(D\\) and extracts this matrix out and writes into file Dij.Rdata. As I want to work in R with these results, I reformat the structure of the results to fit the matrix format in R which is something like:</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D <span class=\"operator\">=</span> structure<span class=\"punctuation\">(</span><span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"number\">1</span><span class=\"punctuation\">,</span><span class=\"number\">0</span><span class=\"punctuation\">,</span><span class=\"number\">0</span><span class=\"punctuation\">,</span><span class=\"number\">1</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span>.Dim<span class=\"operator\">=</span><span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"number\">2</span><span class=\"punctuation\">,</span><span class=\"number\">2</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>At last, I can directly <code>source</code> the file in R and read the matrix. </p>\n<p><img src=\"/2018-10-29-sed/d.png\" alt=\"The last D matrix is captured.\"></p>\n<h2 id=\"Details-in-sed\"><a href=\"#Details-in-sed\" class=\"headerlink\" title=\"Details in sed\"></a>Details in sed</h2><p>The first <code>sed</code> in the second script is the key part in this function. </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed <span class=\"string\">&#x27;/D&#x27;</span>&#123;<span class=\"string\">&#x27;length(D)+1&#x27;</span>&#125;<span class=\"string\">&#x27;/&#123;G;s/\\nX\\&#123;&#x27;</span><span class=\"variable\">$B</span><span class=\"string\">&#x27;\\&#125;//;tend;x;s/^/X/;x;P;d&#125;;p;d;:end;s/D&#x27;</span>&#123;<span class=\"string\">&#x27;length(D)+1&#x27;</span>&#125;<span class=\"string\">&#x27;/D/;:a;n;ba&#x27;</span> Ds<span class=\"string\">&quot;$j<span class=\"variable\">$i</span>&quot;</span>.Rdata&gt;Dt<span class=\"string\">&quot;$j<span class=\"variable\">$i</span>&quot;</span>.Rdata</span><br></pre></td></tr></table></figure>\n\n<p>I don’t fully understand what every letter in this command means. In this <a href=\"https://superuser.com/questions/394282/sed-perform-only-first-nth-matched-replacement\">answer</a>, the author explained the idea is to store a \\(X\\) at each match in the holdspace, and when all the \\(X\\)s are there, loop till the end of file. If you know more, please comment after the post. Thanks!</p>\n<p>The third <code>sed</code> reformats the matrix to fit in R. <code>-e</code> executes several commands in one line. </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed -i -e <span class=\"string\">&#x27;s/D = \\[/D = structure(c(/&#x27;</span> -e <span class=\"string\">&#x27;s/\\];/),.Dim=c(&#x27;</span>$(<span class=\"built_in\">echo</span> <span class=\"variable\">$C</span>)<span class=\"string\">&#x27;,&#x27;</span>$(<span class=\"built_in\">echo</span> <span class=\"variable\">$C</span>)<span class=\"string\">&#x27;))/&#x27;</span> -e <span class=\"string\">&#x27;s/;/ /g&#x27;</span> -e <span class=\"string\">&#x27;2,$&#123;s/ /,/g&#125;&#x27;</span> -e <span class=\"string\">&#x27;2,$&#123;s/,,/ /g&#125;&#x27;</span> -e <span class=\"string\">&#x27;3,&#x27;</span>$(<span class=\"built_in\">echo</span> <span class=\"variable\">$D</span>)<span class=\"string\">&#x27;&#123;s/^/,/g&#125;&#x27;</span> D<span class=\"string\">&quot;$j<span class=\"variable\">$i</span>&quot;</span>.Rdata</span><br></pre></td></tr></table></figure>\n\n<p>The first segment replaces “\\(D &#x3D; [ \\)” with “\\(D &#x3D; structure(c( \\)” while the second replaces the tail “];” with “(,.Dim&#x3D;c(row,col)”. Then all the signs “;” are substituted by space and the single space is substituted by “,” from the second line to the end. Following the replacement of “,,” by space from the second line and add “,” at the beginning of the line from the third line on. Finally, a standard matrix form is rebuilt.  </p>\n<p>BTW, a good tutorial can be found <a href=\"http://www.grymoire.com/Unix/Sed.html\">here</a>. Have fun! </p>\n","site":{"data":{}},"excerpt":"<p>In the third project, a bunch of mega data are generated for analysis. However, the simulated data is too big to load in memory. Thus, I need to extract some information without opening the file. After quite a few time searching for a solution, <code>sed</code> command in bash language helps me out. More details about the third project is coming soon.</p>","more":"<h2 id=\"The-data-file\"><a href=\"#The-data-file\" class=\"headerlink\" title=\"The data file\"></a>The data file</h2><p>The data file contains a few snapshot on different time points. Some matrix are written in the file when a snapshot time is hit. These matrix may be very large according to the parameter settings you chose. What I want to extract is the matrix \\(\\boldsymbol{D}\\) and \\(\\boldsymbol{R}\\) at the end. </p>\n<p><img src=\"/2018-10-29-sed/rawdata.png\" alt=\"Raw data files.\"></p>\n<h2 id=\"Extracting-the-matrix\"><a href=\"#Extracting-the-matrix\" class=\"headerlink\" title=\"Extracting the matrix\"></a>Extracting the matrix</h2><p>Firstly, I extract all the \\(\\boldsymbol{D}\\)s, for example, from the data file. The following code does the thing for me.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> &#123;0..4&#125;;</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> &#123;0..4&#125;;</span><br><span class=\"line\"><span class=\"keyword\">do</span> </span><br><span class=\"line\">sed -n <span class=\"string\">&#x27;/D&#x27;</span>&#123;<span class=\"string\">&#x27;length(D)+1&#x27;</span>&#125;<span class=\"string\">&#x27; = \\[\\r/,/\\];/p&#x27;</span> <span class=\"built_in\">test</span><span class=\"string\">&quot;$j<span class=\"variable\">$i</span>&quot;</span>.m &gt; Ds<span class=\"string\">&quot;$j<span class=\"variable\">$i</span>&quot;</span>.Rdata</span><br><span class=\"line\"><span class=\"built_in\">echo</span> $j<span class=\"variable\">$i</span><span class=\"string\">&#x27; done&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<p>As you see, there are in total 25 data files I need to deal with. For each data file, <code>sed</code> finds the line starting with “\\(D\\left\\{length(D)+1\\right\\} &#x3D; [\\)” till “\\(];\\)” from the file testji.m and writes&#x2F;prints (\\(p\\)) all the matched lines to the file Dsji.Rdata. </p>\n<p><img src=\"/2018-10-29-sed/ds.png\" alt=\"All D matrix are extracted.\"></p>\n<h2 id=\"Replacing-the-last-D-matrix\"><a href=\"#Replacing-the-last-D-matrix\" class=\"headerlink\" title=\"Replacing the last D matrix\"></a>Replacing the last D matrix</h2><p>Then, I want to extract the last  \\(\\boldsymbol{D}\\) matrix. How can I do that? Use the following code:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> &#123;0..4&#125;;</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> &#123;0..4&#125;;</span><br><span class=\"line\"><span class=\"keyword\">do</span> </span><br><span class=\"line\">A=$(grep -c <span class=\"string\">&#x27;D&#x27;</span>&#123;<span class=\"string\">&#x27;length(D)+1&#x27;</span>&#125;<span class=\"string\">&#x27; = \\[&#x27;</span> Ds<span class=\"string\">&quot;$j<span class=\"variable\">$i</span>&quot;</span>.Rdata)</span><br><span class=\"line\">B=$[<span class=\"variable\">$A</span>-1]</span><br><span class=\"line\">sed <span class=\"string\">&#x27;/D&#x27;</span>&#123;<span class=\"string\">&#x27;length(D)+1&#x27;</span>&#125;<span class=\"string\">&#x27;/&#123;G;s/\\nX\\&#123;&#x27;</span><span class=\"variable\">$B</span><span class=\"string\">&#x27;\\&#125;//;tend;x;s/^/X/;x;P;d&#125;;p;d;:end;s/D&#x27;</span>&#123;<span class=\"string\">&#x27;length(D)+1&#x27;</span>&#125;<span class=\"string\">&#x27;/D/;:a;n;ba&#x27;</span> Ds<span class=\"string\">&quot;$j<span class=\"variable\">$i</span>&quot;</span>.Rdata&gt;Dt<span class=\"string\">&quot;$j<span class=\"variable\">$i</span>&quot;</span>.Rdata</span><br><span class=\"line\">sed -n <span class=\"string\">&#x27;/D = \\[\\r/,/\\];/p&#x27;</span> Dt<span class=\"string\">&quot;$j<span class=\"variable\">$i</span>&quot;</span>.Rdata &gt; D<span class=\"string\">&quot;$j<span class=\"variable\">$i</span>&quot;</span>.Rdata</span><br><span class=\"line\"></span><br><span class=\"line\">C=$(<span class=\"built_in\">cat</span> D<span class=\"string\">&quot;$j<span class=\"variable\">$i</span>&quot;</span>.Rdata |<span class=\"built_in\">wc</span> -l)</span><br><span class=\"line\">C=$[<span class=\"variable\">$C</span>-2]</span><br><span class=\"line\">D=$[<span class=\"variable\">$C</span>+1]</span><br><span class=\"line\"></span><br><span class=\"line\">sed -i -e <span class=\"string\">&#x27;s/D = \\[/D = structure(c(/&#x27;</span> -e <span class=\"string\">&#x27;s/\\];/),.Dim=c(&#x27;</span>$(<span class=\"built_in\">echo</span> <span class=\"variable\">$C</span>)<span class=\"string\">&#x27;,&#x27;</span>$(<span class=\"built_in\">echo</span> <span class=\"variable\">$C</span>)<span class=\"string\">&#x27;))/&#x27;</span> -e <span class=\"string\">&#x27;s/;/ /g&#x27;</span> -e <span class=\"string\">&#x27;2,$&#123;s/ /,/g&#125;&#x27;</span> -e <span class=\"string\">&#x27;2,$&#123;s/,,/ /g&#125;&#x27;</span> -e <span class=\"string\">&#x27;3,&#x27;</span>$(<span class=\"built_in\">echo</span> <span class=\"variable\">$D</span>)<span class=\"string\">&#x27;&#123;s/^/,/g&#125;&#x27;</span> D<span class=\"string\">&quot;$j<span class=\"variable\">$i</span>&quot;</span>.Rdata</span><br><span class=\"line\"><span class=\"built_in\">echo</span> $j<span class=\"variable\">$i</span><span class=\"string\">&#x27; done&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<p>The command <code>grep</code> returns the number of the replicates of the line “\\(D\\left\\{length(D)+1\\right\\} &#x3D; [\\)”. Then <code>sed</code> replaces the head of the last matrix with \\(D\\) and extracts this matrix out and writes into file Dij.Rdata. As I want to work in R with these results, I reformat the structure of the results to fit the matrix format in R which is something like:</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D <span class=\"operator\">=</span> structure<span class=\"punctuation\">(</span><span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"number\">1</span><span class=\"punctuation\">,</span><span class=\"number\">0</span><span class=\"punctuation\">,</span><span class=\"number\">0</span><span class=\"punctuation\">,</span><span class=\"number\">1</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span>.Dim<span class=\"operator\">=</span><span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"number\">2</span><span class=\"punctuation\">,</span><span class=\"number\">2</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>At last, I can directly <code>source</code> the file in R and read the matrix. </p>\n<p><img src=\"/2018-10-29-sed/d.png\" alt=\"The last D matrix is captured.\"></p>\n<h2 id=\"Details-in-sed\"><a href=\"#Details-in-sed\" class=\"headerlink\" title=\"Details in sed\"></a>Details in sed</h2><p>The first <code>sed</code> in the second script is the key part in this function. </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed <span class=\"string\">&#x27;/D&#x27;</span>&#123;<span class=\"string\">&#x27;length(D)+1&#x27;</span>&#125;<span class=\"string\">&#x27;/&#123;G;s/\\nX\\&#123;&#x27;</span><span class=\"variable\">$B</span><span class=\"string\">&#x27;\\&#125;//;tend;x;s/^/X/;x;P;d&#125;;p;d;:end;s/D&#x27;</span>&#123;<span class=\"string\">&#x27;length(D)+1&#x27;</span>&#125;<span class=\"string\">&#x27;/D/;:a;n;ba&#x27;</span> Ds<span class=\"string\">&quot;$j<span class=\"variable\">$i</span>&quot;</span>.Rdata&gt;Dt<span class=\"string\">&quot;$j<span class=\"variable\">$i</span>&quot;</span>.Rdata</span><br></pre></td></tr></table></figure>\n\n<p>I don’t fully understand what every letter in this command means. In this <a href=\"https://superuser.com/questions/394282/sed-perform-only-first-nth-matched-replacement\">answer</a>, the author explained the idea is to store a \\(X\\) at each match in the holdspace, and when all the \\(X\\)s are there, loop till the end of file. If you know more, please comment after the post. Thanks!</p>\n<p>The third <code>sed</code> reformats the matrix to fit in R. <code>-e</code> executes several commands in one line. </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed -i -e <span class=\"string\">&#x27;s/D = \\[/D = structure(c(/&#x27;</span> -e <span class=\"string\">&#x27;s/\\];/),.Dim=c(&#x27;</span>$(<span class=\"built_in\">echo</span> <span class=\"variable\">$C</span>)<span class=\"string\">&#x27;,&#x27;</span>$(<span class=\"built_in\">echo</span> <span class=\"variable\">$C</span>)<span class=\"string\">&#x27;))/&#x27;</span> -e <span class=\"string\">&#x27;s/;/ /g&#x27;</span> -e <span class=\"string\">&#x27;2,$&#123;s/ /,/g&#125;&#x27;</span> -e <span class=\"string\">&#x27;2,$&#123;s/,,/ /g&#125;&#x27;</span> -e <span class=\"string\">&#x27;3,&#x27;</span>$(<span class=\"built_in\">echo</span> <span class=\"variable\">$D</span>)<span class=\"string\">&#x27;&#123;s/^/,/g&#125;&#x27;</span> D<span class=\"string\">&quot;$j<span class=\"variable\">$i</span>&quot;</span>.Rdata</span><br></pre></td></tr></table></figure>\n\n<p>The first segment replaces “\\(D &#x3D; [ \\)” with “\\(D &#x3D; structure(c( \\)” while the second replaces the tail “];” with “(,.Dim&#x3D;c(row,col)”. Then all the signs “;” are substituted by space and the single space is substituted by “,” from the second line to the end. Following the replacement of “,,” by space from the second line and add “,” at the beginning of the line from the third line on. Finally, a standard matrix form is rebuilt.  </p>\n<p>BTW, a good tutorial can be found <a href=\"http://www.grymoire.com/Unix/Sed.html\">here</a>. Have fun! </p>"},{"title":"R update all packages","date":"2018-11-26T08:00:00.000Z","_content":"\nA convenient way to update all the packages.\n\n<!--more-->\n\n## Update all the packages\nVery simple, just one piece of code as follows:\n\n```R\nupdate.packages(ask = FALSE, dependencies = c('Suggests'))\n```\n\nRun it in the console of your Rstudio and take a cup of coffee. ","source":"_posts/2018-11-26-Rupdateallpackages.md","raw":"---\ntitle: R update all packages\ncategories: [Research, R]\ntags: [R,update, packages]\ndate: 2018-11-26\n\n---\n\nA convenient way to update all the packages.\n\n<!--more-->\n\n## Update all the packages\nVery simple, just one piece of code as follows:\n\n```R\nupdate.packages(ask = FALSE, dependencies = c('Suggests'))\n```\n\nRun it in the console of your Rstudio and take a cup of coffee. ","slug":"2018-11-26-Rupdateallpackages","published":1,"updated":"2022-09-17T02:04:05.117Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl85g865r000h4gkre3l70jme","content":"<p>A convenient way to update all the packages.</p>\n<span id=\"more\"></span>\n\n<h2 id=\"Update-all-the-packages\"><a href=\"#Update-all-the-packages\" class=\"headerlink\" title=\"Update all the packages\"></a>Update all the packages</h2><p>Very simple, just one piece of code as follows:</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update.packages<span class=\"punctuation\">(</span>ask <span class=\"operator\">=</span> <span class=\"literal\">FALSE</span><span class=\"punctuation\">,</span> dependencies <span class=\"operator\">=</span> <span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"string\">&#x27;Suggests&#x27;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>Run it in the console of your Rstudio and take a cup of coffee. </p>\n","site":{"data":{}},"excerpt":"<p>A convenient way to update all the packages.</p>","more":"<h2 id=\"Update-all-the-packages\"><a href=\"#Update-all-the-packages\" class=\"headerlink\" title=\"Update all the packages\"></a>Update all the packages</h2><p>Very simple, just one piece of code as follows:</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">update.packages<span class=\"punctuation\">(</span>ask <span class=\"operator\">=</span> <span class=\"literal\">FALSE</span><span class=\"punctuation\">,</span> dependencies <span class=\"operator\">=</span> <span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"string\">&#x27;Suggests&#x27;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>Run it in the console of your Rstudio and take a cup of coffee. </p>"},{"title":"Color your plots","date":"2018-11-29T08:00:00.000Z","_content":"\nShare a fancy [website](https://www.webdesignrankings.com/resources/lolcolors/) that shows \"Curated color palette\".\n\n<!--more-->\n\n## Gallery\nSome examples by using different colors. \n\n![colors 1](2018-11-29-color/col1.png)\n![colors 2](2018-11-29-color/col2.png)\n![colors 3](2018-11-29-color/col3.png)\n![colors 4](2018-11-29-color/col4.png)\n\nPlots are generated by [ggtree](http://bioconductor.org/packages/release/bioc/html/ggtree.html). And the data is simulated under our model. Coming soon!\n\nPS: which one do you prefer? Or all suck...","source":"_posts/2018-11-29-color.md","raw":"---\ntitle: Color your plots\ncategories: [Research, Data visualization, R]\ntags: [R,color, python, plot]\ndate: 2018-11-29\n\n---\n\nShare a fancy [website](https://www.webdesignrankings.com/resources/lolcolors/) that shows \"Curated color palette\".\n\n<!--more-->\n\n## Gallery\nSome examples by using different colors. \n\n![colors 1](2018-11-29-color/col1.png)\n![colors 2](2018-11-29-color/col2.png)\n![colors 3](2018-11-29-color/col3.png)\n![colors 4](2018-11-29-color/col4.png)\n\nPlots are generated by [ggtree](http://bioconductor.org/packages/release/bioc/html/ggtree.html). And the data is simulated under our model. Coming soon!\n\nPS: which one do you prefer? Or all suck...","slug":"2018-11-29-color","published":1,"updated":"2022-09-17T02:04:05.117Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl85g865r000i4gkrf61o361n","content":"<p>Share a fancy <a href=\"https://www.webdesignrankings.com/resources/lolcolors/\">website</a> that shows “Curated color palette”.</p>\n<span id=\"more\"></span>\n\n<h2 id=\"Gallery\"><a href=\"#Gallery\" class=\"headerlink\" title=\"Gallery\"></a>Gallery</h2><p>Some examples by using different colors. </p>\n<p><img src=\"/2018-11-29-color/col1.png\" alt=\"colors 1\"><br><img src=\"/2018-11-29-color/col2.png\" alt=\"colors 2\"><br><img src=\"/2018-11-29-color/col3.png\" alt=\"colors 3\"><br><img src=\"/2018-11-29-color/col4.png\" alt=\"colors 4\"></p>\n<p>Plots are generated by <a href=\"http://bioconductor.org/packages/release/bioc/html/ggtree.html\">ggtree</a>. And the data is simulated under our model. Coming soon!</p>\n<p>PS: which one do you prefer? Or all suck…</p>\n","site":{"data":{}},"excerpt":"<p>Share a fancy <a href=\"https://www.webdesignrankings.com/resources/lolcolors/\">website</a> that shows “Curated color palette”.</p>","more":"<h2 id=\"Gallery\"><a href=\"#Gallery\" class=\"headerlink\" title=\"Gallery\"></a>Gallery</h2><p>Some examples by using different colors. </p>\n<p><img src=\"/2018-11-29-color/col1.png\" alt=\"colors 1\"><br><img src=\"/2018-11-29-color/col2.png\" alt=\"colors 2\"><br><img src=\"/2018-11-29-color/col3.png\" alt=\"colors 3\"><br><img src=\"/2018-11-29-color/col4.png\" alt=\"colors 4\"></p>\n<p>Plots are generated by <a href=\"http://bioconductor.org/packages/release/bioc/html/ggtree.html\">ggtree</a>. And the data is simulated under our model. Coming soon!</p>\n<p>PS: which one do you prefer? Or all suck…</p>"},{"title":"ggradar2: deploy a radar to your data ","date":"2018-12-05T08:00:00.000Z","_content":"\n[`ggradar2`](https://github.com/xl0418/ggradar2) is  now available. A large amount of features have been added to make your radar chart powerful. See [`ggradar2`](https://github.com/xl0418/ggradar2) on my [Github](https://github.com/xl0418)\n\n<!--more-->\n\n## Introduction\nggradar2 is a gg-function to draw a radar plot for data analysis. It is stem from [ggradar](https://github.com/ricardo-bion/ggradar) but has been extended with more cool features. \n\n\n## Install ggradar2\nRun the code \n\n```R\ndevtools::install_github(\"xl0418/ggradar2\",dependencies=TRUE)\n```\n\n## Use ggradar2\n### Load data.\n\n```R\nlibrary(ggradar2)\ndata(mtcars)\n% Extract the group names. Otherwise, the first column will be chosen as the group names.\ngroup = row.names(mtcars)\ndf = cbind(group,mtcars)\n% The radar chart is not a nice presentation if you want to compare too many groups. Thus here \n% we only focus on 4 groups.\ndftest = head(df,4)\n% To better distinguish two different styles, 6 groups are selected for illustration.\ndftest = dftest[,1:7]\n```\n\n### Default style\nBy default\n\n```R\nggradar2(dftest)\n```\n\nreturns \n\n![default](2018-12-05-ggradar2/roundfill.png)\n\n### No fill with round grid\nIf you don't want to fill the polygon, run\n\n```R\nggradar2(dftest,polygonfill = FALSE)\n```\n\n![default](2018-12-05-ggradar2/roundnofill.png)\n\n### Web type\nA new web type 'lux' has been added by `webtype`.\n\nmini type\n\n```R\nggradar2(dftest,webtype = 'mini')\n```\n\n![default](2018-12-05-ggradar2/mini.png)\n\nluxurious type\n\n```R\nggradar2(dftest,webtype = 'lux')\n```\n\n![default](2018-12-05-ggradar2/lux.png)\n\n\n### Gird line trend\nUse `grid.line.trend = 'increase'` to plot an outward-increasing grid lines.\n\n```R\nggradar2(dftest,style = 'sharp',webtype = 'lux',\n              group.line.width = 0.5,grid.line.trend = 'increase',gridline.min.linetype = 'solid',\n              gridline.max.linetype = 'solid',gridline.min.colour = 'black',gridline.max.colour='black')\n```\n\n![default](2018-12-05-ggradar2/trend.png)\n\n\n### Full score\nUse `fullscore = c(...)` to set the full score to each variable.\n\n```R\nfullscore <- c(100,10,300,150,10,10)\na <- ggradar2(dftest,fullscore = fullscore)\n```\n\n![default](2018-12-05-ggradar2/fullscore.png)\n\n\n### Sharp grid\nA new style has been added. Call out the straight line style by running \n\n```R\nggradar2(dftest,style = 'sharp')\n```\n\n![default](2018-12-05-ggradar2/straightfill.png)\n\n### Sharp grid without fill\nGet rid of the fill\n\n```R\nggradar2(dftest,style = 'sharp',polygonfill = FALSE)\n```\n\n![default](2018-12-05-ggradar2/straightnofill.png)\n\n### Removing the legend \n\n```R\nggradar2(dftest,style = 'sharp',\npolygonfill = FALSE,plot.legend = FALSE)\n```\n\n![default](2018-12-05-ggradar2/nolegend.png)\n\n### Multiple plots by subgroups\n\n```R\n# Extract 3 brands of cars out of the data frame\nfacettest <- df[c(1,2,4,5,8:14),]\n# Set the subgroup names\nfacet1 <- mapply(rep,c('Mazda','Hornet','Merc'),c(2,2,7))\nfacet1 <- Reduce(c,facet1)\nfacettest <- cbind(facettest,facet1)\nggradar2(facettest,multiplots = TRUE)\n```\n\nNotice that the column name for the subgroups should be 'facet1'. Otherwise, ggradar2 could not recognize it.\n\n![default](2018-12-05-ggradar2/multipleplotsbig.png)","source":"_posts/2018-12-05-ggradar2.md","raw":"---\ntitle: \"ggradar2: deploy a radar to your data \"\ncategories: [Research, Data visualization, R, ggradar2]\ntags: [R,ggplot, ggradar2, Data visualization]\ndate: 2018-12-05\n\n---\n\n[`ggradar2`](https://github.com/xl0418/ggradar2) is  now available. A large amount of features have been added to make your radar chart powerful. See [`ggradar2`](https://github.com/xl0418/ggradar2) on my [Github](https://github.com/xl0418)\n\n<!--more-->\n\n## Introduction\nggradar2 is a gg-function to draw a radar plot for data analysis. It is stem from [ggradar](https://github.com/ricardo-bion/ggradar) but has been extended with more cool features. \n\n\n## Install ggradar2\nRun the code \n\n```R\ndevtools::install_github(\"xl0418/ggradar2\",dependencies=TRUE)\n```\n\n## Use ggradar2\n### Load data.\n\n```R\nlibrary(ggradar2)\ndata(mtcars)\n% Extract the group names. Otherwise, the first column will be chosen as the group names.\ngroup = row.names(mtcars)\ndf = cbind(group,mtcars)\n% The radar chart is not a nice presentation if you want to compare too many groups. Thus here \n% we only focus on 4 groups.\ndftest = head(df,4)\n% To better distinguish two different styles, 6 groups are selected for illustration.\ndftest = dftest[,1:7]\n```\n\n### Default style\nBy default\n\n```R\nggradar2(dftest)\n```\n\nreturns \n\n![default](2018-12-05-ggradar2/roundfill.png)\n\n### No fill with round grid\nIf you don't want to fill the polygon, run\n\n```R\nggradar2(dftest,polygonfill = FALSE)\n```\n\n![default](2018-12-05-ggradar2/roundnofill.png)\n\n### Web type\nA new web type 'lux' has been added by `webtype`.\n\nmini type\n\n```R\nggradar2(dftest,webtype = 'mini')\n```\n\n![default](2018-12-05-ggradar2/mini.png)\n\nluxurious type\n\n```R\nggradar2(dftest,webtype = 'lux')\n```\n\n![default](2018-12-05-ggradar2/lux.png)\n\n\n### Gird line trend\nUse `grid.line.trend = 'increase'` to plot an outward-increasing grid lines.\n\n```R\nggradar2(dftest,style = 'sharp',webtype = 'lux',\n              group.line.width = 0.5,grid.line.trend = 'increase',gridline.min.linetype = 'solid',\n              gridline.max.linetype = 'solid',gridline.min.colour = 'black',gridline.max.colour='black')\n```\n\n![default](2018-12-05-ggradar2/trend.png)\n\n\n### Full score\nUse `fullscore = c(...)` to set the full score to each variable.\n\n```R\nfullscore <- c(100,10,300,150,10,10)\na <- ggradar2(dftest,fullscore = fullscore)\n```\n\n![default](2018-12-05-ggradar2/fullscore.png)\n\n\n### Sharp grid\nA new style has been added. Call out the straight line style by running \n\n```R\nggradar2(dftest,style = 'sharp')\n```\n\n![default](2018-12-05-ggradar2/straightfill.png)\n\n### Sharp grid without fill\nGet rid of the fill\n\n```R\nggradar2(dftest,style = 'sharp',polygonfill = FALSE)\n```\n\n![default](2018-12-05-ggradar2/straightnofill.png)\n\n### Removing the legend \n\n```R\nggradar2(dftest,style = 'sharp',\npolygonfill = FALSE,plot.legend = FALSE)\n```\n\n![default](2018-12-05-ggradar2/nolegend.png)\n\n### Multiple plots by subgroups\n\n```R\n# Extract 3 brands of cars out of the data frame\nfacettest <- df[c(1,2,4,5,8:14),]\n# Set the subgroup names\nfacet1 <- mapply(rep,c('Mazda','Hornet','Merc'),c(2,2,7))\nfacet1 <- Reduce(c,facet1)\nfacettest <- cbind(facettest,facet1)\nggradar2(facettest,multiplots = TRUE)\n```\n\nNotice that the column name for the subgroups should be 'facet1'. Otherwise, ggradar2 could not recognize it.\n\n![default](2018-12-05-ggradar2/multipleplotsbig.png)","slug":"2018-12-05-ggradar2","published":1,"updated":"2022-09-17T02:04:05.118Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl85g865s000l4gkrcg7282ew","content":"<p><a href=\"https://github.com/xl0418/ggradar2\"><code>ggradar2</code></a> is  now available. A large amount of features have been added to make your radar chart powerful. See <a href=\"https://github.com/xl0418/ggradar2\"><code>ggradar2</code></a> on my <a href=\"https://github.com/xl0418\">Github</a></p>\n<span id=\"more\"></span>\n\n<h2 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h2><p>ggradar2 is a gg-function to draw a radar plot for data analysis. It is stem from <a href=\"https://github.com/ricardo-bion/ggradar\">ggradar</a> but has been extended with more cool features. </p>\n<h2 id=\"Install-ggradar2\"><a href=\"#Install-ggradar2\" class=\"headerlink\" title=\"Install ggradar2\"></a>Install ggradar2</h2><p>Run the code </p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">devtools<span class=\"operator\">::</span>install_github<span class=\"punctuation\">(</span><span class=\"string\">&quot;xl0418/ggradar2&quot;</span><span class=\"punctuation\">,</span>dependencies<span class=\"operator\">=</span><span class=\"literal\">TRUE</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Use-ggradar2\"><a href=\"#Use-ggradar2\" class=\"headerlink\" title=\"Use ggradar2\"></a>Use ggradar2</h2><h3 id=\"Load-data\"><a href=\"#Load-data\" class=\"headerlink\" title=\"Load data.\"></a>Load data.</h3><figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">library<span class=\"punctuation\">(</span>ggradar2<span class=\"punctuation\">)</span></span><br><span class=\"line\">data<span class=\"punctuation\">(</span>mtcars<span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"operator\">% Extract the group names. Otherwise, the first column will be chosen as the group names.</span></span><br><span class=\"line\"><span class=\"operator\">group = row.names(mtcars)</span></span><br><span class=\"line\"><span class=\"operator\">df = cbind(group,mtcars)</span></span><br><span class=\"line\"><span class=\"operator\">%</span> The radar chart is not a nice presentation <span class=\"keyword\">if</span> you want to compare too many groups. Thus here </span><br><span class=\"line\"><span class=\"operator\">% we only focus on 4 groups.</span></span><br><span class=\"line\"><span class=\"operator\">dftest = head(df,4)</span></span><br><span class=\"line\"><span class=\"operator\">%</span> To better distinguish two different styles<span class=\"punctuation\">,</span> <span class=\"number\">6</span> groups are selected <span class=\"keyword\">for</span> illustration.</span><br><span class=\"line\">dftest <span class=\"operator\">=</span> dftest<span class=\"punctuation\">[</span><span class=\"punctuation\">,</span><span class=\"number\">1</span><span class=\"operator\">:</span><span class=\"number\">7</span><span class=\"punctuation\">]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Default-style\"><a href=\"#Default-style\" class=\"headerlink\" title=\"Default style\"></a>Default style</h3><p>By default</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ggradar2<span class=\"punctuation\">(</span>dftest<span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>returns </p>\n<p><img src=\"/2018-12-05-ggradar2/roundfill.png\" alt=\"default\"></p>\n<h3 id=\"No-fill-with-round-grid\"><a href=\"#No-fill-with-round-grid\" class=\"headerlink\" title=\"No fill with round grid\"></a>No fill with round grid</h3><p>If you don’t want to fill the polygon, run</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ggradar2<span class=\"punctuation\">(</span>dftest<span class=\"punctuation\">,</span>polygonfill <span class=\"operator\">=</span> <span class=\"literal\">FALSE</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2018-12-05-ggradar2/roundnofill.png\" alt=\"default\"></p>\n<h3 id=\"Web-type\"><a href=\"#Web-type\" class=\"headerlink\" title=\"Web type\"></a>Web type</h3><p>A new web type ‘lux’ has been added by <code>webtype</code>.</p>\n<p>mini type</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ggradar2<span class=\"punctuation\">(</span>dftest<span class=\"punctuation\">,</span>webtype <span class=\"operator\">=</span> <span class=\"string\">&#x27;mini&#x27;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2018-12-05-ggradar2/mini.png\" alt=\"default\"></p>\n<p>luxurious type</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ggradar2<span class=\"punctuation\">(</span>dftest<span class=\"punctuation\">,</span>webtype <span class=\"operator\">=</span> <span class=\"string\">&#x27;lux&#x27;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2018-12-05-ggradar2/lux.png\" alt=\"default\"></p>\n<h3 id=\"Gird-line-trend\"><a href=\"#Gird-line-trend\" class=\"headerlink\" title=\"Gird line trend\"></a>Gird line trend</h3><p>Use <code>grid.line.trend = &#39;increase&#39;</code> to plot an outward-increasing grid lines.</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ggradar2<span class=\"punctuation\">(</span>dftest<span class=\"punctuation\">,</span>style <span class=\"operator\">=</span> <span class=\"string\">&#x27;sharp&#x27;</span><span class=\"punctuation\">,</span>webtype <span class=\"operator\">=</span> <span class=\"string\">&#x27;lux&#x27;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">              group.line.width <span class=\"operator\">=</span> <span class=\"number\">0.5</span><span class=\"punctuation\">,</span>grid.line.trend <span class=\"operator\">=</span> <span class=\"string\">&#x27;increase&#x27;</span><span class=\"punctuation\">,</span>gridline.min.linetype <span class=\"operator\">=</span> <span class=\"string\">&#x27;solid&#x27;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">              gridline.max.linetype <span class=\"operator\">=</span> <span class=\"string\">&#x27;solid&#x27;</span><span class=\"punctuation\">,</span>gridline.min.colour <span class=\"operator\">=</span> <span class=\"string\">&#x27;black&#x27;</span><span class=\"punctuation\">,</span>gridline.max.colour<span class=\"operator\">=</span><span class=\"string\">&#x27;black&#x27;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2018-12-05-ggradar2/trend.png\" alt=\"default\"></p>\n<h3 id=\"Full-score\"><a href=\"#Full-score\" class=\"headerlink\" title=\"Full score\"></a>Full score</h3><p>Use <code>fullscore = c(...)</code> to set the full score to each variable.</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fullscore <span class=\"operator\">&lt;-</span> <span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"number\">100</span><span class=\"punctuation\">,</span><span class=\"number\">10</span><span class=\"punctuation\">,</span><span class=\"number\">300</span><span class=\"punctuation\">,</span><span class=\"number\">150</span><span class=\"punctuation\">,</span><span class=\"number\">10</span><span class=\"punctuation\">,</span><span class=\"number\">10</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">a <span class=\"operator\">&lt;-</span> ggradar2<span class=\"punctuation\">(</span>dftest<span class=\"punctuation\">,</span>fullscore <span class=\"operator\">=</span> fullscore<span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2018-12-05-ggradar2/fullscore.png\" alt=\"default\"></p>\n<h3 id=\"Sharp-grid\"><a href=\"#Sharp-grid\" class=\"headerlink\" title=\"Sharp grid\"></a>Sharp grid</h3><p>A new style has been added. Call out the straight line style by running </p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ggradar2<span class=\"punctuation\">(</span>dftest<span class=\"punctuation\">,</span>style <span class=\"operator\">=</span> <span class=\"string\">&#x27;sharp&#x27;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2018-12-05-ggradar2/straightfill.png\" alt=\"default\"></p>\n<h3 id=\"Sharp-grid-without-fill\"><a href=\"#Sharp-grid-without-fill\" class=\"headerlink\" title=\"Sharp grid without fill\"></a>Sharp grid without fill</h3><p>Get rid of the fill</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ggradar2<span class=\"punctuation\">(</span>dftest<span class=\"punctuation\">,</span>style <span class=\"operator\">=</span> <span class=\"string\">&#x27;sharp&#x27;</span><span class=\"punctuation\">,</span>polygonfill <span class=\"operator\">=</span> <span class=\"literal\">FALSE</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2018-12-05-ggradar2/straightnofill.png\" alt=\"default\"></p>\n<h3 id=\"Removing-the-legend\"><a href=\"#Removing-the-legend\" class=\"headerlink\" title=\"Removing the legend\"></a>Removing the legend</h3><figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ggradar2<span class=\"punctuation\">(</span>dftest<span class=\"punctuation\">,</span>style <span class=\"operator\">=</span> <span class=\"string\">&#x27;sharp&#x27;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">polygonfill <span class=\"operator\">=</span> <span class=\"literal\">FALSE</span><span class=\"punctuation\">,</span>plot.legend <span class=\"operator\">=</span> <span class=\"literal\">FALSE</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2018-12-05-ggradar2/nolegend.png\" alt=\"default\"></p>\n<h3 id=\"Multiple-plots-by-subgroups\"><a href=\"#Multiple-plots-by-subgroups\" class=\"headerlink\" title=\"Multiple plots by subgroups\"></a>Multiple plots by subgroups</h3><figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Extract 3 brands of cars out of the data frame</span></span><br><span class=\"line\">facettest <span class=\"operator\">&lt;-</span> df<span class=\"punctuation\">[</span><span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"number\">1</span><span class=\"punctuation\">,</span><span class=\"number\">2</span><span class=\"punctuation\">,</span><span class=\"number\">4</span><span class=\"punctuation\">,</span><span class=\"number\">5</span><span class=\"punctuation\">,</span><span class=\"number\">8</span><span class=\"operator\">:</span><span class=\"number\">14</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span><span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"comment\"># Set the subgroup names</span></span><br><span class=\"line\">facet1 <span class=\"operator\">&lt;-</span> mapply<span class=\"punctuation\">(</span><span class=\"built_in\">rep</span><span class=\"punctuation\">,</span><span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"string\">&#x27;Mazda&#x27;</span><span class=\"punctuation\">,</span><span class=\"string\">&#x27;Hornet&#x27;</span><span class=\"punctuation\">,</span><span class=\"string\">&#x27;Merc&#x27;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span><span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"number\">2</span><span class=\"punctuation\">,</span><span class=\"number\">2</span><span class=\"punctuation\">,</span><span class=\"number\">7</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">facet1 <span class=\"operator\">&lt;-</span> Reduce<span class=\"punctuation\">(</span><span class=\"built_in\">c</span><span class=\"punctuation\">,</span>facet1<span class=\"punctuation\">)</span></span><br><span class=\"line\">facettest <span class=\"operator\">&lt;-</span> cbind<span class=\"punctuation\">(</span>facettest<span class=\"punctuation\">,</span>facet1<span class=\"punctuation\">)</span></span><br><span class=\"line\">ggradar2<span class=\"punctuation\">(</span>facettest<span class=\"punctuation\">,</span>multiplots <span class=\"operator\">=</span> <span class=\"literal\">TRUE</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>Notice that the column name for the subgroups should be ‘facet1’. Otherwise, ggradar2 could not recognize it.</p>\n<p><img src=\"/2018-12-05-ggradar2/multipleplotsbig.png\" alt=\"default\"></p>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://github.com/xl0418/ggradar2\"><code>ggradar2</code></a> is  now available. A large amount of features have been added to make your radar chart powerful. See <a href=\"https://github.com/xl0418/ggradar2\"><code>ggradar2</code></a> on my <a href=\"https://github.com/xl0418\">Github</a></p>","more":"<h2 id=\"Introduction\"><a href=\"#Introduction\" class=\"headerlink\" title=\"Introduction\"></a>Introduction</h2><p>ggradar2 is a gg-function to draw a radar plot for data analysis. It is stem from <a href=\"https://github.com/ricardo-bion/ggradar\">ggradar</a> but has been extended with more cool features. </p>\n<h2 id=\"Install-ggradar2\"><a href=\"#Install-ggradar2\" class=\"headerlink\" title=\"Install ggradar2\"></a>Install ggradar2</h2><p>Run the code </p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">devtools<span class=\"operator\">::</span>install_github<span class=\"punctuation\">(</span><span class=\"string\">&quot;xl0418/ggradar2&quot;</span><span class=\"punctuation\">,</span>dependencies<span class=\"operator\">=</span><span class=\"literal\">TRUE</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Use-ggradar2\"><a href=\"#Use-ggradar2\" class=\"headerlink\" title=\"Use ggradar2\"></a>Use ggradar2</h2><h3 id=\"Load-data\"><a href=\"#Load-data\" class=\"headerlink\" title=\"Load data.\"></a>Load data.</h3><figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">library<span class=\"punctuation\">(</span>ggradar2<span class=\"punctuation\">)</span></span><br><span class=\"line\">data<span class=\"punctuation\">(</span>mtcars<span class=\"punctuation\">)</span></span><br><span class=\"line\"><span class=\"operator\">% Extract the group names. Otherwise, the first column will be chosen as the group names.</span></span><br><span class=\"line\"><span class=\"operator\">group = row.names(mtcars)</span></span><br><span class=\"line\"><span class=\"operator\">df = cbind(group,mtcars)</span></span><br><span class=\"line\"><span class=\"operator\">%</span> The radar chart is not a nice presentation <span class=\"keyword\">if</span> you want to compare too many groups. Thus here </span><br><span class=\"line\"><span class=\"operator\">% we only focus on 4 groups.</span></span><br><span class=\"line\"><span class=\"operator\">dftest = head(df,4)</span></span><br><span class=\"line\"><span class=\"operator\">%</span> To better distinguish two different styles<span class=\"punctuation\">,</span> <span class=\"number\">6</span> groups are selected <span class=\"keyword\">for</span> illustration.</span><br><span class=\"line\">dftest <span class=\"operator\">=</span> dftest<span class=\"punctuation\">[</span><span class=\"punctuation\">,</span><span class=\"number\">1</span><span class=\"operator\">:</span><span class=\"number\">7</span><span class=\"punctuation\">]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Default-style\"><a href=\"#Default-style\" class=\"headerlink\" title=\"Default style\"></a>Default style</h3><p>By default</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ggradar2<span class=\"punctuation\">(</span>dftest<span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>returns </p>\n<p><img src=\"/2018-12-05-ggradar2/roundfill.png\" alt=\"default\"></p>\n<h3 id=\"No-fill-with-round-grid\"><a href=\"#No-fill-with-round-grid\" class=\"headerlink\" title=\"No fill with round grid\"></a>No fill with round grid</h3><p>If you don’t want to fill the polygon, run</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ggradar2<span class=\"punctuation\">(</span>dftest<span class=\"punctuation\">,</span>polygonfill <span class=\"operator\">=</span> <span class=\"literal\">FALSE</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2018-12-05-ggradar2/roundnofill.png\" alt=\"default\"></p>\n<h3 id=\"Web-type\"><a href=\"#Web-type\" class=\"headerlink\" title=\"Web type\"></a>Web type</h3><p>A new web type ‘lux’ has been added by <code>webtype</code>.</p>\n<p>mini type</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ggradar2<span class=\"punctuation\">(</span>dftest<span class=\"punctuation\">,</span>webtype <span class=\"operator\">=</span> <span class=\"string\">&#x27;mini&#x27;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2018-12-05-ggradar2/mini.png\" alt=\"default\"></p>\n<p>luxurious type</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ggradar2<span class=\"punctuation\">(</span>dftest<span class=\"punctuation\">,</span>webtype <span class=\"operator\">=</span> <span class=\"string\">&#x27;lux&#x27;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2018-12-05-ggradar2/lux.png\" alt=\"default\"></p>\n<h3 id=\"Gird-line-trend\"><a href=\"#Gird-line-trend\" class=\"headerlink\" title=\"Gird line trend\"></a>Gird line trend</h3><p>Use <code>grid.line.trend = &#39;increase&#39;</code> to plot an outward-increasing grid lines.</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ggradar2<span class=\"punctuation\">(</span>dftest<span class=\"punctuation\">,</span>style <span class=\"operator\">=</span> <span class=\"string\">&#x27;sharp&#x27;</span><span class=\"punctuation\">,</span>webtype <span class=\"operator\">=</span> <span class=\"string\">&#x27;lux&#x27;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">              group.line.width <span class=\"operator\">=</span> <span class=\"number\">0.5</span><span class=\"punctuation\">,</span>grid.line.trend <span class=\"operator\">=</span> <span class=\"string\">&#x27;increase&#x27;</span><span class=\"punctuation\">,</span>gridline.min.linetype <span class=\"operator\">=</span> <span class=\"string\">&#x27;solid&#x27;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">              gridline.max.linetype <span class=\"operator\">=</span> <span class=\"string\">&#x27;solid&#x27;</span><span class=\"punctuation\">,</span>gridline.min.colour <span class=\"operator\">=</span> <span class=\"string\">&#x27;black&#x27;</span><span class=\"punctuation\">,</span>gridline.max.colour<span class=\"operator\">=</span><span class=\"string\">&#x27;black&#x27;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2018-12-05-ggradar2/trend.png\" alt=\"default\"></p>\n<h3 id=\"Full-score\"><a href=\"#Full-score\" class=\"headerlink\" title=\"Full score\"></a>Full score</h3><p>Use <code>fullscore = c(...)</code> to set the full score to each variable.</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fullscore <span class=\"operator\">&lt;-</span> <span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"number\">100</span><span class=\"punctuation\">,</span><span class=\"number\">10</span><span class=\"punctuation\">,</span><span class=\"number\">300</span><span class=\"punctuation\">,</span><span class=\"number\">150</span><span class=\"punctuation\">,</span><span class=\"number\">10</span><span class=\"punctuation\">,</span><span class=\"number\">10</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">a <span class=\"operator\">&lt;-</span> ggradar2<span class=\"punctuation\">(</span>dftest<span class=\"punctuation\">,</span>fullscore <span class=\"operator\">=</span> fullscore<span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2018-12-05-ggradar2/fullscore.png\" alt=\"default\"></p>\n<h3 id=\"Sharp-grid\"><a href=\"#Sharp-grid\" class=\"headerlink\" title=\"Sharp grid\"></a>Sharp grid</h3><p>A new style has been added. Call out the straight line style by running </p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ggradar2<span class=\"punctuation\">(</span>dftest<span class=\"punctuation\">,</span>style <span class=\"operator\">=</span> <span class=\"string\">&#x27;sharp&#x27;</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2018-12-05-ggradar2/straightfill.png\" alt=\"default\"></p>\n<h3 id=\"Sharp-grid-without-fill\"><a href=\"#Sharp-grid-without-fill\" class=\"headerlink\" title=\"Sharp grid without fill\"></a>Sharp grid without fill</h3><p>Get rid of the fill</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ggradar2<span class=\"punctuation\">(</span>dftest<span class=\"punctuation\">,</span>style <span class=\"operator\">=</span> <span class=\"string\">&#x27;sharp&#x27;</span><span class=\"punctuation\">,</span>polygonfill <span class=\"operator\">=</span> <span class=\"literal\">FALSE</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2018-12-05-ggradar2/straightnofill.png\" alt=\"default\"></p>\n<h3 id=\"Removing-the-legend\"><a href=\"#Removing-the-legend\" class=\"headerlink\" title=\"Removing the legend\"></a>Removing the legend</h3><figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ggradar2<span class=\"punctuation\">(</span>dftest<span class=\"punctuation\">,</span>style <span class=\"operator\">=</span> <span class=\"string\">&#x27;sharp&#x27;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">polygonfill <span class=\"operator\">=</span> <span class=\"literal\">FALSE</span><span class=\"punctuation\">,</span>plot.legend <span class=\"operator\">=</span> <span class=\"literal\">FALSE</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"/2018-12-05-ggradar2/nolegend.png\" alt=\"default\"></p>\n<h3 id=\"Multiple-plots-by-subgroups\"><a href=\"#Multiple-plots-by-subgroups\" class=\"headerlink\" title=\"Multiple plots by subgroups\"></a>Multiple plots by subgroups</h3><figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Extract 3 brands of cars out of the data frame</span></span><br><span class=\"line\">facettest <span class=\"operator\">&lt;-</span> df<span class=\"punctuation\">[</span><span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"number\">1</span><span class=\"punctuation\">,</span><span class=\"number\">2</span><span class=\"punctuation\">,</span><span class=\"number\">4</span><span class=\"punctuation\">,</span><span class=\"number\">5</span><span class=\"punctuation\">,</span><span class=\"number\">8</span><span class=\"operator\">:</span><span class=\"number\">14</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span><span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"comment\"># Set the subgroup names</span></span><br><span class=\"line\">facet1 <span class=\"operator\">&lt;-</span> mapply<span class=\"punctuation\">(</span><span class=\"built_in\">rep</span><span class=\"punctuation\">,</span><span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"string\">&#x27;Mazda&#x27;</span><span class=\"punctuation\">,</span><span class=\"string\">&#x27;Hornet&#x27;</span><span class=\"punctuation\">,</span><span class=\"string\">&#x27;Merc&#x27;</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span><span class=\"built_in\">c</span><span class=\"punctuation\">(</span><span class=\"number\">2</span><span class=\"punctuation\">,</span><span class=\"number\">2</span><span class=\"punctuation\">,</span><span class=\"number\">7</span><span class=\"punctuation\">)</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">facet1 <span class=\"operator\">&lt;-</span> Reduce<span class=\"punctuation\">(</span><span class=\"built_in\">c</span><span class=\"punctuation\">,</span>facet1<span class=\"punctuation\">)</span></span><br><span class=\"line\">facettest <span class=\"operator\">&lt;-</span> cbind<span class=\"punctuation\">(</span>facettest<span class=\"punctuation\">,</span>facet1<span class=\"punctuation\">)</span></span><br><span class=\"line\">ggradar2<span class=\"punctuation\">(</span>facettest<span class=\"punctuation\">,</span>multiplots <span class=\"operator\">=</span> <span class=\"literal\">TRUE</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>Notice that the column name for the subgroups should be ‘facet1’. Otherwise, ggradar2 could not recognize it.</p>\n<p><img src=\"/2018-12-05-ggradar2/multipleplotsbig.png\" alt=\"default\"></p>"},{"title":"Draw the evolution of SMC","date":"2018-11-30T08:00:00.000Z","_content":"\nFinally, I have done visualizing the evolution of SMC in R instead of in Python. Here, two illustrations are given. \n\n<!--more-->\n\n## Generating Data\nThe data I used in the examples is generated under SMC applying on our trait-population coevolution model, a likelihood-free method for searching the true parameters when an analytic formulation of the model is not achievable. The data is consisting of 30 iterations samples. Each iteration contains 10K sampling. The algorithm starts by sampling from a uniform distribution in range (0,1). After each iteration, it computes the fitness of the samples and highly weights the samples with high fitness. Finally, it converges to the true value.  \n\n## Mountain plot\nMountain plot is recently highly evaluated theme for comparing the distribution of data across groups. The idea is stem from [Henrik's plot](https://twitter.com/hnrklndbrg/status/883675698300420098)\n\n![plot 1](2018-11-30-SMCplots/Rplot1.png)\n\nForget to point out the true value is at 1.0, which is the peak of the distribution at 30th iteration. \n\n## Heatmap plot\nAnother nice presentation is realized by the heat map. The data was manipulated a bit. The density of the samples was converted to the frequency in tiny cells. Then it can be applied by the heat map plot.\n\n![plot 1](2018-11-30-SMCplots/Rplot2.png)\n\nWhich one do you prefer?\n","source":"_posts/2018-11-30-SMCplots.md","raw":"---\ntitle: Draw the evolution of SMC\ncategories: [Research, Data visualization, R]\ntags: [R,ggplot, SMC, Data visualization]\ndate: 2018-11-30\n\n---\n\nFinally, I have done visualizing the evolution of SMC in R instead of in Python. Here, two illustrations are given. \n\n<!--more-->\n\n## Generating Data\nThe data I used in the examples is generated under SMC applying on our trait-population coevolution model, a likelihood-free method for searching the true parameters when an analytic formulation of the model is not achievable. The data is consisting of 30 iterations samples. Each iteration contains 10K sampling. The algorithm starts by sampling from a uniform distribution in range (0,1). After each iteration, it computes the fitness of the samples and highly weights the samples with high fitness. Finally, it converges to the true value.  \n\n## Mountain plot\nMountain plot is recently highly evaluated theme for comparing the distribution of data across groups. The idea is stem from [Henrik's plot](https://twitter.com/hnrklndbrg/status/883675698300420098)\n\n![plot 1](2018-11-30-SMCplots/Rplot1.png)\n\nForget to point out the true value is at 1.0, which is the peak of the distribution at 30th iteration. \n\n## Heatmap plot\nAnother nice presentation is realized by the heat map. The data was manipulated a bit. The density of the samples was converted to the frequency in tiny cells. Then it can be applied by the heat map plot.\n\n![plot 1](2018-11-30-SMCplots/Rplot2.png)\n\nWhich one do you prefer?\n","slug":"2018-11-30-SMCplots","published":1,"updated":"2022-09-17T02:04:05.118Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl85g865t000m4gkr67h2adtj","content":"<p>Finally, I have done visualizing the evolution of SMC in R instead of in Python. Here, two illustrations are given. </p>\n<span id=\"more\"></span>\n\n<h2 id=\"Generating-Data\"><a href=\"#Generating-Data\" class=\"headerlink\" title=\"Generating Data\"></a>Generating Data</h2><p>The data I used in the examples is generated under SMC applying on our trait-population coevolution model, a likelihood-free method for searching the true parameters when an analytic formulation of the model is not achievable. The data is consisting of 30 iterations samples. Each iteration contains 10K sampling. The algorithm starts by sampling from a uniform distribution in range (0,1). After each iteration, it computes the fitness of the samples and highly weights the samples with high fitness. Finally, it converges to the true value.  </p>\n<h2 id=\"Mountain-plot\"><a href=\"#Mountain-plot\" class=\"headerlink\" title=\"Mountain plot\"></a>Mountain plot</h2><p>Mountain plot is recently highly evaluated theme for comparing the distribution of data across groups. The idea is stem from <a href=\"https://twitter.com/hnrklndbrg/status/883675698300420098\">Henrik’s plot</a></p>\n<p><img src=\"/2018-11-30-SMCplots/Rplot1.png\" alt=\"plot 1\"></p>\n<p>Forget to point out the true value is at 1.0, which is the peak of the distribution at 30th iteration. </p>\n<h2 id=\"Heatmap-plot\"><a href=\"#Heatmap-plot\" class=\"headerlink\" title=\"Heatmap plot\"></a>Heatmap plot</h2><p>Another nice presentation is realized by the heat map. The data was manipulated a bit. The density of the samples was converted to the frequency in tiny cells. Then it can be applied by the heat map plot.</p>\n<p><img src=\"/2018-11-30-SMCplots/Rplot2.png\" alt=\"plot 1\"></p>\n<p>Which one do you prefer?</p>\n","site":{"data":{}},"excerpt":"<p>Finally, I have done visualizing the evolution of SMC in R instead of in Python. Here, two illustrations are given. </p>","more":"<h2 id=\"Generating-Data\"><a href=\"#Generating-Data\" class=\"headerlink\" title=\"Generating Data\"></a>Generating Data</h2><p>The data I used in the examples is generated under SMC applying on our trait-population coevolution model, a likelihood-free method for searching the true parameters when an analytic formulation of the model is not achievable. The data is consisting of 30 iterations samples. Each iteration contains 10K sampling. The algorithm starts by sampling from a uniform distribution in range (0,1). After each iteration, it computes the fitness of the samples and highly weights the samples with high fitness. Finally, it converges to the true value.  </p>\n<h2 id=\"Mountain-plot\"><a href=\"#Mountain-plot\" class=\"headerlink\" title=\"Mountain plot\"></a>Mountain plot</h2><p>Mountain plot is recently highly evaluated theme for comparing the distribution of data across groups. The idea is stem from <a href=\"https://twitter.com/hnrklndbrg/status/883675698300420098\">Henrik’s plot</a></p>\n<p><img src=\"/2018-11-30-SMCplots/Rplot1.png\" alt=\"plot 1\"></p>\n<p>Forget to point out the true value is at 1.0, which is the peak of the distribution at 30th iteration. </p>\n<h2 id=\"Heatmap-plot\"><a href=\"#Heatmap-plot\" class=\"headerlink\" title=\"Heatmap plot\"></a>Heatmap plot</h2><p>Another nice presentation is realized by the heat map. The data was manipulated a bit. The density of the samples was converted to the frequency in tiny cells. Then it can be applied by the heat map plot.</p>\n<p><img src=\"/2018-11-30-SMCplots/Rplot2.png\" alt=\"plot 1\"></p>\n<p>Which one do you prefer?</p>"},{"title":"PyCUDA series 1: Build GPU programming environment ","date":"2019-01-04T08:00:00.000Z","_content":"\nAs my research always involves a huge amount of computation, parallel technique is a super fancy way to save my time. But the resource of cluster at my university is limited. I recently received a warning that CIT has detected multiple-account usage under my IP. To avoid the risk of being fired, I have to figure out another way to parallelize my job instead of parallelizing accounts. Right on time, GPU programming came out as an ideal option. I hope the GPU resource of my university is not full loaded yet.\n\nDue to some incompatibilities of CUDA and Visual Studio 2017, I spent half a day to figure out the solutions and finally succeeded building up GPU programming environment on Windows 10 with Pycuda installed in Python. Here, I post the procedure of the build and some solutions to the incompatibilities.\n\n<!--more-->\n \n# Prerequisite \n\nFor now, I am working on **Windows 10** with **Python 3.7.0**. The CUDA version that is compatibly built up for me is **CUDA 10.0**. I used **Pycharm 2018.3** as the Python IDE. Probably I will try to build on OS 10 soon in the future.\n\n# Simple procedure \n\n1.  Install [Python 3.7](https://www.python.org/downloads/) and [PyCharm 2018.3](https://www.jetbrains.com/pycharm/download/).\n\n2.  Install [Visual Studio 2017](https://visualstudio.microsoft.com/zh-hans/downloads/) as CUDA needs C++ compile. \n\n3.  Open the Visual Studio installer under the folder Visual Studio 2017. \n \n![default](2019-01-04-PyCUDAseries1/vsinstaller.png)\n\n4. Select: **Modify** under Visual Studio 2017 -> **Installation details**.\n\n5. Install options: select only the **Windows 10 SDK**.\n\n![default](2019-01-04-PyCUDAseries1/win10SDK.png)\n\n6.  Install [CUDA 10.0](https://developer.nvidia.com/cuda-downloads?target_os=Windows&target_arch=x86_64&target_version=10&target_type=exelocal) and follow the steps [here](https://docs.nvidia.com/cuda/cuda-quick-start-guide/index.html#windows) to set up CUDA environment.\n\n\n# Tips\n\n- To make sure that CUDA is successfully installed, check `nvcc -v` at your terminal. \n- The step to build samples in Nvidia's guide is not necessary. I couldn't build the samples due to some incompatibilities of vs c++ but still have it work on Python.\n\n\n\n# Problem shooting\n\n- **CUDA install failed**\n\nI only came across this issue on my desktop at office that has an old monitor. Then, I resolved it by customizing the installation with uncheck of Visual Studio integration. No idea why but it works. Also check answer [here](https://www.reddit.com/r/nvidia/comments/9d2f23/cuda_install_problems_windows_10_geforce_1070ti/)\n\n\n- **nvcc fatal : Cannot find compiler 'cl.exe' in PATH **\n\nCheck [here](https://stackoverflow.com/questions/8125826/error-compiling-cuda-from-command-prompt). In principle, you should add `cl.exe` to the environment variables.\n","source":"_posts/2019-01-04-PyCUDAseries1.md","raw":"---\ntitle: \"PyCUDA series 1: Build GPU programming environment \"\ncategories: [Research,GPU programming,pyCUDA]\ntags: [Python, CUDA, GPU programming, Parallel computation]\ndate: 2019-01-04\n\n---\n\nAs my research always involves a huge amount of computation, parallel technique is a super fancy way to save my time. But the resource of cluster at my university is limited. I recently received a warning that CIT has detected multiple-account usage under my IP. To avoid the risk of being fired, I have to figure out another way to parallelize my job instead of parallelizing accounts. Right on time, GPU programming came out as an ideal option. I hope the GPU resource of my university is not full loaded yet.\n\nDue to some incompatibilities of CUDA and Visual Studio 2017, I spent half a day to figure out the solutions and finally succeeded building up GPU programming environment on Windows 10 with Pycuda installed in Python. Here, I post the procedure of the build and some solutions to the incompatibilities.\n\n<!--more-->\n \n# Prerequisite \n\nFor now, I am working on **Windows 10** with **Python 3.7.0**. The CUDA version that is compatibly built up for me is **CUDA 10.0**. I used **Pycharm 2018.3** as the Python IDE. Probably I will try to build on OS 10 soon in the future.\n\n# Simple procedure \n\n1.  Install [Python 3.7](https://www.python.org/downloads/) and [PyCharm 2018.3](https://www.jetbrains.com/pycharm/download/).\n\n2.  Install [Visual Studio 2017](https://visualstudio.microsoft.com/zh-hans/downloads/) as CUDA needs C++ compile. \n\n3.  Open the Visual Studio installer under the folder Visual Studio 2017. \n \n![default](2019-01-04-PyCUDAseries1/vsinstaller.png)\n\n4. Select: **Modify** under Visual Studio 2017 -> **Installation details**.\n\n5. Install options: select only the **Windows 10 SDK**.\n\n![default](2019-01-04-PyCUDAseries1/win10SDK.png)\n\n6.  Install [CUDA 10.0](https://developer.nvidia.com/cuda-downloads?target_os=Windows&target_arch=x86_64&target_version=10&target_type=exelocal) and follow the steps [here](https://docs.nvidia.com/cuda/cuda-quick-start-guide/index.html#windows) to set up CUDA environment.\n\n\n# Tips\n\n- To make sure that CUDA is successfully installed, check `nvcc -v` at your terminal. \n- The step to build samples in Nvidia's guide is not necessary. I couldn't build the samples due to some incompatibilities of vs c++ but still have it work on Python.\n\n\n\n# Problem shooting\n\n- **CUDA install failed**\n\nI only came across this issue on my desktop at office that has an old monitor. Then, I resolved it by customizing the installation with uncheck of Visual Studio integration. No idea why but it works. Also check answer [here](https://www.reddit.com/r/nvidia/comments/9d2f23/cuda_install_problems_windows_10_geforce_1070ti/)\n\n\n- **nvcc fatal : Cannot find compiler 'cl.exe' in PATH **\n\nCheck [here](https://stackoverflow.com/questions/8125826/error-compiling-cuda-from-command-prompt). In principle, you should add `cl.exe` to the environment variables.\n","slug":"2019-01-04-PyCUDAseries1","published":1,"updated":"2022-09-17T02:04:05.121Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl85g865u000p4gkr8c40fsbw","content":"<p>As my research always involves a huge amount of computation, parallel technique is a super fancy way to save my time. But the resource of cluster at my university is limited. I recently received a warning that CIT has detected multiple-account usage under my IP. To avoid the risk of being fired, I have to figure out another way to parallelize my job instead of parallelizing accounts. Right on time, GPU programming came out as an ideal option. I hope the GPU resource of my university is not full loaded yet.</p>\n<p>Due to some incompatibilities of CUDA and Visual Studio 2017, I spent half a day to figure out the solutions and finally succeeded building up GPU programming environment on Windows 10 with Pycuda installed in Python. Here, I post the procedure of the build and some solutions to the incompatibilities.</p>\n<span id=\"more\"></span>\n<h1 id=\"Prerequisite\"><a href=\"#Prerequisite\" class=\"headerlink\" title=\"Prerequisite\"></a>Prerequisite</h1><p>For now, I am working on <strong>Windows 10</strong> with <strong>Python 3.7.0</strong>. The CUDA version that is compatibly built up for me is <strong>CUDA 10.0</strong>. I used <strong>Pycharm 2018.3</strong> as the Python IDE. Probably I will try to build on OS 10 soon in the future.</p>\n<h1 id=\"Simple-procedure\"><a href=\"#Simple-procedure\" class=\"headerlink\" title=\"Simple procedure\"></a>Simple procedure</h1><ol>\n<li><p>Install <a href=\"https://www.python.org/downloads/\">Python 3.7</a> and <a href=\"https://www.jetbrains.com/pycharm/download/\">PyCharm 2018.3</a>.</p>\n</li>\n<li><p>Install <a href=\"https://visualstudio.microsoft.com/zh-hans/downloads/\">Visual Studio 2017</a> as CUDA needs C++ compile. </p>\n</li>\n<li><p>Open the Visual Studio installer under the folder Visual Studio 2017.</p>\n</li>\n</ol>\n<p><img src=\"/2019-01-04-PyCUDAseries1/vsinstaller.png\" alt=\"default\"></p>\n<ol start=\"4\">\n<li><p>Select: <strong>Modify</strong> under Visual Studio 2017 -&gt; <strong>Installation details</strong>.</p>\n</li>\n<li><p>Install options: select only the <strong>Windows 10 SDK</strong>.</p>\n</li>\n</ol>\n<p><img src=\"/2019-01-04-PyCUDAseries1/win10SDK.png\" alt=\"default\"></p>\n<ol start=\"6\">\n<li>Install <a href=\"https://developer.nvidia.com/cuda-downloads?target_os=Windows&target_arch=x86_64&target_version=10&target_type=exelocal\">CUDA 10.0</a> and follow the steps <a href=\"https://docs.nvidia.com/cuda/cuda-quick-start-guide/index.html#windows\">here</a> to set up CUDA environment.</li>\n</ol>\n<h1 id=\"Tips\"><a href=\"#Tips\" class=\"headerlink\" title=\"Tips\"></a>Tips</h1><ul>\n<li>To make sure that CUDA is successfully installed, check <code>nvcc -v</code> at your terminal. </li>\n<li>The step to build samples in Nvidia’s guide is not necessary. I couldn’t build the samples due to some incompatibilities of vs c++ but still have it work on Python.</li>\n</ul>\n<h1 id=\"Problem-shooting\"><a href=\"#Problem-shooting\" class=\"headerlink\" title=\"Problem shooting\"></a>Problem shooting</h1><ul>\n<li><strong>CUDA install failed</strong></li>\n</ul>\n<p>I only came across this issue on my desktop at office that has an old monitor. Then, I resolved it by customizing the installation with uncheck of Visual Studio integration. No idea why but it works. Also check answer <a href=\"https://www.reddit.com/r/nvidia/comments/9d2f23/cuda_install_problems_windows_10_geforce_1070ti/\">here</a></p>\n<ul>\n<li>**nvcc fatal : Cannot find compiler ‘cl.exe’ in PATH **</li>\n</ul>\n<p>Check <a href=\"https://stackoverflow.com/questions/8125826/error-compiling-cuda-from-command-prompt\">here</a>. In principle, you should add <code>cl.exe</code> to the environment variables.</p>\n","site":{"data":{}},"excerpt":"<p>As my research always involves a huge amount of computation, parallel technique is a super fancy way to save my time. But the resource of cluster at my university is limited. I recently received a warning that CIT has detected multiple-account usage under my IP. To avoid the risk of being fired, I have to figure out another way to parallelize my job instead of parallelizing accounts. Right on time, GPU programming came out as an ideal option. I hope the GPU resource of my university is not full loaded yet.</p>\n<p>Due to some incompatibilities of CUDA and Visual Studio 2017, I spent half a day to figure out the solutions and finally succeeded building up GPU programming environment on Windows 10 with Pycuda installed in Python. Here, I post the procedure of the build and some solutions to the incompatibilities.</p>","more":"<h1 id=\"Prerequisite\"><a href=\"#Prerequisite\" class=\"headerlink\" title=\"Prerequisite\"></a>Prerequisite</h1><p>For now, I am working on <strong>Windows 10</strong> with <strong>Python 3.7.0</strong>. The CUDA version that is compatibly built up for me is <strong>CUDA 10.0</strong>. I used <strong>Pycharm 2018.3</strong> as the Python IDE. Probably I will try to build on OS 10 soon in the future.</p>\n<h1 id=\"Simple-procedure\"><a href=\"#Simple-procedure\" class=\"headerlink\" title=\"Simple procedure\"></a>Simple procedure</h1><ol>\n<li><p>Install <a href=\"https://www.python.org/downloads/\">Python 3.7</a> and <a href=\"https://www.jetbrains.com/pycharm/download/\">PyCharm 2018.3</a>.</p>\n</li>\n<li><p>Install <a href=\"https://visualstudio.microsoft.com/zh-hans/downloads/\">Visual Studio 2017</a> as CUDA needs C++ compile. </p>\n</li>\n<li><p>Open the Visual Studio installer under the folder Visual Studio 2017.</p>\n</li>\n</ol>\n<p><img src=\"/2019-01-04-PyCUDAseries1/vsinstaller.png\" alt=\"default\"></p>\n<ol start=\"4\">\n<li><p>Select: <strong>Modify</strong> under Visual Studio 2017 -&gt; <strong>Installation details</strong>.</p>\n</li>\n<li><p>Install options: select only the <strong>Windows 10 SDK</strong>.</p>\n</li>\n</ol>\n<p><img src=\"/2019-01-04-PyCUDAseries1/win10SDK.png\" alt=\"default\"></p>\n<ol start=\"6\">\n<li>Install <a href=\"https://developer.nvidia.com/cuda-downloads?target_os=Windows&target_arch=x86_64&target_version=10&target_type=exelocal\">CUDA 10.0</a> and follow the steps <a href=\"https://docs.nvidia.com/cuda/cuda-quick-start-guide/index.html#windows\">here</a> to set up CUDA environment.</li>\n</ol>\n<h1 id=\"Tips\"><a href=\"#Tips\" class=\"headerlink\" title=\"Tips\"></a>Tips</h1><ul>\n<li>To make sure that CUDA is successfully installed, check <code>nvcc -v</code> at your terminal. </li>\n<li>The step to build samples in Nvidia’s guide is not necessary. I couldn’t build the samples due to some incompatibilities of vs c++ but still have it work on Python.</li>\n</ul>\n<h1 id=\"Problem-shooting\"><a href=\"#Problem-shooting\" class=\"headerlink\" title=\"Problem shooting\"></a>Problem shooting</h1><ul>\n<li><strong>CUDA install failed</strong></li>\n</ul>\n<p>I only came across this issue on my desktop at office that has an old monitor. Then, I resolved it by customizing the installation with uncheck of Visual Studio integration. No idea why but it works. Also check answer <a href=\"https://www.reddit.com/r/nvidia/comments/9d2f23/cuda_install_problems_windows_10_geforce_1070ti/\">here</a></p>\n<ul>\n<li>**nvcc fatal : Cannot find compiler ‘cl.exe’ in PATH **</li>\n</ul>\n<p>Check <a href=\"https://stackoverflow.com/questions/8125826/error-compiling-cuda-from-command-prompt\">here</a>. In principle, you should add <code>cl.exe</code> to the environment variables.</p>"},{"title":"ggradar2: Help document ","date":"2018-12-07T08:00:00.000Z","_content":"\nIn this blog, the details of the arguments used in [ggradar2](https://github.com/xl0418/ggradar2) are provided.\n\n<!--more-->\n\n## ggradar2: arguments\n\n\n**plot.data** :\nThe input data should be in the data.frame format with columns named. The values in the data are supposed to be numeric. If you want to apply scales like 'high', 'middle', 'low'. Please evaluate them first and put them as `gridline.label` . \n\nNotice that 'group' column is suggested to included in your data. `ggradar2` now can smartly detect if 'group' is correctly provided. If not, you will be asked if the first column is allowed to defined as the group column. \n\n```\nWARNING: 'group' column is not detected. The first column will be chosen as the group name. Yes/no? (y/n)\n```\n\nIf you want to plot multiple plots against some subgroups, please specify it in the column `data$facet1`.\n\n**base.size**: The size of radar chart. The default value is 20. \n\n**webtype**: `\"mini\"` set a web type with 3 grid lines while `\"lux\"` set a type with 5 grid lines. Default setting is `\"mini\"`.\n\n**axis.labels**:  The label of each column in your data is plotted around the radar. \n\n**axis.label.offset**: The offset of axis labels.\n\n**axis.label.size**: The size of axis labels.\n\n**axis.line.colour**: The color of axis labels.\n\n**grid.min, grid.max**: Rescale your values in this range.\n\n**centre.y**: The radius of inner circle. \n\n**label.centre.y**: `TRUE` prints the central value. `FALSE` turns it off.\n\n**grid.line.width**: The width of grid lines.\n\n**grid.line.trend**: `\"classic\"` sets equal width of the grid lines. `\"increase\"` sets an outward-increasing width of the grid lines. `\"decrease\"` sets an outward-decreasing width of the grid lines.\n\n**gridline.min.linetype, gridline.mid.linetype, gridline.max.linetype**: Set the grid line type for the inner, middle and outer circles. The default setting is `\"longdash\"`.\n\n**gridline.min.colour, gridline.mid.colour, gridline.max.colour**: Set the colors for the inner, middle and outer circles. The default settings are `\"grey\", \"#007A87\", \"grey\"`.\n\n**grid.label.size**: Set the size of grid labels.\n\n**gridline.label.offset**: The offset of grid labels.\n\n**gridline.label**: The default setting is the percentage. Replace it with your labels.\n\n**group.line.width**: The width of group lines.\n \n**group.point.size**: The size of the point in each axis for group lines.\n\n**group.colours**: Set colors for the group lines.\n\n**polygonfill**: Turn on/off the polygon fill.\n\n**polygonfill.transparency**: The transparency of polygon fills.\n\n**group.fill.colours**: The colors of polygon fills.\n\n**background.circle.colour**: The background color for the radar.\n\n**background.circle.transparency**: The transparency of the background.\n\n**radarshape**: `\"round\"` gives you a round radar. `\"sharp\"` gives you a sharp radar.\n\n**multiplots**: Turn on/off multi-plotting function. If on, `data$facet1` column should be included in your data. TRUE/FALSE\n\n**fullscore**: Set full scores to your values. \n\n**stripbackground**: Turn on/off the background for the panels of multiple plots.\n\nThe followings are basic settings.\n\n```R\nlegend.title=\"\",\nplot.legend=TRUE,\nplot.title=\"\",\nlegend.text.size=14,\n```","source":"_posts/2018-12-07-ggradar2helpdocument.md","raw":"---\ntitle: \"ggradar2: Help document \"\ncategories: [Research, Data visualization, R, ggradar2]\ntags: [R,ggplot, ggradar2, Data visualization,help document]\ndate: 2018-12-07\n\n---\n\nIn this blog, the details of the arguments used in [ggradar2](https://github.com/xl0418/ggradar2) are provided.\n\n<!--more-->\n\n## ggradar2: arguments\n\n\n**plot.data** :\nThe input data should be in the data.frame format with columns named. The values in the data are supposed to be numeric. If you want to apply scales like 'high', 'middle', 'low'. Please evaluate them first and put them as `gridline.label` . \n\nNotice that 'group' column is suggested to included in your data. `ggradar2` now can smartly detect if 'group' is correctly provided. If not, you will be asked if the first column is allowed to defined as the group column. \n\n```\nWARNING: 'group' column is not detected. The first column will be chosen as the group name. Yes/no? (y/n)\n```\n\nIf you want to plot multiple plots against some subgroups, please specify it in the column `data$facet1`.\n\n**base.size**: The size of radar chart. The default value is 20. \n\n**webtype**: `\"mini\"` set a web type with 3 grid lines while `\"lux\"` set a type with 5 grid lines. Default setting is `\"mini\"`.\n\n**axis.labels**:  The label of each column in your data is plotted around the radar. \n\n**axis.label.offset**: The offset of axis labels.\n\n**axis.label.size**: The size of axis labels.\n\n**axis.line.colour**: The color of axis labels.\n\n**grid.min, grid.max**: Rescale your values in this range.\n\n**centre.y**: The radius of inner circle. \n\n**label.centre.y**: `TRUE` prints the central value. `FALSE` turns it off.\n\n**grid.line.width**: The width of grid lines.\n\n**grid.line.trend**: `\"classic\"` sets equal width of the grid lines. `\"increase\"` sets an outward-increasing width of the grid lines. `\"decrease\"` sets an outward-decreasing width of the grid lines.\n\n**gridline.min.linetype, gridline.mid.linetype, gridline.max.linetype**: Set the grid line type for the inner, middle and outer circles. The default setting is `\"longdash\"`.\n\n**gridline.min.colour, gridline.mid.colour, gridline.max.colour**: Set the colors for the inner, middle and outer circles. The default settings are `\"grey\", \"#007A87\", \"grey\"`.\n\n**grid.label.size**: Set the size of grid labels.\n\n**gridline.label.offset**: The offset of grid labels.\n\n**gridline.label**: The default setting is the percentage. Replace it with your labels.\n\n**group.line.width**: The width of group lines.\n \n**group.point.size**: The size of the point in each axis for group lines.\n\n**group.colours**: Set colors for the group lines.\n\n**polygonfill**: Turn on/off the polygon fill.\n\n**polygonfill.transparency**: The transparency of polygon fills.\n\n**group.fill.colours**: The colors of polygon fills.\n\n**background.circle.colour**: The background color for the radar.\n\n**background.circle.transparency**: The transparency of the background.\n\n**radarshape**: `\"round\"` gives you a round radar. `\"sharp\"` gives you a sharp radar.\n\n**multiplots**: Turn on/off multi-plotting function. If on, `data$facet1` column should be included in your data. TRUE/FALSE\n\n**fullscore**: Set full scores to your values. \n\n**stripbackground**: Turn on/off the background for the panels of multiple plots.\n\nThe followings are basic settings.\n\n```R\nlegend.title=\"\",\nplot.legend=TRUE,\nplot.title=\"\",\nlegend.text.size=14,\n```","slug":"2018-12-07-ggradar2helpdocument","published":1,"updated":"2022-09-17T02:04:05.121Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl85g865u000r4gkrgpq9aw2f","content":"<p>In this blog, the details of the arguments used in <a href=\"https://github.com/xl0418/ggradar2\">ggradar2</a> are provided.</p>\n<span id=\"more\"></span>\n\n<h2 id=\"ggradar2-arguments\"><a href=\"#ggradar2-arguments\" class=\"headerlink\" title=\"ggradar2: arguments\"></a>ggradar2: arguments</h2><p><strong>plot.data</strong> :<br>The input data should be in the data.frame format with columns named. The values in the data are supposed to be numeric. If you want to apply scales like ‘high’, ‘middle’, ‘low’. Please evaluate them first and put them as <code>gridline.label</code> . </p>\n<p>Notice that ‘group’ column is suggested to included in your data. <code>ggradar2</code> now can smartly detect if ‘group’ is correctly provided. If not, you will be asked if the first column is allowed to defined as the group column. </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WARNING: &#x27;group&#x27; column is not detected. The first column will be chosen as the group name. Yes/no? (y/n)</span><br></pre></td></tr></table></figure>\n\n<p>If you want to plot multiple plots against some subgroups, please specify it in the column <code>data$facet1</code>.</p>\n<p><strong>base.size</strong>: The size of radar chart. The default value is 20. </p>\n<p><strong>webtype</strong>: <code>&quot;mini&quot;</code> set a web type with 3 grid lines while <code>&quot;lux&quot;</code> set a type with 5 grid lines. Default setting is <code>&quot;mini&quot;</code>.</p>\n<p><strong>axis.labels</strong>:  The label of each column in your data is plotted around the radar. </p>\n<p><strong>axis.label.offset</strong>: The offset of axis labels.</p>\n<p><strong>axis.label.size</strong>: The size of axis labels.</p>\n<p><strong>axis.line.colour</strong>: The color of axis labels.</p>\n<p><strong>grid.min, grid.max</strong>: Rescale your values in this range.</p>\n<p><strong>centre.y</strong>: The radius of inner circle. </p>\n<p><strong>label.centre.y</strong>: <code>TRUE</code> prints the central value. <code>FALSE</code> turns it off.</p>\n<p><strong>grid.line.width</strong>: The width of grid lines.</p>\n<p><strong>grid.line.trend</strong>: <code>&quot;classic&quot;</code> sets equal width of the grid lines. <code>&quot;increase&quot;</code> sets an outward-increasing width of the grid lines. <code>&quot;decrease&quot;</code> sets an outward-decreasing width of the grid lines.</p>\n<p><strong>gridline.min.linetype, gridline.mid.linetype, gridline.max.linetype</strong>: Set the grid line type for the inner, middle and outer circles. The default setting is <code>&quot;longdash&quot;</code>.</p>\n<p><strong>gridline.min.colour, gridline.mid.colour, gridline.max.colour</strong>: Set the colors for the inner, middle and outer circles. The default settings are <code>&quot;grey&quot;, &quot;#007A87&quot;, &quot;grey&quot;</code>.</p>\n<p><strong>grid.label.size</strong>: Set the size of grid labels.</p>\n<p><strong>gridline.label.offset</strong>: The offset of grid labels.</p>\n<p><strong>gridline.label</strong>: The default setting is the percentage. Replace it with your labels.</p>\n<p><strong>group.line.width</strong>: The width of group lines.</p>\n<p><strong>group.point.size</strong>: The size of the point in each axis for group lines.</p>\n<p><strong>group.colours</strong>: Set colors for the group lines.</p>\n<p><strong>polygonfill</strong>: Turn on&#x2F;off the polygon fill.</p>\n<p><strong>polygonfill.transparency</strong>: The transparency of polygon fills.</p>\n<p><strong>group.fill.colours</strong>: The colors of polygon fills.</p>\n<p><strong>background.circle.colour</strong>: The background color for the radar.</p>\n<p><strong>background.circle.transparency</strong>: The transparency of the background.</p>\n<p><strong>radarshape</strong>: <code>&quot;round&quot;</code> gives you a round radar. <code>&quot;sharp&quot;</code> gives you a sharp radar.</p>\n<p><strong>multiplots</strong>: Turn on&#x2F;off multi-plotting function. If on, <code>data$facet1</code> column should be included in your data. TRUE&#x2F;FALSE</p>\n<p><strong>fullscore</strong>: Set full scores to your values. </p>\n<p><strong>stripbackground</strong>: Turn on&#x2F;off the background for the panels of multiple plots.</p>\n<p>The followings are basic settings.</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">legend.title<span class=\"operator\">=</span><span class=\"string\">&quot;&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">plot.legend<span class=\"operator\">=</span><span class=\"literal\">TRUE</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">plot.title<span class=\"operator\">=</span><span class=\"string\">&quot;&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">legend.text.size<span class=\"operator\">=</span><span class=\"number\">14</span><span class=\"punctuation\">,</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>In this blog, the details of the arguments used in <a href=\"https://github.com/xl0418/ggradar2\">ggradar2</a> are provided.</p>","more":"<h2 id=\"ggradar2-arguments\"><a href=\"#ggradar2-arguments\" class=\"headerlink\" title=\"ggradar2: arguments\"></a>ggradar2: arguments</h2><p><strong>plot.data</strong> :<br>The input data should be in the data.frame format with columns named. The values in the data are supposed to be numeric. If you want to apply scales like ‘high’, ‘middle’, ‘low’. Please evaluate them first and put them as <code>gridline.label</code> . </p>\n<p>Notice that ‘group’ column is suggested to included in your data. <code>ggradar2</code> now can smartly detect if ‘group’ is correctly provided. If not, you will be asked if the first column is allowed to defined as the group column. </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WARNING: &#x27;group&#x27; column is not detected. The first column will be chosen as the group name. Yes/no? (y/n)</span><br></pre></td></tr></table></figure>\n\n<p>If you want to plot multiple plots against some subgroups, please specify it in the column <code>data$facet1</code>.</p>\n<p><strong>base.size</strong>: The size of radar chart. The default value is 20. </p>\n<p><strong>webtype</strong>: <code>&quot;mini&quot;</code> set a web type with 3 grid lines while <code>&quot;lux&quot;</code> set a type with 5 grid lines. Default setting is <code>&quot;mini&quot;</code>.</p>\n<p><strong>axis.labels</strong>:  The label of each column in your data is plotted around the radar. </p>\n<p><strong>axis.label.offset</strong>: The offset of axis labels.</p>\n<p><strong>axis.label.size</strong>: The size of axis labels.</p>\n<p><strong>axis.line.colour</strong>: The color of axis labels.</p>\n<p><strong>grid.min, grid.max</strong>: Rescale your values in this range.</p>\n<p><strong>centre.y</strong>: The radius of inner circle. </p>\n<p><strong>label.centre.y</strong>: <code>TRUE</code> prints the central value. <code>FALSE</code> turns it off.</p>\n<p><strong>grid.line.width</strong>: The width of grid lines.</p>\n<p><strong>grid.line.trend</strong>: <code>&quot;classic&quot;</code> sets equal width of the grid lines. <code>&quot;increase&quot;</code> sets an outward-increasing width of the grid lines. <code>&quot;decrease&quot;</code> sets an outward-decreasing width of the grid lines.</p>\n<p><strong>gridline.min.linetype, gridline.mid.linetype, gridline.max.linetype</strong>: Set the grid line type for the inner, middle and outer circles. The default setting is <code>&quot;longdash&quot;</code>.</p>\n<p><strong>gridline.min.colour, gridline.mid.colour, gridline.max.colour</strong>: Set the colors for the inner, middle and outer circles. The default settings are <code>&quot;grey&quot;, &quot;#007A87&quot;, &quot;grey&quot;</code>.</p>\n<p><strong>grid.label.size</strong>: Set the size of grid labels.</p>\n<p><strong>gridline.label.offset</strong>: The offset of grid labels.</p>\n<p><strong>gridline.label</strong>: The default setting is the percentage. Replace it with your labels.</p>\n<p><strong>group.line.width</strong>: The width of group lines.</p>\n<p><strong>group.point.size</strong>: The size of the point in each axis for group lines.</p>\n<p><strong>group.colours</strong>: Set colors for the group lines.</p>\n<p><strong>polygonfill</strong>: Turn on&#x2F;off the polygon fill.</p>\n<p><strong>polygonfill.transparency</strong>: The transparency of polygon fills.</p>\n<p><strong>group.fill.colours</strong>: The colors of polygon fills.</p>\n<p><strong>background.circle.colour</strong>: The background color for the radar.</p>\n<p><strong>background.circle.transparency</strong>: The transparency of the background.</p>\n<p><strong>radarshape</strong>: <code>&quot;round&quot;</code> gives you a round radar. <code>&quot;sharp&quot;</code> gives you a sharp radar.</p>\n<p><strong>multiplots</strong>: Turn on&#x2F;off multi-plotting function. If on, <code>data$facet1</code> column should be included in your data. TRUE&#x2F;FALSE</p>\n<p><strong>fullscore</strong>: Set full scores to your values. </p>\n<p><strong>stripbackground</strong>: Turn on&#x2F;off the background for the panels of multiple plots.</p>\n<p>The followings are basic settings.</p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">legend.title<span class=\"operator\">=</span><span class=\"string\">&quot;&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">plot.legend<span class=\"operator\">=</span><span class=\"literal\">TRUE</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">plot.title<span class=\"operator\">=</span><span class=\"string\">&quot;&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">legend.text.size<span class=\"operator\">=</span><span class=\"number\">14</span><span class=\"punctuation\">,</span></span><br></pre></td></tr></table></figure>"},{"title":"Sed again: run on Ubuntu to avoid weird behavior","date":"2019-01-10T08:00:00.000Z","_content":"\nAs my 2nd project is close to an end, it is right the time to go back to the phylogenetic Janzen-Connell model. Simulations and plotting functions have been done during the gap time squeezed from the 2nd project. The last thing is to analyze the data, in which I bumped into a weird behavior of `sed`. \n\n<!--more-->\n\n## The data file\nIn this project, I have generated in total 108 data file in `.m` (Matlab) format. Each file contain several distance matrix, abundance vectors, an event table and turnover ticks that I want to extract and analyze exclusively. \n\n![Raw data files.](2019-01-10sed2/mfiles.png)\n\n## Extract the matrix\nThe procedure is simple. I modified the previous experimental bash scripts a bit to fit the file names of data. Then execute them sequentially on Windows prompt.\n\n1. Run `extractallDs.sh` and `extractallRs.sh` to extract all D matrix and R matrix from the raw files into `LRsij.Rdata,MRsij.Rdata,HRsij.Rdata,LDsij.Rdata,MDsij.Rdata,HDsij.Rdata`.\n2. Run `Dlast.sh` to extract the last D and R matrix into `LDij.Rdata,LRij.Rdata,MDij.Rdata,MRij.Rdata,HDij.Rdata,HRij.Rdata`.\n3. Do the same thing to extract event table and turnover ticks by running `loopextractEve_Turn.sh`\n\nlike \n\n![Raw data files.](2019-01-10sed2/rdatafiles.png)\n\nBut I obtained nothing in the files. \n\n## Bug shooting\nSame simulation code generates the same data structure. But why couldn't the same bash script extract information as before? At that moment, I kind of had a feeling that it must be that the script cannot recognize the newline sign. like the following, if the computer cannot match `\\r`, which is the code for the newline under windows and DOS, the script extracts nothing. \n \n```bash\n#!/bin/bash\nfor j in {0..4};\ndo\nfor i in {0..4};\ndo \nsed -n '/D'{'length(D)+1'}' = \\[\\r/,/\\];/p' test\"$j$i\".m > Ds\"$j$i\".Rdata\necho $j$i' done'\ndone\ndone\n```\n\nBut after I changed it to `\\n` that is the right code for a linux file, it didn't work neither. Even after changing the file code via `unix2dos`, none of the means worked.\n\n\\\\(\\boldsymbol{Finally}\\\\), after several hours of googling, thinking, patting the computer, I tried out the solution. The scripts need to be executed under the linux system. I launched them on Ubuntu again, the newline sign was recognized. \n\nBut it is still a mystery to me that why on a windows prompt none of `\\r` and `\\n` can be recognized. If you know it, pls reply this post. Thanks!","source":"_posts/2019-01-10sed2.md","raw":"---\ntitle: \"Sed again: run on Ubuntu to avoid weird behavior\"\ncategories: [Research, Bash, sed]\ntags: [project 3, bash, mega data, extract information]\ndate: 2019-01-10\n\n---\n\nAs my 2nd project is close to an end, it is right the time to go back to the phylogenetic Janzen-Connell model. Simulations and plotting functions have been done during the gap time squeezed from the 2nd project. The last thing is to analyze the data, in which I bumped into a weird behavior of `sed`. \n\n<!--more-->\n\n## The data file\nIn this project, I have generated in total 108 data file in `.m` (Matlab) format. Each file contain several distance matrix, abundance vectors, an event table and turnover ticks that I want to extract and analyze exclusively. \n\n![Raw data files.](2019-01-10sed2/mfiles.png)\n\n## Extract the matrix\nThe procedure is simple. I modified the previous experimental bash scripts a bit to fit the file names of data. Then execute them sequentially on Windows prompt.\n\n1. Run `extractallDs.sh` and `extractallRs.sh` to extract all D matrix and R matrix from the raw files into `LRsij.Rdata,MRsij.Rdata,HRsij.Rdata,LDsij.Rdata,MDsij.Rdata,HDsij.Rdata`.\n2. Run `Dlast.sh` to extract the last D and R matrix into `LDij.Rdata,LRij.Rdata,MDij.Rdata,MRij.Rdata,HDij.Rdata,HRij.Rdata`.\n3. Do the same thing to extract event table and turnover ticks by running `loopextractEve_Turn.sh`\n\nlike \n\n![Raw data files.](2019-01-10sed2/rdatafiles.png)\n\nBut I obtained nothing in the files. \n\n## Bug shooting\nSame simulation code generates the same data structure. But why couldn't the same bash script extract information as before? At that moment, I kind of had a feeling that it must be that the script cannot recognize the newline sign. like the following, if the computer cannot match `\\r`, which is the code for the newline under windows and DOS, the script extracts nothing. \n \n```bash\n#!/bin/bash\nfor j in {0..4};\ndo\nfor i in {0..4};\ndo \nsed -n '/D'{'length(D)+1'}' = \\[\\r/,/\\];/p' test\"$j$i\".m > Ds\"$j$i\".Rdata\necho $j$i' done'\ndone\ndone\n```\n\nBut after I changed it to `\\n` that is the right code for a linux file, it didn't work neither. Even after changing the file code via `unix2dos`, none of the means worked.\n\n\\\\(\\boldsymbol{Finally}\\\\), after several hours of googling, thinking, patting the computer, I tried out the solution. The scripts need to be executed under the linux system. I launched them on Ubuntu again, the newline sign was recognized. \n\nBut it is still a mystery to me that why on a windows prompt none of `\\r` and `\\n` can be recognized. If you know it, pls reply this post. Thanks!","slug":"2019-01-10sed2","published":1,"updated":"2022-09-17T02:04:05.123Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl85g865v000u4gkr9vgahe9i","content":"<p>As my 2nd project is close to an end, it is right the time to go back to the phylogenetic Janzen-Connell model. Simulations and plotting functions have been done during the gap time squeezed from the 2nd project. The last thing is to analyze the data, in which I bumped into a weird behavior of <code>sed</code>. </p>\n<span id=\"more\"></span>\n\n<h2 id=\"The-data-file\"><a href=\"#The-data-file\" class=\"headerlink\" title=\"The data file\"></a>The data file</h2><p>In this project, I have generated in total 108 data file in <code>.m</code> (Matlab) format. Each file contain several distance matrix, abundance vectors, an event table and turnover ticks that I want to extract and analyze exclusively. </p>\n<p><img src=\"/2019-01-10sed2/mfiles.png\" alt=\"Raw data files.\"></p>\n<h2 id=\"Extract-the-matrix\"><a href=\"#Extract-the-matrix\" class=\"headerlink\" title=\"Extract the matrix\"></a>Extract the matrix</h2><p>The procedure is simple. I modified the previous experimental bash scripts a bit to fit the file names of data. Then execute them sequentially on Windows prompt.</p>\n<ol>\n<li>Run <code>extractallDs.sh</code> and <code>extractallRs.sh</code> to extract all D matrix and R matrix from the raw files into <code>LRsij.Rdata,MRsij.Rdata,HRsij.Rdata,LDsij.Rdata,MDsij.Rdata,HDsij.Rdata</code>.</li>\n<li>Run <code>Dlast.sh</code> to extract the last D and R matrix into <code>LDij.Rdata,LRij.Rdata,MDij.Rdata,MRij.Rdata,HDij.Rdata,HRij.Rdata</code>.</li>\n<li>Do the same thing to extract event table and turnover ticks by running <code>loopextractEve_Turn.sh</code></li>\n</ol>\n<p>like </p>\n<p><img src=\"/2019-01-10sed2/rdatafiles.png\" alt=\"Raw data files.\"></p>\n<p>But I obtained nothing in the files. </p>\n<h2 id=\"Bug-shooting\"><a href=\"#Bug-shooting\" class=\"headerlink\" title=\"Bug shooting\"></a>Bug shooting</h2><p>Same simulation code generates the same data structure. But why couldn’t the same bash script extract information as before? At that moment, I kind of had a feeling that it must be that the script cannot recognize the newline sign. like the following, if the computer cannot match <code>\\r</code>, which is the code for the newline under windows and DOS, the script extracts nothing. </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> &#123;0..4&#125;;</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> &#123;0..4&#125;;</span><br><span class=\"line\"><span class=\"keyword\">do</span> </span><br><span class=\"line\">sed -n <span class=\"string\">&#x27;/D&#x27;</span>&#123;<span class=\"string\">&#x27;length(D)+1&#x27;</span>&#125;<span class=\"string\">&#x27; = \\[\\r/,/\\];/p&#x27;</span> <span class=\"built_in\">test</span><span class=\"string\">&quot;$j<span class=\"variable\">$i</span>&quot;</span>.m &gt; Ds<span class=\"string\">&quot;$j<span class=\"variable\">$i</span>&quot;</span>.Rdata</span><br><span class=\"line\"><span class=\"built_in\">echo</span> $j<span class=\"variable\">$i</span><span class=\"string\">&#x27; done&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<p>But after I changed it to <code>\\n</code> that is the right code for a linux file, it didn’t work neither. Even after changing the file code via <code>unix2dos</code>, none of the means worked.</p>\n<p>\\(\\boldsymbol{Finally}\\), after several hours of googling, thinking, patting the computer, I tried out the solution. The scripts need to be executed under the linux system. I launched them on Ubuntu again, the newline sign was recognized. </p>\n<p>But it is still a mystery to me that why on a windows prompt none of <code>\\r</code> and <code>\\n</code> can be recognized. If you know it, pls reply this post. Thanks!</p>\n","site":{"data":{}},"excerpt":"<p>As my 2nd project is close to an end, it is right the time to go back to the phylogenetic Janzen-Connell model. Simulations and plotting functions have been done during the gap time squeezed from the 2nd project. The last thing is to analyze the data, in which I bumped into a weird behavior of <code>sed</code>. </p>","more":"<h2 id=\"The-data-file\"><a href=\"#The-data-file\" class=\"headerlink\" title=\"The data file\"></a>The data file</h2><p>In this project, I have generated in total 108 data file in <code>.m</code> (Matlab) format. Each file contain several distance matrix, abundance vectors, an event table and turnover ticks that I want to extract and analyze exclusively. </p>\n<p><img src=\"/2019-01-10sed2/mfiles.png\" alt=\"Raw data files.\"></p>\n<h2 id=\"Extract-the-matrix\"><a href=\"#Extract-the-matrix\" class=\"headerlink\" title=\"Extract the matrix\"></a>Extract the matrix</h2><p>The procedure is simple. I modified the previous experimental bash scripts a bit to fit the file names of data. Then execute them sequentially on Windows prompt.</p>\n<ol>\n<li>Run <code>extractallDs.sh</code> and <code>extractallRs.sh</code> to extract all D matrix and R matrix from the raw files into <code>LRsij.Rdata,MRsij.Rdata,HRsij.Rdata,LDsij.Rdata,MDsij.Rdata,HDsij.Rdata</code>.</li>\n<li>Run <code>Dlast.sh</code> to extract the last D and R matrix into <code>LDij.Rdata,LRij.Rdata,MDij.Rdata,MRij.Rdata,HDij.Rdata,HRij.Rdata</code>.</li>\n<li>Do the same thing to extract event table and turnover ticks by running <code>loopextractEve_Turn.sh</code></li>\n</ol>\n<p>like </p>\n<p><img src=\"/2019-01-10sed2/rdatafiles.png\" alt=\"Raw data files.\"></p>\n<p>But I obtained nothing in the files. </p>\n<h2 id=\"Bug-shooting\"><a href=\"#Bug-shooting\" class=\"headerlink\" title=\"Bug shooting\"></a>Bug shooting</h2><p>Same simulation code generates the same data structure. But why couldn’t the same bash script extract information as before? At that moment, I kind of had a feeling that it must be that the script cannot recognize the newline sign. like the following, if the computer cannot match <code>\\r</code>, which is the code for the newline under windows and DOS, the script extracts nothing. </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> &#123;0..4&#125;;</span><br><span class=\"line\"><span class=\"keyword\">do</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> &#123;0..4&#125;;</span><br><span class=\"line\"><span class=\"keyword\">do</span> </span><br><span class=\"line\">sed -n <span class=\"string\">&#x27;/D&#x27;</span>&#123;<span class=\"string\">&#x27;length(D)+1&#x27;</span>&#125;<span class=\"string\">&#x27; = \\[\\r/,/\\];/p&#x27;</span> <span class=\"built_in\">test</span><span class=\"string\">&quot;$j<span class=\"variable\">$i</span>&quot;</span>.m &gt; Ds<span class=\"string\">&quot;$j<span class=\"variable\">$i</span>&quot;</span>.Rdata</span><br><span class=\"line\"><span class=\"built_in\">echo</span> $j<span class=\"variable\">$i</span><span class=\"string\">&#x27; done&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br></pre></td></tr></table></figure>\n\n<p>But after I changed it to <code>\\n</code> that is the right code for a linux file, it didn’t work neither. Even after changing the file code via <code>unix2dos</code>, none of the means worked.</p>\n<p>\\(\\boldsymbol{Finally}\\), after several hours of googling, thinking, patting the computer, I tried out the solution. The scripts need to be executed under the linux system. I launched them on Ubuntu again, the newline sign was recognized. </p>\n<p>But it is still a mystery to me that why on a windows prompt none of <code>\\r</code> and <code>\\n</code> can be recognized. If you know it, pls reply this post. Thanks!</p>"},{"title":"PyCUDA series 3: matrix multiplication using multiple blocks","date":"2019-01-21T08:00:00.000Z","_content":"\nA simple practice on matrix multiplication is shown in this post. The matrix product function can use multiple blocks to calculate multiplications of two matrix. \n\n<!--more-->\n \n# A simple matrix multiplication\n\nThe most important part is the kernel function, which is given below\n\n```Python\nkernel_code_template = \"\"\"\n__global__ void matrixmulti(float *a, float *b, float *c)\n{\n\n    // 2D Thread ID \n    int tx = blockDim.x*blockIdx.x + threadIdx.x; // Compute column index\n    int ty = blockDim.y*blockIdx.y + threadIdx.y; // Compute row index\n\n    // Each thread loads one row of M and one column of N, \n    //   to produce one element of P.\n    if((ty <%(MATRIX_SIZE)s) && (tx < %(MATRIX_SIZE)s))\n    {\n    // Pvalue is used to store the element of the matrix\n    // that is computed by the thread\n    float Pvalue = 0;\n    for(int k=0; k<%(MATRIX_SIZE)s;++k)\n    {\n    float Aelement = a[ty*%(MATRIX_SIZE)s +k];\n    float Belement = b[k*%(MATRIX_SIZE)s +tx];\n    Pvalue += Aelement * Belement;\n    }\n    c[ty * %(MATRIX_SIZE)s + tx] = Pvalue;\n    }\n\n}\n\"\"\"\n\n```\n\nNote that the evaluation of C should be put in the conditional loop to guarentee that over-requested threads would not be invoked. \n\n\n# An odd bug\n\nThe code works well when the matrix size is less than 320\\*320 and requesting block size to be 32\\*32. But when the matrix size exceeds 320, like 321, the matrix product produced by GPU is not equal to the result by CPU. The difference between them is very tiny, like the scale of 1e-5. So far, I don't quite understand where this bug comes from. Probabily it is due to the limit of the number of blocks in one grid? \n\n\n\n# Full code\nIt contains the example code and the speed test. Clone it [here](https://github.com/xl0418/GPU_Python/blob/master/gpu_matrixmultiplication.py)\n","source":"_posts/2019-01-21-PyCUDAseries3.md","raw":"---\ntitle: \"PyCUDA series 3: matrix multiplication using multiple blocks\"\ncategories: [Research,GPU programming,pyCUDA]\ntags: [Python, CUDA, GPU programming, Parallel computation]\ndate: 2019-01-21\n\n---\n\nA simple practice on matrix multiplication is shown in this post. The matrix product function can use multiple blocks to calculate multiplications of two matrix. \n\n<!--more-->\n \n# A simple matrix multiplication\n\nThe most important part is the kernel function, which is given below\n\n```Python\nkernel_code_template = \"\"\"\n__global__ void matrixmulti(float *a, float *b, float *c)\n{\n\n    // 2D Thread ID \n    int tx = blockDim.x*blockIdx.x + threadIdx.x; // Compute column index\n    int ty = blockDim.y*blockIdx.y + threadIdx.y; // Compute row index\n\n    // Each thread loads one row of M and one column of N, \n    //   to produce one element of P.\n    if((ty <%(MATRIX_SIZE)s) && (tx < %(MATRIX_SIZE)s))\n    {\n    // Pvalue is used to store the element of the matrix\n    // that is computed by the thread\n    float Pvalue = 0;\n    for(int k=0; k<%(MATRIX_SIZE)s;++k)\n    {\n    float Aelement = a[ty*%(MATRIX_SIZE)s +k];\n    float Belement = b[k*%(MATRIX_SIZE)s +tx];\n    Pvalue += Aelement * Belement;\n    }\n    c[ty * %(MATRIX_SIZE)s + tx] = Pvalue;\n    }\n\n}\n\"\"\"\n\n```\n\nNote that the evaluation of C should be put in the conditional loop to guarentee that over-requested threads would not be invoked. \n\n\n# An odd bug\n\nThe code works well when the matrix size is less than 320\\*320 and requesting block size to be 32\\*32. But when the matrix size exceeds 320, like 321, the matrix product produced by GPU is not equal to the result by CPU. The difference between them is very tiny, like the scale of 1e-5. So far, I don't quite understand where this bug comes from. Probabily it is due to the limit of the number of blocks in one grid? \n\n\n\n# Full code\nIt contains the example code and the speed test. Clone it [here](https://github.com/xl0418/GPU_Python/blob/master/gpu_matrixmultiplication.py)\n","slug":"2019-01-21-PyCUDAseries3","published":1,"updated":"2022-09-17T02:04:05.125Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl85g865v000x4gkr2o50aj1i","content":"<p>A simple practice on matrix multiplication is shown in this post. The matrix product function can use multiple blocks to calculate multiplications of two matrix. </p>\n<span id=\"more\"></span>\n<h1 id=\"A-simple-matrix-multiplication\"><a href=\"#A-simple-matrix-multiplication\" class=\"headerlink\" title=\"A simple matrix multiplication\"></a>A simple matrix multiplication</h1><p>The most important part is the kernel function, which is given below</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kernel_code_template = <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">__global__ void matrixmulti(float *a, float *b, float *c)</span></span><br><span class=\"line\"><span class=\"string\">&#123;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    // 2D Thread ID </span></span><br><span class=\"line\"><span class=\"string\">    int tx = blockDim.x*blockIdx.x + threadIdx.x; // Compute column index</span></span><br><span class=\"line\"><span class=\"string\">    int ty = blockDim.y*blockIdx.y + threadIdx.y; // Compute row index</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    // Each thread loads one row of M and one column of N, </span></span><br><span class=\"line\"><span class=\"string\">    //   to produce one element of P.</span></span><br><span class=\"line\"><span class=\"string\">    if((ty &lt;%(MATRIX_SIZE)s) &amp;&amp; (tx &lt; %(MATRIX_SIZE)s))</span></span><br><span class=\"line\"><span class=\"string\">    &#123;</span></span><br><span class=\"line\"><span class=\"string\">    // Pvalue is used to store the element of the matrix</span></span><br><span class=\"line\"><span class=\"string\">    // that is computed by the thread</span></span><br><span class=\"line\"><span class=\"string\">    float Pvalue = 0;</span></span><br><span class=\"line\"><span class=\"string\">    for(int k=0; k&lt;%(MATRIX_SIZE)s;++k)</span></span><br><span class=\"line\"><span class=\"string\">    &#123;</span></span><br><span class=\"line\"><span class=\"string\">    float Aelement = a[ty*%(MATRIX_SIZE)s +k];</span></span><br><span class=\"line\"><span class=\"string\">    float Belement = b[k*%(MATRIX_SIZE)s +tx];</span></span><br><span class=\"line\"><span class=\"string\">    Pvalue += Aelement * Belement;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">    c[ty * %(MATRIX_SIZE)s + tx] = Pvalue;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>Note that the evaluation of C should be put in the conditional loop to guarentee that over-requested threads would not be invoked. </p>\n<h1 id=\"An-odd-bug\"><a href=\"#An-odd-bug\" class=\"headerlink\" title=\"An odd bug\"></a>An odd bug</h1><p>The code works well when the matrix size is less than 320*320 and requesting block size to be 32*32. But when the matrix size exceeds 320, like 321, the matrix product produced by GPU is not equal to the result by CPU. The difference between them is very tiny, like the scale of 1e-5. So far, I don’t quite understand where this bug comes from. Probabily it is due to the limit of the number of blocks in one grid? </p>\n<h1 id=\"Full-code\"><a href=\"#Full-code\" class=\"headerlink\" title=\"Full code\"></a>Full code</h1><p>It contains the example code and the speed test. Clone it <a href=\"https://github.com/xl0418/GPU_Python/blob/master/gpu_matrixmultiplication.py\">here</a></p>\n","site":{"data":{}},"excerpt":"<p>A simple practice on matrix multiplication is shown in this post. The matrix product function can use multiple blocks to calculate multiplications of two matrix. </p>","more":"<h1 id=\"A-simple-matrix-multiplication\"><a href=\"#A-simple-matrix-multiplication\" class=\"headerlink\" title=\"A simple matrix multiplication\"></a>A simple matrix multiplication</h1><p>The most important part is the kernel function, which is given below</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kernel_code_template = <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">__global__ void matrixmulti(float *a, float *b, float *c)</span></span><br><span class=\"line\"><span class=\"string\">&#123;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    // 2D Thread ID </span></span><br><span class=\"line\"><span class=\"string\">    int tx = blockDim.x*blockIdx.x + threadIdx.x; // Compute column index</span></span><br><span class=\"line\"><span class=\"string\">    int ty = blockDim.y*blockIdx.y + threadIdx.y; // Compute row index</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    // Each thread loads one row of M and one column of N, </span></span><br><span class=\"line\"><span class=\"string\">    //   to produce one element of P.</span></span><br><span class=\"line\"><span class=\"string\">    if((ty &lt;%(MATRIX_SIZE)s) &amp;&amp; (tx &lt; %(MATRIX_SIZE)s))</span></span><br><span class=\"line\"><span class=\"string\">    &#123;</span></span><br><span class=\"line\"><span class=\"string\">    // Pvalue is used to store the element of the matrix</span></span><br><span class=\"line\"><span class=\"string\">    // that is computed by the thread</span></span><br><span class=\"line\"><span class=\"string\">    float Pvalue = 0;</span></span><br><span class=\"line\"><span class=\"string\">    for(int k=0; k&lt;%(MATRIX_SIZE)s;++k)</span></span><br><span class=\"line\"><span class=\"string\">    &#123;</span></span><br><span class=\"line\"><span class=\"string\">    float Aelement = a[ty*%(MATRIX_SIZE)s +k];</span></span><br><span class=\"line\"><span class=\"string\">    float Belement = b[k*%(MATRIX_SIZE)s +tx];</span></span><br><span class=\"line\"><span class=\"string\">    Pvalue += Aelement * Belement;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">    c[ty * %(MATRIX_SIZE)s + tx] = Pvalue;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>Note that the evaluation of C should be put in the conditional loop to guarentee that over-requested threads would not be invoked. </p>\n<h1 id=\"An-odd-bug\"><a href=\"#An-odd-bug\" class=\"headerlink\" title=\"An odd bug\"></a>An odd bug</h1><p>The code works well when the matrix size is less than 320*320 and requesting block size to be 32*32. But when the matrix size exceeds 320, like 321, the matrix product produced by GPU is not equal to the result by CPU. The difference between them is very tiny, like the scale of 1e-5. So far, I don’t quite understand where this bug comes from. Probabily it is due to the limit of the number of blocks in one grid? </p>\n<h1 id=\"Full-code\"><a href=\"#Full-code\" class=\"headerlink\" title=\"Full code\"></a>Full code</h1><p>It contains the example code and the speed test. Clone it <a href=\"https://github.com/xl0418/GPU_Python/blob/master/gpu_matrixmultiplication.py\">here</a></p>"},{"title":"PyCUDA series 2: a simple matrix algebra and speed test","date":"2019-01-14T08:00:00.000Z","_content":"\nIn this post, you will find a simple matrix algebra done by gpu parallelization and a straightforward result of the speed contest between cpu and gpu.\n\n<!--more-->\n \n# A simple matrix algebra to be parallelized\n\nAs a first try, I intended to parallleize a simple matrix algebra in my Project 2 that can be computed as follows on Python:\n\n```Python\nc = a_cpu[:,np.newaxis]-a_cpu\n```\n\nThis is a formula to compute the discrepancy of any pair of elements given by a vector. For example, input \n\n```Python\na = np.array([1,2,3])\n```\n\nthe formula should return \n\n```Python\nc = array([[0,-1,-2,],\n\t[1,0,-1],\n\t[2,1,0]])\n```\n\nA standard python code like the formula above by using `numpy` package, every element in `c_cpu` is computed in a serial order. \n\nIn terms of the power of current cpu, for a lower dimensional matrix, you can hardly feel the elapsed time to compute out the equation. However, if you have a huge matrix of 10000X10000 size and want to loop it 100 times, it costs half a minute on an i7 4790k cpu, although you may ignore the little time consumed. But it is not rare to have a large matrix bigger than 1 million by 1 million and loop it billion times at least in an evolutionary problem. In this case, you are saving your life if the compulation time can be reduced.\n\n# A shortcut to understand GPU parallel computation\n\nNow we have a good way to save our life instead of having a weird pill. CUDA is a parallel computing platform and application programming interface (API) model created by [Nvidia](https://developer.nvidia.com/nvidia-developer-zone). [PyCUDA](https://documen.tician.de/pycuda/index.html) provides a python package to allow people to parallelize their computation on a Graphic Processing Unit (GPU) by Python. For sure, I didn't say everything is parallelizable. Only the procedures that are consisting of independent calculation paths can be parallelized, which means you work on different paths at the same time instead of doing them one by one. Hence, the amount of time that can be saved relies on the percentage of work that is parallelizable in your work. In this sense, matrix algebra is a good representative. Other applications of parallelism involves rendering graphics to a screen, running a Monte Carlo Simulation, multiplying matrices for a machine learning algorithm, or powering a database. Google them yourself. \n\n\nWhy does GPU possess such powerful ability? It owes to its design purpose. A graphic card is designed to process graphics and render them to a screen. What is a graphic? It is just like a matrix. So to process a matrix, the ability to compute multiple entries of the matrix is more important than the ability to deal with just one entry smartly. Hence, a gpu is designed to own a huge amount of threads that can process multiple calculations at one time although they are slow while a cpu only contains few (like an i7 4790k has 4 physical cores which means 4  physical threads, at most 8 threads if including hyperthreads tech) but are faster. A good analogy is that a gpu is like a cluster of students at primary school while a cpu is like a professor. When calculating a complex problem, the professor is definitely faster and smarter. But when computing lots of simple algebra, the cluster of primary students is faster. In summary, CPUs are designed for running a small number of potentially quite complex tasks. GPUs are designed for running a large number of quite\nsimple tasks.\n\n# Parallelize the matrix algebra\n\nAfter having a rough idea of parallelism, let's do it on practice. For a matrix algebra like the above example, what are the independent calculation paths? Apparently, each entry of the output matrix `c` is computed out independently given the input `a`. Thus, we could assign each calculation path to a thread on GPU. \n\n```Python\n\nkernel_code_template = \"\"\"\n__global__ void com_t(int matrixsize,float *a, float *c)\n{\n\n    // 2D Thread ID \n    int tx = blockDim.x*blockIdx.x + threadIdx.x; // Compute column index\n    int ty = blockDim.y*blockIdx.y + threadIdx.y; // Compute row index\n\n    // Pvalue is used to store the element of the matrix\n    // that is computed by the thread\n    float Pvalue = 0;\n\n    // Each thread loads one row of M and one column of N, \n    //   to produce one element of P.\n    if((ty <matrixsize) && (tx < matrixsize))\n    {\n    float Aelement = a[ty];\n    float Belement = a[tx];\n    Pvalue = Aelement - Belement;\n    // Write the matrix to device memory;\n    // each thread writes one element\n    c[ty * matrixsize + tx] = Pvalue;\n    }\n}\n\"\"\"\n```\n\n\nThe most important part of parallelism on GPU is the kernel function which is coded for a single calculation path. The only difference among different calculation paths is the locality information of the entries of matrix `c` in the memory. Normally, we can envisage a memory on GPU as a cluster of grids of blocks of threads. But in fact, it is not this physical structure on the borad of the card. It involves streaming processors (SMs) dealing with wraps. However, here we better use the metaphor.\n\n![default](2019-01-14-PyCUDAseries2/gridblockthread.png)\n\nEach entry in matrix `c` corresponds to a specific combination of `gridIdx.x,gridIdx.y,blockIdx.x,blockIdx.y,threadIdx.x,threadIdx.y`. The value of the indexes also depend on how we allocate the size of grid, block. A regular way for a matrix algebra is to fit the struture to the matrix. For example, if we want to compute a 5X5 matrix, we can allocate the size of block as 5X5 which means we will use a matrix of 5X5 threads for compuatation. But a block contains at most 1024 threads for the current card (GTX 970). Thus for a square matrix we can allocate at most a size of 32X32 threads for one block. If we want to work on a larger matrix, we need more blocks or even more grids. This then causes one issue that some threads may not be used if the matrix size is not a multiplier of the block size. Therefore, we need to constrain our computation within the matrix by using `if((ty <matrixsize) && (tx < matrixsize))`. And make sure the evaluation of matrix `c` is put in the loop. Otherwise, the over requested threads (if the requested threads don't fit the matrix size) will be invoked and replace the inner results in `c`.\n\nOnce we have correctly allocated the memory and located the entry by these indexes, we can formulate your calculation. After that, the code will be uploaded to GPU and tranferred to the code of GPU (compile). Once all entries have been calculated, the results will be stored in the memory on GPU. Then cpu will pull back the result.  \n\n```Python\n\n# compile the kernel code\nmod = compiler.SourceModule(kernel_code_template)\n\n# get the kernel function from the compiled module\nmatrixmul = mod.get_function(\"com_t\")\n\nmatrixsize = 3\nBLOCK_SIZE = 2\n\n# call the kernel on the card\nmatrixmul(np.uint32(matrixsize),\n    # inputs\n    a_gpu,\n    # output\n    c_gpu,\n    # 4 blocks of BLOCK_SIZE x BLOCK_SIZE threads\n    grid = (2,2,1),\n    block = (BLOCK_SIZE, BLOCK_SIZE, 1),\n    )\n```\n\n# Speed comparison between CPU and GPU\n\nAt last, to show the power of GPU even on such simple matrix algebra, I run calculation for different dimensions and loop each calculation 100 times to enlarge the time consumption.\n\n![default](2019-01-14-PyCUDAseries2/speedtest.png)\n\nAs the figure shows, the time consumption for 100 times calculations starts to significantly split up when the dimension of matrix is over 2000. The time consumption on CPU grows almost exponentially along the dimension while on gpu it only grows a little. With the increase of dimension, you save a huge amount of your time and your life.\n\n# End\nThis is a quite simplified introduction to a parallelism example. There is a bank of posts explaining parallelism better and more exhaustive than this one. However, my goal here is to use a simple example and a short length of words to have you get an idea of how it works instead of scaring you away from this field. Once you fall into the trap of \"it looks as simple as the author said\", I believe you will learn more by yourself :-)\n\n# Reference\n[CUDA Programming] by Shane Cook is a good start book for learning both the hardware and the language. \n\nThis [PyCUDA website](https://andreask.cs.illinois.edu/PyCuda) provides some examples on Python.\n\n# Full code\nIt contains the example code and the speed test. Clone it [here](https://github.com/xl0418/GPU_Python/blob/master/gpu_cpu_speedtest.py)\n","source":"_posts/2019-01-14-PyCUDAseries2.md","raw":"---\ntitle: \"PyCUDA series 2: a simple matrix algebra and speed test\"\ncategories: [Research,GPU programming,pyCUDA]\ntags: [Python, CUDA, GPU programming, Parallel computation]\ndate: 2019-01-14\n\n---\n\nIn this post, you will find a simple matrix algebra done by gpu parallelization and a straightforward result of the speed contest between cpu and gpu.\n\n<!--more-->\n \n# A simple matrix algebra to be parallelized\n\nAs a first try, I intended to parallleize a simple matrix algebra in my Project 2 that can be computed as follows on Python:\n\n```Python\nc = a_cpu[:,np.newaxis]-a_cpu\n```\n\nThis is a formula to compute the discrepancy of any pair of elements given by a vector. For example, input \n\n```Python\na = np.array([1,2,3])\n```\n\nthe formula should return \n\n```Python\nc = array([[0,-1,-2,],\n\t[1,0,-1],\n\t[2,1,0]])\n```\n\nA standard python code like the formula above by using `numpy` package, every element in `c_cpu` is computed in a serial order. \n\nIn terms of the power of current cpu, for a lower dimensional matrix, you can hardly feel the elapsed time to compute out the equation. However, if you have a huge matrix of 10000X10000 size and want to loop it 100 times, it costs half a minute on an i7 4790k cpu, although you may ignore the little time consumed. But it is not rare to have a large matrix bigger than 1 million by 1 million and loop it billion times at least in an evolutionary problem. In this case, you are saving your life if the compulation time can be reduced.\n\n# A shortcut to understand GPU parallel computation\n\nNow we have a good way to save our life instead of having a weird pill. CUDA is a parallel computing platform and application programming interface (API) model created by [Nvidia](https://developer.nvidia.com/nvidia-developer-zone). [PyCUDA](https://documen.tician.de/pycuda/index.html) provides a python package to allow people to parallelize their computation on a Graphic Processing Unit (GPU) by Python. For sure, I didn't say everything is parallelizable. Only the procedures that are consisting of independent calculation paths can be parallelized, which means you work on different paths at the same time instead of doing them one by one. Hence, the amount of time that can be saved relies on the percentage of work that is parallelizable in your work. In this sense, matrix algebra is a good representative. Other applications of parallelism involves rendering graphics to a screen, running a Monte Carlo Simulation, multiplying matrices for a machine learning algorithm, or powering a database. Google them yourself. \n\n\nWhy does GPU possess such powerful ability? It owes to its design purpose. A graphic card is designed to process graphics and render them to a screen. What is a graphic? It is just like a matrix. So to process a matrix, the ability to compute multiple entries of the matrix is more important than the ability to deal with just one entry smartly. Hence, a gpu is designed to own a huge amount of threads that can process multiple calculations at one time although they are slow while a cpu only contains few (like an i7 4790k has 4 physical cores which means 4  physical threads, at most 8 threads if including hyperthreads tech) but are faster. A good analogy is that a gpu is like a cluster of students at primary school while a cpu is like a professor. When calculating a complex problem, the professor is definitely faster and smarter. But when computing lots of simple algebra, the cluster of primary students is faster. In summary, CPUs are designed for running a small number of potentially quite complex tasks. GPUs are designed for running a large number of quite\nsimple tasks.\n\n# Parallelize the matrix algebra\n\nAfter having a rough idea of parallelism, let's do it on practice. For a matrix algebra like the above example, what are the independent calculation paths? Apparently, each entry of the output matrix `c` is computed out independently given the input `a`. Thus, we could assign each calculation path to a thread on GPU. \n\n```Python\n\nkernel_code_template = \"\"\"\n__global__ void com_t(int matrixsize,float *a, float *c)\n{\n\n    // 2D Thread ID \n    int tx = blockDim.x*blockIdx.x + threadIdx.x; // Compute column index\n    int ty = blockDim.y*blockIdx.y + threadIdx.y; // Compute row index\n\n    // Pvalue is used to store the element of the matrix\n    // that is computed by the thread\n    float Pvalue = 0;\n\n    // Each thread loads one row of M and one column of N, \n    //   to produce one element of P.\n    if((ty <matrixsize) && (tx < matrixsize))\n    {\n    float Aelement = a[ty];\n    float Belement = a[tx];\n    Pvalue = Aelement - Belement;\n    // Write the matrix to device memory;\n    // each thread writes one element\n    c[ty * matrixsize + tx] = Pvalue;\n    }\n}\n\"\"\"\n```\n\n\nThe most important part of parallelism on GPU is the kernel function which is coded for a single calculation path. The only difference among different calculation paths is the locality information of the entries of matrix `c` in the memory. Normally, we can envisage a memory on GPU as a cluster of grids of blocks of threads. But in fact, it is not this physical structure on the borad of the card. It involves streaming processors (SMs) dealing with wraps. However, here we better use the metaphor.\n\n![default](2019-01-14-PyCUDAseries2/gridblockthread.png)\n\nEach entry in matrix `c` corresponds to a specific combination of `gridIdx.x,gridIdx.y,blockIdx.x,blockIdx.y,threadIdx.x,threadIdx.y`. The value of the indexes also depend on how we allocate the size of grid, block. A regular way for a matrix algebra is to fit the struture to the matrix. For example, if we want to compute a 5X5 matrix, we can allocate the size of block as 5X5 which means we will use a matrix of 5X5 threads for compuatation. But a block contains at most 1024 threads for the current card (GTX 970). Thus for a square matrix we can allocate at most a size of 32X32 threads for one block. If we want to work on a larger matrix, we need more blocks or even more grids. This then causes one issue that some threads may not be used if the matrix size is not a multiplier of the block size. Therefore, we need to constrain our computation within the matrix by using `if((ty <matrixsize) && (tx < matrixsize))`. And make sure the evaluation of matrix `c` is put in the loop. Otherwise, the over requested threads (if the requested threads don't fit the matrix size) will be invoked and replace the inner results in `c`.\n\nOnce we have correctly allocated the memory and located the entry by these indexes, we can formulate your calculation. After that, the code will be uploaded to GPU and tranferred to the code of GPU (compile). Once all entries have been calculated, the results will be stored in the memory on GPU. Then cpu will pull back the result.  \n\n```Python\n\n# compile the kernel code\nmod = compiler.SourceModule(kernel_code_template)\n\n# get the kernel function from the compiled module\nmatrixmul = mod.get_function(\"com_t\")\n\nmatrixsize = 3\nBLOCK_SIZE = 2\n\n# call the kernel on the card\nmatrixmul(np.uint32(matrixsize),\n    # inputs\n    a_gpu,\n    # output\n    c_gpu,\n    # 4 blocks of BLOCK_SIZE x BLOCK_SIZE threads\n    grid = (2,2,1),\n    block = (BLOCK_SIZE, BLOCK_SIZE, 1),\n    )\n```\n\n# Speed comparison between CPU and GPU\n\nAt last, to show the power of GPU even on such simple matrix algebra, I run calculation for different dimensions and loop each calculation 100 times to enlarge the time consumption.\n\n![default](2019-01-14-PyCUDAseries2/speedtest.png)\n\nAs the figure shows, the time consumption for 100 times calculations starts to significantly split up when the dimension of matrix is over 2000. The time consumption on CPU grows almost exponentially along the dimension while on gpu it only grows a little. With the increase of dimension, you save a huge amount of your time and your life.\n\n# End\nThis is a quite simplified introduction to a parallelism example. There is a bank of posts explaining parallelism better and more exhaustive than this one. However, my goal here is to use a simple example and a short length of words to have you get an idea of how it works instead of scaring you away from this field. Once you fall into the trap of \"it looks as simple as the author said\", I believe you will learn more by yourself :-)\n\n# Reference\n[CUDA Programming] by Shane Cook is a good start book for learning both the hardware and the language. \n\nThis [PyCUDA website](https://andreask.cs.illinois.edu/PyCuda) provides some examples on Python.\n\n# Full code\nIt contains the example code and the speed test. Clone it [here](https://github.com/xl0418/GPU_Python/blob/master/gpu_cpu_speedtest.py)\n","slug":"2019-01-14-PyCUDAseries2","published":1,"updated":"2022-09-17T02:04:05.124Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl85g865w00104gkr5icq7o20","content":"<p>In this post, you will find a simple matrix algebra done by gpu parallelization and a straightforward result of the speed contest between cpu and gpu.</p>\n<span id=\"more\"></span>\n<h1 id=\"A-simple-matrix-algebra-to-be-parallelized\"><a href=\"#A-simple-matrix-algebra-to-be-parallelized\" class=\"headerlink\" title=\"A simple matrix algebra to be parallelized\"></a>A simple matrix algebra to be parallelized</h1><p>As a first try, I intended to parallleize a simple matrix algebra in my Project 2 that can be computed as follows on Python:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">c = a_cpu[:,np.newaxis]-a_cpu</span><br></pre></td></tr></table></figure>\n\n<p>This is a formula to compute the discrepancy of any pair of elements given by a vector. For example, input </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = np.array([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>])</span><br></pre></td></tr></table></figure>\n\n<p>the formula should return </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">c = array([[<span class=\"number\">0</span>,-<span class=\"number\">1</span>,-<span class=\"number\">2</span>,],</span><br><span class=\"line\">\t[<span class=\"number\">1</span>,<span class=\"number\">0</span>,-<span class=\"number\">1</span>],</span><br><span class=\"line\">\t[<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>]])</span><br></pre></td></tr></table></figure>\n\n<p>A standard python code like the formula above by using <code>numpy</code> package, every element in <code>c_cpu</code> is computed in a serial order. </p>\n<p>In terms of the power of current cpu, for a lower dimensional matrix, you can hardly feel the elapsed time to compute out the equation. However, if you have a huge matrix of 10000X10000 size and want to loop it 100 times, it costs half a minute on an i7 4790k cpu, although you may ignore the little time consumed. But it is not rare to have a large matrix bigger than 1 million by 1 million and loop it billion times at least in an evolutionary problem. In this case, you are saving your life if the compulation time can be reduced.</p>\n<h1 id=\"A-shortcut-to-understand-GPU-parallel-computation\"><a href=\"#A-shortcut-to-understand-GPU-parallel-computation\" class=\"headerlink\" title=\"A shortcut to understand GPU parallel computation\"></a>A shortcut to understand GPU parallel computation</h1><p>Now we have a good way to save our life instead of having a weird pill. CUDA is a parallel computing platform and application programming interface (API) model created by <a href=\"https://developer.nvidia.com/nvidia-developer-zone\">Nvidia</a>. <a href=\"https://documen.tician.de/pycuda/index.html\">PyCUDA</a> provides a python package to allow people to parallelize their computation on a Graphic Processing Unit (GPU) by Python. For sure, I didn’t say everything is parallelizable. Only the procedures that are consisting of independent calculation paths can be parallelized, which means you work on different paths at the same time instead of doing them one by one. Hence, the amount of time that can be saved relies on the percentage of work that is parallelizable in your work. In this sense, matrix algebra is a good representative. Other applications of parallelism involves rendering graphics to a screen, running a Monte Carlo Simulation, multiplying matrices for a machine learning algorithm, or powering a database. Google them yourself. </p>\n<p>Why does GPU possess such powerful ability? It owes to its design purpose. A graphic card is designed to process graphics and render them to a screen. What is a graphic? It is just like a matrix. So to process a matrix, the ability to compute multiple entries of the matrix is more important than the ability to deal with just one entry smartly. Hence, a gpu is designed to own a huge amount of threads that can process multiple calculations at one time although they are slow while a cpu only contains few (like an i7 4790k has 4 physical cores which means 4  physical threads, at most 8 threads if including hyperthreads tech) but are faster. A good analogy is that a gpu is like a cluster of students at primary school while a cpu is like a professor. When calculating a complex problem, the professor is definitely faster and smarter. But when computing lots of simple algebra, the cluster of primary students is faster. In summary, CPUs are designed for running a small number of potentially quite complex tasks. GPUs are designed for running a large number of quite<br>simple tasks.</p>\n<h1 id=\"Parallelize-the-matrix-algebra\"><a href=\"#Parallelize-the-matrix-algebra\" class=\"headerlink\" title=\"Parallelize the matrix algebra\"></a>Parallelize the matrix algebra</h1><p>After having a rough idea of parallelism, let’s do it on practice. For a matrix algebra like the above example, what are the independent calculation paths? Apparently, each entry of the output matrix <code>c</code> is computed out independently given the input <code>a</code>. Thus, we could assign each calculation path to a thread on GPU. </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">kernel_code_template = <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">__global__ void com_t(int matrixsize,float *a, float *c)</span></span><br><span class=\"line\"><span class=\"string\">&#123;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    // 2D Thread ID </span></span><br><span class=\"line\"><span class=\"string\">    int tx = blockDim.x*blockIdx.x + threadIdx.x; // Compute column index</span></span><br><span class=\"line\"><span class=\"string\">    int ty = blockDim.y*blockIdx.y + threadIdx.y; // Compute row index</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    // Pvalue is used to store the element of the matrix</span></span><br><span class=\"line\"><span class=\"string\">    // that is computed by the thread</span></span><br><span class=\"line\"><span class=\"string\">    float Pvalue = 0;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    // Each thread loads one row of M and one column of N, </span></span><br><span class=\"line\"><span class=\"string\">    //   to produce one element of P.</span></span><br><span class=\"line\"><span class=\"string\">    if((ty &lt;matrixsize) &amp;&amp; (tx &lt; matrixsize))</span></span><br><span class=\"line\"><span class=\"string\">    &#123;</span></span><br><span class=\"line\"><span class=\"string\">    float Aelement = a[ty];</span></span><br><span class=\"line\"><span class=\"string\">    float Belement = a[tx];</span></span><br><span class=\"line\"><span class=\"string\">    Pvalue = Aelement - Belement;</span></span><br><span class=\"line\"><span class=\"string\">    // Write the matrix to device memory;</span></span><br><span class=\"line\"><span class=\"string\">    // each thread writes one element</span></span><br><span class=\"line\"><span class=\"string\">    c[ty * matrixsize + tx] = Pvalue;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n<p>The most important part of parallelism on GPU is the kernel function which is coded for a single calculation path. The only difference among different calculation paths is the locality information of the entries of matrix <code>c</code> in the memory. Normally, we can envisage a memory on GPU as a cluster of grids of blocks of threads. But in fact, it is not this physical structure on the borad of the card. It involves streaming processors (SMs) dealing with wraps. However, here we better use the metaphor.</p>\n<p><img src=\"/2019-01-14-PyCUDAseries2/gridblockthread.png\" alt=\"default\"></p>\n<p>Each entry in matrix <code>c</code> corresponds to a specific combination of <code>gridIdx.x,gridIdx.y,blockIdx.x,blockIdx.y,threadIdx.x,threadIdx.y</code>. The value of the indexes also depend on how we allocate the size of grid, block. A regular way for a matrix algebra is to fit the struture to the matrix. For example, if we want to compute a 5X5 matrix, we can allocate the size of block as 5X5 which means we will use a matrix of 5X5 threads for compuatation. But a block contains at most 1024 threads for the current card (GTX 970). Thus for a square matrix we can allocate at most a size of 32X32 threads for one block. If we want to work on a larger matrix, we need more blocks or even more grids. This then causes one issue that some threads may not be used if the matrix size is not a multiplier of the block size. Therefore, we need to constrain our computation within the matrix by using <code>if((ty &lt;matrixsize) &amp;&amp; (tx &lt; matrixsize))</code>. And make sure the evaluation of matrix <code>c</code> is put in the loop. Otherwise, the over requested threads (if the requested threads don’t fit the matrix size) will be invoked and replace the inner results in <code>c</code>.</p>\n<p>Once we have correctly allocated the memory and located the entry by these indexes, we can formulate your calculation. After that, the code will be uploaded to GPU and tranferred to the code of GPU (compile). Once all entries have been calculated, the results will be stored in the memory on GPU. Then cpu will pull back the result.  </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># compile the kernel code</span></span><br><span class=\"line\">mod = compiler.SourceModule(kernel_code_template)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># get the kernel function from the compiled module</span></span><br><span class=\"line\">matrixmul = mod.get_function(<span class=\"string\">&quot;com_t&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">matrixsize = <span class=\"number\">3</span></span><br><span class=\"line\">BLOCK_SIZE = <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># call the kernel on the card</span></span><br><span class=\"line\">matrixmul(np.uint32(matrixsize),</span><br><span class=\"line\">    <span class=\"comment\"># inputs</span></span><br><span class=\"line\">    a_gpu,</span><br><span class=\"line\">    <span class=\"comment\"># output</span></span><br><span class=\"line\">    c_gpu,</span><br><span class=\"line\">    <span class=\"comment\"># 4 blocks of BLOCK_SIZE x BLOCK_SIZE threads</span></span><br><span class=\"line\">    grid = (<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>),</span><br><span class=\"line\">    block = (BLOCK_SIZE, BLOCK_SIZE, <span class=\"number\">1</span>),</span><br><span class=\"line\">    )</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Speed-comparison-between-CPU-and-GPU\"><a href=\"#Speed-comparison-between-CPU-and-GPU\" class=\"headerlink\" title=\"Speed comparison between CPU and GPU\"></a>Speed comparison between CPU and GPU</h1><p>At last, to show the power of GPU even on such simple matrix algebra, I run calculation for different dimensions and loop each calculation 100 times to enlarge the time consumption.</p>\n<p><img src=\"/2019-01-14-PyCUDAseries2/speedtest.png\" alt=\"default\"></p>\n<p>As the figure shows, the time consumption for 100 times calculations starts to significantly split up when the dimension of matrix is over 2000. The time consumption on CPU grows almost exponentially along the dimension while on gpu it only grows a little. With the increase of dimension, you save a huge amount of your time and your life.</p>\n<h1 id=\"End\"><a href=\"#End\" class=\"headerlink\" title=\"End\"></a>End</h1><p>This is a quite simplified introduction to a parallelism example. There is a bank of posts explaining parallelism better and more exhaustive than this one. However, my goal here is to use a simple example and a short length of words to have you get an idea of how it works instead of scaring you away from this field. Once you fall into the trap of “it looks as simple as the author said”, I believe you will learn more by yourself :-)</p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p>[CUDA Programming] by Shane Cook is a good start book for learning both the hardware and the language. </p>\n<p>This <a href=\"https://andreask.cs.illinois.edu/PyCuda\">PyCUDA website</a> provides some examples on Python.</p>\n<h1 id=\"Full-code\"><a href=\"#Full-code\" class=\"headerlink\" title=\"Full code\"></a>Full code</h1><p>It contains the example code and the speed test. Clone it <a href=\"https://github.com/xl0418/GPU_Python/blob/master/gpu_cpu_speedtest.py\">here</a></p>\n","site":{"data":{}},"excerpt":"<p>In this post, you will find a simple matrix algebra done by gpu parallelization and a straightforward result of the speed contest between cpu and gpu.</p>","more":"<h1 id=\"A-simple-matrix-algebra-to-be-parallelized\"><a href=\"#A-simple-matrix-algebra-to-be-parallelized\" class=\"headerlink\" title=\"A simple matrix algebra to be parallelized\"></a>A simple matrix algebra to be parallelized</h1><p>As a first try, I intended to parallleize a simple matrix algebra in my Project 2 that can be computed as follows on Python:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">c = a_cpu[:,np.newaxis]-a_cpu</span><br></pre></td></tr></table></figure>\n\n<p>This is a formula to compute the discrepancy of any pair of elements given by a vector. For example, input </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = np.array([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>])</span><br></pre></td></tr></table></figure>\n\n<p>the formula should return </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">c = array([[<span class=\"number\">0</span>,-<span class=\"number\">1</span>,-<span class=\"number\">2</span>,],</span><br><span class=\"line\">\t[<span class=\"number\">1</span>,<span class=\"number\">0</span>,-<span class=\"number\">1</span>],</span><br><span class=\"line\">\t[<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>]])</span><br></pre></td></tr></table></figure>\n\n<p>A standard python code like the formula above by using <code>numpy</code> package, every element in <code>c_cpu</code> is computed in a serial order. </p>\n<p>In terms of the power of current cpu, for a lower dimensional matrix, you can hardly feel the elapsed time to compute out the equation. However, if you have a huge matrix of 10000X10000 size and want to loop it 100 times, it costs half a minute on an i7 4790k cpu, although you may ignore the little time consumed. But it is not rare to have a large matrix bigger than 1 million by 1 million and loop it billion times at least in an evolutionary problem. In this case, you are saving your life if the compulation time can be reduced.</p>\n<h1 id=\"A-shortcut-to-understand-GPU-parallel-computation\"><a href=\"#A-shortcut-to-understand-GPU-parallel-computation\" class=\"headerlink\" title=\"A shortcut to understand GPU parallel computation\"></a>A shortcut to understand GPU parallel computation</h1><p>Now we have a good way to save our life instead of having a weird pill. CUDA is a parallel computing platform and application programming interface (API) model created by <a href=\"https://developer.nvidia.com/nvidia-developer-zone\">Nvidia</a>. <a href=\"https://documen.tician.de/pycuda/index.html\">PyCUDA</a> provides a python package to allow people to parallelize their computation on a Graphic Processing Unit (GPU) by Python. For sure, I didn’t say everything is parallelizable. Only the procedures that are consisting of independent calculation paths can be parallelized, which means you work on different paths at the same time instead of doing them one by one. Hence, the amount of time that can be saved relies on the percentage of work that is parallelizable in your work. In this sense, matrix algebra is a good representative. Other applications of parallelism involves rendering graphics to a screen, running a Monte Carlo Simulation, multiplying matrices for a machine learning algorithm, or powering a database. Google them yourself. </p>\n<p>Why does GPU possess such powerful ability? It owes to its design purpose. A graphic card is designed to process graphics and render them to a screen. What is a graphic? It is just like a matrix. So to process a matrix, the ability to compute multiple entries of the matrix is more important than the ability to deal with just one entry smartly. Hence, a gpu is designed to own a huge amount of threads that can process multiple calculations at one time although they are slow while a cpu only contains few (like an i7 4790k has 4 physical cores which means 4  physical threads, at most 8 threads if including hyperthreads tech) but are faster. A good analogy is that a gpu is like a cluster of students at primary school while a cpu is like a professor. When calculating a complex problem, the professor is definitely faster and smarter. But when computing lots of simple algebra, the cluster of primary students is faster. In summary, CPUs are designed for running a small number of potentially quite complex tasks. GPUs are designed for running a large number of quite<br>simple tasks.</p>\n<h1 id=\"Parallelize-the-matrix-algebra\"><a href=\"#Parallelize-the-matrix-algebra\" class=\"headerlink\" title=\"Parallelize the matrix algebra\"></a>Parallelize the matrix algebra</h1><p>After having a rough idea of parallelism, let’s do it on practice. For a matrix algebra like the above example, what are the independent calculation paths? Apparently, each entry of the output matrix <code>c</code> is computed out independently given the input <code>a</code>. Thus, we could assign each calculation path to a thread on GPU. </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">kernel_code_template = <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">__global__ void com_t(int matrixsize,float *a, float *c)</span></span><br><span class=\"line\"><span class=\"string\">&#123;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    // 2D Thread ID </span></span><br><span class=\"line\"><span class=\"string\">    int tx = blockDim.x*blockIdx.x + threadIdx.x; // Compute column index</span></span><br><span class=\"line\"><span class=\"string\">    int ty = blockDim.y*blockIdx.y + threadIdx.y; // Compute row index</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    // Pvalue is used to store the element of the matrix</span></span><br><span class=\"line\"><span class=\"string\">    // that is computed by the thread</span></span><br><span class=\"line\"><span class=\"string\">    float Pvalue = 0;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    // Each thread loads one row of M and one column of N, </span></span><br><span class=\"line\"><span class=\"string\">    //   to produce one element of P.</span></span><br><span class=\"line\"><span class=\"string\">    if((ty &lt;matrixsize) &amp;&amp; (tx &lt; matrixsize))</span></span><br><span class=\"line\"><span class=\"string\">    &#123;</span></span><br><span class=\"line\"><span class=\"string\">    float Aelement = a[ty];</span></span><br><span class=\"line\"><span class=\"string\">    float Belement = a[tx];</span></span><br><span class=\"line\"><span class=\"string\">    Pvalue = Aelement - Belement;</span></span><br><span class=\"line\"><span class=\"string\">    // Write the matrix to device memory;</span></span><br><span class=\"line\"><span class=\"string\">    // each thread writes one element</span></span><br><span class=\"line\"><span class=\"string\">    c[ty * matrixsize + tx] = Pvalue;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n<p>The most important part of parallelism on GPU is the kernel function which is coded for a single calculation path. The only difference among different calculation paths is the locality information of the entries of matrix <code>c</code> in the memory. Normally, we can envisage a memory on GPU as a cluster of grids of blocks of threads. But in fact, it is not this physical structure on the borad of the card. It involves streaming processors (SMs) dealing with wraps. However, here we better use the metaphor.</p>\n<p><img src=\"/2019-01-14-PyCUDAseries2/gridblockthread.png\" alt=\"default\"></p>\n<p>Each entry in matrix <code>c</code> corresponds to a specific combination of <code>gridIdx.x,gridIdx.y,blockIdx.x,blockIdx.y,threadIdx.x,threadIdx.y</code>. The value of the indexes also depend on how we allocate the size of grid, block. A regular way for a matrix algebra is to fit the struture to the matrix. For example, if we want to compute a 5X5 matrix, we can allocate the size of block as 5X5 which means we will use a matrix of 5X5 threads for compuatation. But a block contains at most 1024 threads for the current card (GTX 970). Thus for a square matrix we can allocate at most a size of 32X32 threads for one block. If we want to work on a larger matrix, we need more blocks or even more grids. This then causes one issue that some threads may not be used if the matrix size is not a multiplier of the block size. Therefore, we need to constrain our computation within the matrix by using <code>if((ty &lt;matrixsize) &amp;&amp; (tx &lt; matrixsize))</code>. And make sure the evaluation of matrix <code>c</code> is put in the loop. Otherwise, the over requested threads (if the requested threads don’t fit the matrix size) will be invoked and replace the inner results in <code>c</code>.</p>\n<p>Once we have correctly allocated the memory and located the entry by these indexes, we can formulate your calculation. After that, the code will be uploaded to GPU and tranferred to the code of GPU (compile). Once all entries have been calculated, the results will be stored in the memory on GPU. Then cpu will pull back the result.  </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># compile the kernel code</span></span><br><span class=\"line\">mod = compiler.SourceModule(kernel_code_template)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># get the kernel function from the compiled module</span></span><br><span class=\"line\">matrixmul = mod.get_function(<span class=\"string\">&quot;com_t&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">matrixsize = <span class=\"number\">3</span></span><br><span class=\"line\">BLOCK_SIZE = <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># call the kernel on the card</span></span><br><span class=\"line\">matrixmul(np.uint32(matrixsize),</span><br><span class=\"line\">    <span class=\"comment\"># inputs</span></span><br><span class=\"line\">    a_gpu,</span><br><span class=\"line\">    <span class=\"comment\"># output</span></span><br><span class=\"line\">    c_gpu,</span><br><span class=\"line\">    <span class=\"comment\"># 4 blocks of BLOCK_SIZE x BLOCK_SIZE threads</span></span><br><span class=\"line\">    grid = (<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>),</span><br><span class=\"line\">    block = (BLOCK_SIZE, BLOCK_SIZE, <span class=\"number\">1</span>),</span><br><span class=\"line\">    )</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"Speed-comparison-between-CPU-and-GPU\"><a href=\"#Speed-comparison-between-CPU-and-GPU\" class=\"headerlink\" title=\"Speed comparison between CPU and GPU\"></a>Speed comparison between CPU and GPU</h1><p>At last, to show the power of GPU even on such simple matrix algebra, I run calculation for different dimensions and loop each calculation 100 times to enlarge the time consumption.</p>\n<p><img src=\"/2019-01-14-PyCUDAseries2/speedtest.png\" alt=\"default\"></p>\n<p>As the figure shows, the time consumption for 100 times calculations starts to significantly split up when the dimension of matrix is over 2000. The time consumption on CPU grows almost exponentially along the dimension while on gpu it only grows a little. With the increase of dimension, you save a huge amount of your time and your life.</p>\n<h1 id=\"End\"><a href=\"#End\" class=\"headerlink\" title=\"End\"></a>End</h1><p>This is a quite simplified introduction to a parallelism example. There is a bank of posts explaining parallelism better and more exhaustive than this one. However, my goal here is to use a simple example and a short length of words to have you get an idea of how it works instead of scaring you away from this field. Once you fall into the trap of “it looks as simple as the author said”, I believe you will learn more by yourself :-)</p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><p>[CUDA Programming] by Shane Cook is a good start book for learning both the hardware and the language. </p>\n<p>This <a href=\"https://andreask.cs.illinois.edu/PyCuda\">PyCUDA website</a> provides some examples on Python.</p>\n<h1 id=\"Full-code\"><a href=\"#Full-code\" class=\"headerlink\" title=\"Full code\"></a>Full code</h1><p>It contains the example code and the speed test. Clone it <a href=\"https://github.com/xl0418/GPU_Python/blob/master/gpu_cpu_speedtest.py\">here</a></p>"},{"title":"Machine learning on biology S1: model classification via ML","date":"2019-02-01T08:00:00.000Z","_content":"\nOn my 2nd Phd project, I have constructed a complex trait-population model to describe how species evolve and assemble in a community under natural selection. However, people may naturally ask if such complexity is really needed. What is the discrepancy between the model with and without population dynamics and variable trait variance? To answer this question, a model selection/classification should be performed on the data generated under those candidate models. As what we used in parameter inference, an [Approximate Bayesian Computation-Sequential Monte Carlo method](https://xl0418.github.io/2018/11/30/2018-11-30-SMCplots/) is able to handle this work. However, a huge computational demanding is the bottle neck.  To avoid to waste time on fitting each empirical data set by ABC-SMC, a method that only uses the feature of data sets would be a better choice. This reminds me the existing and fast-developed took, i.e. machine learning. So, from this post on, I would like to share my experience of learning Machine Leaning, how to construct a neural network, how to derive backwards propagation algorithm for leaning parameters of a neural network and how to use tensorflow to simply use machine learning, or even deep learning (a multiple-layer neural network algorithm), to do model selection/classification on the topic I mentioned above. \n\n<!--more-->\n \n# A fast illustration\n\nPresenting application at first would be concrete for people understand what I am talking about. Here in this simple example, I generated 200K data sets for each of the four models, i.e. Brownian Motion model, Ornstein Uhlenbeck (OU) model, Trait-population model, anti-Ornstein Uhlenbeck model. As a preliminary test, I just adjusted the parameter values for \\\\(\\\\gamma\\\\) and \\\\(\\\\alpha\\\\) to stand for 4 models, i.e. when \\\\(\\\\gamma=0,\\\\alpha=0\\\\) it stands for a Brownian Motion model; when \\\\(\\\\gamma>0,\\\\alpha=0\\\\) it stands for an OU model; when \\\\(\\\\gamma=0,\\\\alpha>0\\\\) it stands for an anti-OU model; when \\\\(\\\\gamma>0,\\\\alpha>0\\\\) it stands for a trait-population evolution (TP) model. I didn't remove population dynamics from the BM and OU model. Therefore, the data generated by those two processes would be more alike to TP model than by the standard BM and OU model. The logic behind is that if the learning neural network can distinguish TP from the other 3 models, it is able to pick TP out from model pile with standard BM and OU model. Note that the anti-OU model is similar to Drury et al. model in 2018. \n\nWhen the parameter is nonzero, I simply randomly chose values as I assume we don't know any prior information from the empirical data. \n\nI used in total around 1000K data sets that are randomly generated under 4 models but labeled with correct model names to train a simply three-layer neural network. It is super fast to train such small network and can be done within few minutes. Note that fitting data via ABC-SMC may coat a few days with 30 iterations and 200K particles for each iteration. Then I generated 100 data sets to feed the trained neural network. The generating models are known in advance. The purpose of this test is to check if the trained network is able to recognize the generating models. \n\n# A preliminary result\n\nThe result is shown below:\n\n![fig](2019-02-01-Machinelearningseries1/modelselection1.png)   \n\nEach chart contains four bars indicating the probability of each model (B: BM; O: OU; T: TP; A: Anti-OU). Color red denotes that the prediction of the network is wrong. Otherwise, the highest bar correctly implies the generating model. The results reveal that BM and OU model are confusing to the trained neural network. This makes sense that because of the normalization of traits the output of these two models show no significant discrepancy, i.e. almost all traits are evenly distributed in the trait space. Only the range of the traits would provide some information, i.e. BM model has wider range for the traits than OU model. But the normalization neglects it. The other two models, TP and Anti-OU are nicely distinguishable from the model pile. This indicates that the trait-population model do have significant pattern to express itself. Thus our complexity plays a role in describing trait patterns. \n\n# Future plan\n\nHere in the example, I only exploited a 3-layer neural network but already got a nice result. The issues of confusing BM and OU model may be resolved if a deep neural network is applied. Anyway, the power of machine learning on biology is shown and there are more improvement space waiting for further study.\n\nI do believe that machine learning can be useful in biology. But so far as I know, few literature present this tech on biology field. In fact, data analysis and pattern recognition are also key component in biological research besides modeling. I hope machine learning could attract biologist's attention and thrive here like what it develops in industry and computer science.\n\n# The end\n\nAs planed at the beginning, the following posts would be on machine learning. Coming soon!\n\n","source":"_posts/2019-02-01-Machinelearningseries1.md","raw":"---\ntitle: \"Machine learning on biology S1: model classification via ML\"\ncategories: [Research,Machine learning,Deep learning]\ntags: [Python, Machine learning, neural networks, GPU programming]\ndate: 2019-02-01\n\n---\n\nOn my 2nd Phd project, I have constructed a complex trait-population model to describe how species evolve and assemble in a community under natural selection. However, people may naturally ask if such complexity is really needed. What is the discrepancy between the model with and without population dynamics and variable trait variance? To answer this question, a model selection/classification should be performed on the data generated under those candidate models. As what we used in parameter inference, an [Approximate Bayesian Computation-Sequential Monte Carlo method](https://xl0418.github.io/2018/11/30/2018-11-30-SMCplots/) is able to handle this work. However, a huge computational demanding is the bottle neck.  To avoid to waste time on fitting each empirical data set by ABC-SMC, a method that only uses the feature of data sets would be a better choice. This reminds me the existing and fast-developed took, i.e. machine learning. So, from this post on, I would like to share my experience of learning Machine Leaning, how to construct a neural network, how to derive backwards propagation algorithm for leaning parameters of a neural network and how to use tensorflow to simply use machine learning, or even deep learning (a multiple-layer neural network algorithm), to do model selection/classification on the topic I mentioned above. \n\n<!--more-->\n \n# A fast illustration\n\nPresenting application at first would be concrete for people understand what I am talking about. Here in this simple example, I generated 200K data sets for each of the four models, i.e. Brownian Motion model, Ornstein Uhlenbeck (OU) model, Trait-population model, anti-Ornstein Uhlenbeck model. As a preliminary test, I just adjusted the parameter values for \\\\(\\\\gamma\\\\) and \\\\(\\\\alpha\\\\) to stand for 4 models, i.e. when \\\\(\\\\gamma=0,\\\\alpha=0\\\\) it stands for a Brownian Motion model; when \\\\(\\\\gamma>0,\\\\alpha=0\\\\) it stands for an OU model; when \\\\(\\\\gamma=0,\\\\alpha>0\\\\) it stands for an anti-OU model; when \\\\(\\\\gamma>0,\\\\alpha>0\\\\) it stands for a trait-population evolution (TP) model. I didn't remove population dynamics from the BM and OU model. Therefore, the data generated by those two processes would be more alike to TP model than by the standard BM and OU model. The logic behind is that if the learning neural network can distinguish TP from the other 3 models, it is able to pick TP out from model pile with standard BM and OU model. Note that the anti-OU model is similar to Drury et al. model in 2018. \n\nWhen the parameter is nonzero, I simply randomly chose values as I assume we don't know any prior information from the empirical data. \n\nI used in total around 1000K data sets that are randomly generated under 4 models but labeled with correct model names to train a simply three-layer neural network. It is super fast to train such small network and can be done within few minutes. Note that fitting data via ABC-SMC may coat a few days with 30 iterations and 200K particles for each iteration. Then I generated 100 data sets to feed the trained neural network. The generating models are known in advance. The purpose of this test is to check if the trained network is able to recognize the generating models. \n\n# A preliminary result\n\nThe result is shown below:\n\n![fig](2019-02-01-Machinelearningseries1/modelselection1.png)   \n\nEach chart contains four bars indicating the probability of each model (B: BM; O: OU; T: TP; A: Anti-OU). Color red denotes that the prediction of the network is wrong. Otherwise, the highest bar correctly implies the generating model. The results reveal that BM and OU model are confusing to the trained neural network. This makes sense that because of the normalization of traits the output of these two models show no significant discrepancy, i.e. almost all traits are evenly distributed in the trait space. Only the range of the traits would provide some information, i.e. BM model has wider range for the traits than OU model. But the normalization neglects it. The other two models, TP and Anti-OU are nicely distinguishable from the model pile. This indicates that the trait-population model do have significant pattern to express itself. Thus our complexity plays a role in describing trait patterns. \n\n# Future plan\n\nHere in the example, I only exploited a 3-layer neural network but already got a nice result. The issues of confusing BM and OU model may be resolved if a deep neural network is applied. Anyway, the power of machine learning on biology is shown and there are more improvement space waiting for further study.\n\nI do believe that machine learning can be useful in biology. But so far as I know, few literature present this tech on biology field. In fact, data analysis and pattern recognition are also key component in biological research besides modeling. I hope machine learning could attract biologist's attention and thrive here like what it develops in industry and computer science.\n\n# The end\n\nAs planed at the beginning, the following posts would be on machine learning. Coming soon!\n\n","slug":"2019-02-01-Machinelearningseries1","published":1,"updated":"2022-09-17T02:04:05.125Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl85g865x00134gkr5nm07o1y","content":"<p>On my 2nd Phd project, I have constructed a complex trait-population model to describe how species evolve and assemble in a community under natural selection. However, people may naturally ask if such complexity is really needed. What is the discrepancy between the model with and without population dynamics and variable trait variance? To answer this question, a model selection&#x2F;classification should be performed on the data generated under those candidate models. As what we used in parameter inference, an <a href=\"https://xl0418.github.io/2018/11/30/2018-11-30-SMCplots/\">Approximate Bayesian Computation-Sequential Monte Carlo method</a> is able to handle this work. However, a huge computational demanding is the bottle neck.  To avoid to waste time on fitting each empirical data set by ABC-SMC, a method that only uses the feature of data sets would be a better choice. This reminds me the existing and fast-developed took, i.e. machine learning. So, from this post on, I would like to share my experience of learning Machine Leaning, how to construct a neural network, how to derive backwards propagation algorithm for leaning parameters of a neural network and how to use tensorflow to simply use machine learning, or even deep learning (a multiple-layer neural network algorithm), to do model selection&#x2F;classification on the topic I mentioned above. </p>\n<span id=\"more\"></span>\n<h1 id=\"A-fast-illustration\"><a href=\"#A-fast-illustration\" class=\"headerlink\" title=\"A fast illustration\"></a>A fast illustration</h1><p>Presenting application at first would be concrete for people understand what I am talking about. Here in this simple example, I generated 200K data sets for each of the four models, i.e. Brownian Motion model, Ornstein Uhlenbeck (OU) model, Trait-population model, anti-Ornstein Uhlenbeck model. As a preliminary test, I just adjusted the parameter values for \\(\\gamma\\) and \\(\\alpha\\) to stand for 4 models, i.e. when \\(\\gamma&#x3D;0,\\alpha&#x3D;0\\) it stands for a Brownian Motion model; when \\(\\gamma&gt;0,\\alpha&#x3D;0\\) it stands for an OU model; when \\(\\gamma&#x3D;0,\\alpha&gt;0\\) it stands for an anti-OU model; when \\(\\gamma&gt;0,\\alpha&gt;0\\) it stands for a trait-population evolution (TP) model. I didn’t remove population dynamics from the BM and OU model. Therefore, the data generated by those two processes would be more alike to TP model than by the standard BM and OU model. The logic behind is that if the learning neural network can distinguish TP from the other 3 models, it is able to pick TP out from model pile with standard BM and OU model. Note that the anti-OU model is similar to Drury et al. model in 2018. </p>\n<p>When the parameter is nonzero, I simply randomly chose values as I assume we don’t know any prior information from the empirical data. </p>\n<p>I used in total around 1000K data sets that are randomly generated under 4 models but labeled with correct model names to train a simply three-layer neural network. It is super fast to train such small network and can be done within few minutes. Note that fitting data via ABC-SMC may coat a few days with 30 iterations and 200K particles for each iteration. Then I generated 100 data sets to feed the trained neural network. The generating models are known in advance. The purpose of this test is to check if the trained network is able to recognize the generating models. </p>\n<h1 id=\"A-preliminary-result\"><a href=\"#A-preliminary-result\" class=\"headerlink\" title=\"A preliminary result\"></a>A preliminary result</h1><p>The result is shown below:</p>\n<p><img src=\"/2019-02-01-Machinelearningseries1/modelselection1.png\" alt=\"fig\">   </p>\n<p>Each chart contains four bars indicating the probability of each model (B: BM; O: OU; T: TP; A: Anti-OU). Color red denotes that the prediction of the network is wrong. Otherwise, the highest bar correctly implies the generating model. The results reveal that BM and OU model are confusing to the trained neural network. This makes sense that because of the normalization of traits the output of these two models show no significant discrepancy, i.e. almost all traits are evenly distributed in the trait space. Only the range of the traits would provide some information, i.e. BM model has wider range for the traits than OU model. But the normalization neglects it. The other two models, TP and Anti-OU are nicely distinguishable from the model pile. This indicates that the trait-population model do have significant pattern to express itself. Thus our complexity plays a role in describing trait patterns. </p>\n<h1 id=\"Future-plan\"><a href=\"#Future-plan\" class=\"headerlink\" title=\"Future plan\"></a>Future plan</h1><p>Here in the example, I only exploited a 3-layer neural network but already got a nice result. The issues of confusing BM and OU model may be resolved if a deep neural network is applied. Anyway, the power of machine learning on biology is shown and there are more improvement space waiting for further study.</p>\n<p>I do believe that machine learning can be useful in biology. But so far as I know, few literature present this tech on biology field. In fact, data analysis and pattern recognition are also key component in biological research besides modeling. I hope machine learning could attract biologist’s attention and thrive here like what it develops in industry and computer science.</p>\n<h1 id=\"The-end\"><a href=\"#The-end\" class=\"headerlink\" title=\"The end\"></a>The end</h1><p>As planed at the beginning, the following posts would be on machine learning. Coming soon!</p>\n","site":{"data":{}},"excerpt":"<p>On my 2nd Phd project, I have constructed a complex trait-population model to describe how species evolve and assemble in a community under natural selection. However, people may naturally ask if such complexity is really needed. What is the discrepancy between the model with and without population dynamics and variable trait variance? To answer this question, a model selection&#x2F;classification should be performed on the data generated under those candidate models. As what we used in parameter inference, an <a href=\"https://xl0418.github.io/2018/11/30/2018-11-30-SMCplots/\">Approximate Bayesian Computation-Sequential Monte Carlo method</a> is able to handle this work. However, a huge computational demanding is the bottle neck.  To avoid to waste time on fitting each empirical data set by ABC-SMC, a method that only uses the feature of data sets would be a better choice. This reminds me the existing and fast-developed took, i.e. machine learning. So, from this post on, I would like to share my experience of learning Machine Leaning, how to construct a neural network, how to derive backwards propagation algorithm for leaning parameters of a neural network and how to use tensorflow to simply use machine learning, or even deep learning (a multiple-layer neural network algorithm), to do model selection&#x2F;classification on the topic I mentioned above. </p>","more":"<h1 id=\"A-fast-illustration\"><a href=\"#A-fast-illustration\" class=\"headerlink\" title=\"A fast illustration\"></a>A fast illustration</h1><p>Presenting application at first would be concrete for people understand what I am talking about. Here in this simple example, I generated 200K data sets for each of the four models, i.e. Brownian Motion model, Ornstein Uhlenbeck (OU) model, Trait-population model, anti-Ornstein Uhlenbeck model. As a preliminary test, I just adjusted the parameter values for \\(\\gamma\\) and \\(\\alpha\\) to stand for 4 models, i.e. when \\(\\gamma&#x3D;0,\\alpha&#x3D;0\\) it stands for a Brownian Motion model; when \\(\\gamma&gt;0,\\alpha&#x3D;0\\) it stands for an OU model; when \\(\\gamma&#x3D;0,\\alpha&gt;0\\) it stands for an anti-OU model; when \\(\\gamma&gt;0,\\alpha&gt;0\\) it stands for a trait-population evolution (TP) model. I didn’t remove population dynamics from the BM and OU model. Therefore, the data generated by those two processes would be more alike to TP model than by the standard BM and OU model. The logic behind is that if the learning neural network can distinguish TP from the other 3 models, it is able to pick TP out from model pile with standard BM and OU model. Note that the anti-OU model is similar to Drury et al. model in 2018. </p>\n<p>When the parameter is nonzero, I simply randomly chose values as I assume we don’t know any prior information from the empirical data. </p>\n<p>I used in total around 1000K data sets that are randomly generated under 4 models but labeled with correct model names to train a simply three-layer neural network. It is super fast to train such small network and can be done within few minutes. Note that fitting data via ABC-SMC may coat a few days with 30 iterations and 200K particles for each iteration. Then I generated 100 data sets to feed the trained neural network. The generating models are known in advance. The purpose of this test is to check if the trained network is able to recognize the generating models. </p>\n<h1 id=\"A-preliminary-result\"><a href=\"#A-preliminary-result\" class=\"headerlink\" title=\"A preliminary result\"></a>A preliminary result</h1><p>The result is shown below:</p>\n<p><img src=\"/2019-02-01-Machinelearningseries1/modelselection1.png\" alt=\"fig\">   </p>\n<p>Each chart contains four bars indicating the probability of each model (B: BM; O: OU; T: TP; A: Anti-OU). Color red denotes that the prediction of the network is wrong. Otherwise, the highest bar correctly implies the generating model. The results reveal that BM and OU model are confusing to the trained neural network. This makes sense that because of the normalization of traits the output of these two models show no significant discrepancy, i.e. almost all traits are evenly distributed in the trait space. Only the range of the traits would provide some information, i.e. BM model has wider range for the traits than OU model. But the normalization neglects it. The other two models, TP and Anti-OU are nicely distinguishable from the model pile. This indicates that the trait-population model do have significant pattern to express itself. Thus our complexity plays a role in describing trait patterns. </p>\n<h1 id=\"Future-plan\"><a href=\"#Future-plan\" class=\"headerlink\" title=\"Future plan\"></a>Future plan</h1><p>Here in the example, I only exploited a 3-layer neural network but already got a nice result. The issues of confusing BM and OU model may be resolved if a deep neural network is applied. Anyway, the power of machine learning on biology is shown and there are more improvement space waiting for further study.</p>\n<p>I do believe that machine learning can be useful in biology. But so far as I know, few literature present this tech on biology field. In fact, data analysis and pattern recognition are also key component in biological research besides modeling. I hope machine learning could attract biologist’s attention and thrive here like what it develops in industry and computer science.</p>\n<h1 id=\"The-end\"><a href=\"#The-end\" class=\"headerlink\" title=\"The end\"></a>The end</h1><p>As planed at the beginning, the following posts would be on machine learning. Coming soon!</p>"},{"title":"Machine learning on biology S2: how does a neural network work mathematically?","date":"2019-02-08T08:00:00.000Z","_content":"\nThere are tons of documents out there to explain how neural network works in different angles. So I guess people don't mind me adding one more from my perspective. Hopefully, someone may get inspired from this post.\n\n<!--more-->\n\nIn short, the neural network is a kind of system that transforms the input data into its corresponding output (or labels), strictly speaking, for a supervised learning. This system is consisting of three types of layers, i.e. the input layer, the hidden layer and the output layer. Normally, the hidden layer may have multiple layers according to one's design. Among layers, the data from the upper layer are transformed to the data in the lower layer via a linear combination with an initialized weight matrix. After that, a nonlinear transformation that is generally called the activation function is applied to the data that would be converted to a form for the next round until reaching the output layer. To assure the neural network feedback the correct output, people need to train the neural network by adjusting the weight matrix. They are usually adjusted via minimizing the error between the output from the final layer and the known output from the data used for training. \n\nWithout loss of generality, here I consider a simplest neural network which only possesses fully connected layers, meaning that every neuron in each layer connects all neurons of the upper and lower layers. The mathematical logic behind is analogous to other structures of neural network. Firstly, I used a series of graphs to illustrate how the data flows to the final layer and introduce the notations used in the derivation. Then, a general formulation is present subsequently.\n\n# A 6-layer neural network \n\nThe following four graphs illustrate how the data evolves along the neural network and the notations used in the derivation.\n\n![fig](2019-02-08-Machinelearningseries2/step1.png)    \n\n![fig](2019-02-08-Machinelearningseries2/step2.png)    \n\n![fig](2019-02-08-Machinelearningseries2/step3.png)    \n\n![fig](2019-02-08-Machinelearningseries2/step4.png)   \n\n![fig](2019-02-08-Machinelearningseries2/step5.png) \n\n![fig](2019-02-08-Machinelearningseries2/step8.png)         \n\n![fig](2019-02-08-Machinelearningseries2/step7.png)     \n\n![fig](2019-02-08-Machinelearningseries2/step6.png)     \n\n\n\n# 1 Forward flow of the neural network\n\nConsider a neural network with \\\\(k+1\\\\) layers including the input layer and the output layer. The input data is consisting of \\\\(n\\\\) samples with \\\\(L_{1}\\\\) features\n\n![fig](2019-02-08-Machinelearningseries2/1.png)   \n\nThe output label is given accordingly\n\n![fig](2019-02-08-Machinelearningseries2/2.png)   \n\nwhere the label on the top left denotes the index of the sample. Too abstract? Imagine that sample \\\\(^{1}\\boldsymbol{x}\\\\) corresponds to model 1 while sample \\\\(^{2}\\boldsymbol{x}\\\\) corresponds to model 2. Then the output can be either an array of two vectors indicating the probabilities of model 1 and model 2, for example, \\\\(\\{(1,0),(0,1)\\}\\\\), or a vector of two elements \\\\(\\{0,1\\}\\\\) where 0 indicates model 1 and 1 indicates model 2 or whatever you label them. The purpose is to use a huge amount of data sets to train the neural network, more precisely to compute the weight matrix among the adjacent pair of layers, to fit the output layer to the output vectors. Will see it later on.\n\nNow, let's feed one sample (the first one \\\\(^{1}\\boldsymbol{x}\\\\)) to the neural network to see how to compute the output layer. Later, we will see how to train the network with multiple samples. Assume the second layer has \\\\(L_{2}\\\\) neurons\n\n![fig](2019-02-08-Machinelearningseries2/3.png)   \n\nNote that the first layer is the input layer in which we feed one sample with \\\\(L_{1}\\\\) feature to the neural network at first. Then the weight matrix from the first layer to the second layer is defined as \n\n![fig](2019-02-08-Machinelearningseries2/4.png)   \n\nThus, multiplying the weight matrix Eq.4 with the neurons of the upper layer Eq.3 yields\n\n![fig](2019-02-08-Machinelearningseries2/5.png)   \n\nMore generally, a bias term (constant term) is incorporated as follows\n\n![fig](2019-02-08-Machinelearningseries2/6.png) \n\nwhich can also be written in the form if we absorb the constant vector \\\\(\\boldsymbol{b}_{1}\\\\) into the weight matrix  \n\n![fig](2019-02-08-Machinelearningseries2/78.png) \n\nAfter the transformation, an activation function is applied to \\\\(\\boldsymbol{z}^{(2)}\\\\) elementwisely. For a model classification problem, the sigmoid function and the hyperbolic tangent function are widely used. Here we use the sigmoid function for instance\n\n![fig](2019-02-08-Machinelearningseries2/9.png) \n\nTill now, the transformation from the first layer (the input layer) to the second layer (the first hidden layer) is done. This process can be generalized as .\n\n![fig](2019-02-08-Machinelearningseries2/9-1.png) \n\nwhere \\\\(\\boldsymbol{a}'\\\\) is the vector \\\\(\\boldsymbol{a}\\\\) absorbing 1 at the end as what I did in Eq.8. Note that \\\\(\\boldsymbol{a}^{(1)}=^{1}\\boldsymbol{x}\\\\).\n\nFinally, the neural network will return \\\\(\\boldsymbol{a}^{(k+1)}\\\\) with \\\\(L_{k+1}\\\\) elements from the output layer. Given the corresponding output label \\\\(\\boldsymbol{y}^{(1)}\\\\), we can compute the error between the feedback \\\\(\\boldsymbol{a}^{(k+1)}\\\\) and the output label \\\\(\\boldsymbol{y}^{(1)}\\\\). This is normally called the loss of the result to the output. There are several candidate loss functions for model classification like the least square, the cross-entropy function. We take the least square function as the example\n\n![fig](2019-02-08-Machinelearningseries2/10.png) \n\nSo far, we have computed out the loss of the neural network with a bunch of randomly initialized weight matrix. No doubt, the loss would be huge. Our aim is to minimized the loss \\\\(J\\\\) by tuning the weight matrix. How? Remember your advanced calculus in the high school or the university? \\\\(J\\\\) can be envisaged as a function of every entry in the weight matrix that we want to adjust. Thus, the derivative of \\\\(J\\\\) with respect to each entries of the weight matrix would tell us how to tune the weight matrix to minimize the loss. This method is called gradient descend. And the loss can also propagate backwards to determine the gradient of the entries of the weight matrix at each layer. The full process to tune the weight matrix is also called Backward Propagation. \n\n\n# 2 Backward propagation\n## From the \\\\(k+1\\\\)th layer to the \\\\(k\\\\)th layer\n\nLet us start from the final layer (the \\\\(k+1\\\\)th layer) to the previous one (the \\\\(k\\\\)th layer). Note that the variable of our concern is the entry of the weight matrix from the \\\\(k\\\\)th layer to the \\\\(k+1\\\\)th layer, \\\\(\\theta_{L_{k+1}\\times L_{k}}^{(k)}\\\\). Here I only consider tuning \\\\(\\theta\\\\) instead of \\\\(\\theta'\\\\), meaning that the bias terms are not tuned. Updating the bias terms is similar and you can practice it afterward. The derivative of the loss function with respect to the matrix is defined as \n\n![fig](2019-02-08-Machinelearningseries2/11.png) \n\nAt the mean time, from the loss function Eq.10, we obtain the derivative according to the chain rule\n\n![fig](2019-02-08-Machinelearningseries2/12.png) \n\nwhere\n\n![fig](2019-02-08-Machinelearningseries2/13-15.png) \n\nand\n\n![fig](2019-02-08-Machinelearningseries2/16.png) \n\nwhere \\\\(\\otimes\\\\) is the outer product. Simplifying the gradient Eq.12 yields\n\n![fig](2019-02-08-Machinelearningseries2/17.png) \n\nIf we define\n\n![fig](2019-02-08-Machinelearningseries2/18.png) \n\nThe gradient Eq.17 can be further simplified as\n\n![fig](2019-02-08-Machinelearningseries2/19.png) \n\nNote that we define the outer product of two column vectors is the element-wise produce of the corresponding elements\n\n![fig](2019-02-08-Machinelearningseries2/19-1.png) \n\nNow, as \\\\(\\boldsymbol{z}^{(k+1)}\\\\), \\\\(\\boldsymbol{a}^{(k+1)}\\\\) and \\\\(^{1}\\boldsymbol{y}\\\\) are known, we can update the weight matrix \\\\(\\theta^{(k)}\\\\) by\n\n![fig](2019-02-08-Machinelearningseries2/20.png) \n\nwhere \\\\(\\lambda\\\\) is a constant called the learning rate given in advance. \n\n## From the \\\\(k\\\\)th layer to the \\\\(k-1\\\\)th layer\n\nLet's do the calculation one more time from the \\\\(k\\\\)th layer to the \\\\(k-1\\\\)th layer. At the end of this section, we will get a general formula to update all weight matrix via which we can develop the algorithm for a deep neural network. \n\nNow we consider one more previous weight matrix \\\\(\\theta^{(k-1)}\\\\). The derivative of the loss function with respect to that matrix yields \n\n![fig](2019-02-08-Machinelearningseries2/21.png) \n\nThe first two terms on the right hand side are the same as Eq.12. The third term \\\\(\\frac{\\partial\\boldsymbol{z}^{(k+1)}}{\\partial\\boldsymbol{a}^{(k)}}\\\\) produces the weight matrix from the \\\\(k+1\\\\)th layer to the \\\\(k\\\\)th layer\n\n![fig](2019-02-08-Machinelearningseries2/22.png) \n\nThe last two terms on the right hand side are similar to what we have done above. Finally, we get\n\n![fig](2019-02-08-Machinelearningseries2/23.png) \n\nComparing Eq.19 and Eq.23 tells us that we can update the error\n\n![fig](2019-02-08-Machinelearningseries2/24.png) \n\nfor each transition among layers. This is how the error propagates backwards along the neural network and where the name comes from. Note that this expression is a slightly different from the formula in Chapter 9.2 of the [machine learning course](https://www.coursera.org/course/ml) by Andrew Ng of Standford. Do you see why is that? \n\n# 3 Training multiple samples\n\nWe have derived mathematically how to train one sample on a neural network. How about multiple samples? Easy. Because all the weight matrix of the neural network are shared for all samples, we can update the weight matrix by a fraction of error of each sample. Normally this fraction is \\\\(\\frac{1}{\\text{sample size}}\\\\) where in our example the sample size is \\\\(n\\\\)\n\n![fig](2019-02-08-Machinelearningseries2/25.png) \n\nThen, the weight matrix is tuned to minimize the error of samples. \n\n# 4 Program a neural network \n\nTill now, we have derived a general formula Eq.23 to allow us to update all weight matrix. After updating, the loss function is applied again to examine if the error is sufficiently small. If not, update the weight matrix again till meeting our criterion. Understanding the math behind is a huge step towards the expert level but not the final one. Whether you can equip it via code is essential. Here I attached my code in Python from my perspective as a reference. The user can add any number of hidden layers and deploy any number of neurons there. It is a bit like a minimalistic version of tensorflow. \n\n```Python\nimport numpy as np\nimport pandas as pd\n\nclass neuralnetwork:\n    # initialize parameters\n    def __init__(self,num_sample,num_hidden_layer_units,num_input_feature,num_output_feature,bias,learningrate):\n        self.learningrate=learningrate # learning rate\n        self.num_sample = num_sample  # number of the samples\n        self.num_hidden_layer_units = num_hidden_layer_units # a list indicating the number of hidden layers and how many neurons for each layer\n        self.num_hidden_layer = len(num_hidden_layer_units) # the number of the hidden layers\n        self.weight_layer = []  # initialize the weight matrix\n        self.bias = bias   # bias for the input layer and for the hidden layers\n        assert len(self.bias) == self.num_hidden_layer+1, \"The length of the biases should equal the length of the hidden layers plus 1!!!\"\n        self.units = [num_input_feature] + num_hidden_layer_units + [num_output_feature]\n        # randomly initialize the weight matrix\n        for num_layer in range(0,len(self.units)-1):\n            temp_bias = np.zeros((1,self.units[num_layer+1]))\n            temp_bias.fill(self.bias[num_layer])\n            self.weight_layer.append(np.concatenate((np.random.randn(self.units[num_layer+1],\n                                                self.units[num_layer]),temp_bias.T),axis = 1))\n\n    # the activation function: sigmoid\n    # could be replaced by whatever you want\n    def sigmoid(self,x):\n        y = 1/(1+np.exp(-x))\n        return y\n\n    # train function requires the training data, accuracy and iteration limit\n    def train(self, input, output,accuracy, iteration_limit):\n        go_on = True\n        i = 0 # iteration indicator\n        error = []  # error list recoding errors for all iterations\n        iteration = []\n        while go_on:\n            iteration.append(i)\n            error_acc = 0   # initialize error for every iteration\n            stderror = []   # standard error\n            sample_Z = []   # Z value of neurons for every sample\n            sample_a = []   # sigmoid value of Z for every sample\n            # loop all samples\n            for sample_iter in range(self.num_sample):\n                Zlayer = []\n                a = []\n                a.append(input[sample_iter])    # place the input as the first a value\n                # forward computing Z and a values for all layers\n                for forward_layer in range(len(self.units)-1):\n                    Zlayer.append(np.matmul(self.weight_layer[forward_layer], np.concatenate((a[forward_layer],[1]))))\n                    a.append(self.sigmoid(Zlayer[forward_layer]))\n                # standard error by computing the distance between output layer and true output\n                stderror.append(a[len(a)-1]-output[sample_iter])\n                # loss function defined as the sum of the least square\n                # can be replaced by other functions like cross-entropy\n                error_acc += (1/2*np.sum((stderror[sample_iter])**2))\n                sample_a.append(a)  # store a values for updating\n                sample_Z.append(Zlayer) # store Z values for updating\n            error.append(error_acc) # store error for this iteration\n\n            # backward propagate errors to update the weight matrix\n            i += 1\n            if error[i-1] <accuracy or i >iteration_limit:\n                go_on = False\n            else:\n                for sample_iter in range(self.num_sample):\n                    delta = stderror[sample_iter]  # delta: standard error defined as the derivative of the loss function\n                    # initialize g'(z): the derivative of the activation function at the output layer\n                    deriv_sigmoid =  sample_a[sample_iter][len(sample_a[sample_iter])-1] *\\\n                                 (1 - sample_a[sample_iter][len(sample_a[sample_iter])-1])\n                    # backward propagation\n                    for backward_layer in list(reversed(range(len(self.units)-1))):\n                        temp_weight = self.weight_layer[backward_layer] # store the temporary kth matrix\n                        # update the kth matrix\n                        self.weight_layer[backward_layer][:,:-1] += - self.learningrate/self.num_sample *\\\n                            np.outer(delta * deriv_sigmoid, sample_a[sample_iter][backward_layer])\n                        # update delta and derivative of the activation function\n                        delta = np.dot(temp_weight[:,:-1].T,delta * deriv_sigmoid)\n                        deriv_sigmoid = sample_a[sample_iter][backward_layer] *\\\n                                 (1 - sample_a[sample_iter][backward_layer])\n        self.learningspeed = {'error': error, 'iteration': iteration}\n        self.lsdf = pd.DataFrame(self.learningspeed)\n        return sample_a, self.weight_layer\n\n    # predict\n    def predict(self,input,weight):\n        out = input+[1]\n        for i in range(len(weight)):\n            out = np.dot(weight[i],np.array(out))\n            out = self.sigmoid(out)\n            out = np.concatenate((out,[1]))\n        return out[:-1]\n\n\n# test\ninputx = np.array(([0.2, 0.5, 0.5,0.3], [0.1, 0.2, 0.15,0.1],[0.7,0.9,0.4,0.8]))\noutputy = np.array(([0.5, 0.4], [0.9, 0.1],[0.3,0.5]))\n\n# build the neural network\nnn=neuralnetwork(num_sample=inputx.shape[0],num_hidden_layer_units=[15,14,15,16],num_input_feature=inputx.shape[1],\n             num_output_feature=outputy.shape[1], bias=[0.1,0.2,0.3,0.4,0.4],learningrate=0.2)\n\n# set the accuracy and the iteration limit\nacc = 1e-7\niter = 20000\n# train the neural network\nout_a,weight = nn.train(inputx,outputy,accuracy = acc,iteration_limit=iter)\n# plot the learning process\nnn.lsdf.plot(x='iteration',y='error')\n\n# predict\ninput = [0.19, 0.51, 0.49,0.29]\nout = nn.predict(input,weight)\n\n```\n\nYou can also clone it [on my Github](https://github.com/xl0418/Tensorflow/blob/master/NeuralNetwork.py) \n\n# The end\n\nMy code is obviously not the most efficient one as a lot of loops are used. But in another sense it is easy to read for a starter. As you see in the derivation and in the code, there are a huge amount of independent computing that can be parallelized to speed up. So the future plan is to parallelize the code on GPU which may substantially improve the efficiency of the neural network. It would also be a good practice for you to step into the machine learning field. \n\n# Reference\n\n- An introduction to the math used in Machine Learning:  [The Matrix Calculus You Need For Deep Learning\n](https://explained.ai/matrix-calculus/index.html).\n\n- A concrete derivation of backward propagation for a two-layer neural network in Chinese [here](http://www.cnblogs.com/charlotte77/p/5629865.html#!comments).","source":"_posts/2019-02-08-Machinelearningseries2.md","raw":"---\ntitle: \"Machine learning on biology S2: how does a neural network work mathematically?\"\ncategories: [Research,Machine learning,Deep learning]\ntags: [Python, Machine learning, neural networks, Backward propagation, gradient descent]\ndate: 2019-02-08\n\n---\n\nThere are tons of documents out there to explain how neural network works in different angles. So I guess people don't mind me adding one more from my perspective. Hopefully, someone may get inspired from this post.\n\n<!--more-->\n\nIn short, the neural network is a kind of system that transforms the input data into its corresponding output (or labels), strictly speaking, for a supervised learning. This system is consisting of three types of layers, i.e. the input layer, the hidden layer and the output layer. Normally, the hidden layer may have multiple layers according to one's design. Among layers, the data from the upper layer are transformed to the data in the lower layer via a linear combination with an initialized weight matrix. After that, a nonlinear transformation that is generally called the activation function is applied to the data that would be converted to a form for the next round until reaching the output layer. To assure the neural network feedback the correct output, people need to train the neural network by adjusting the weight matrix. They are usually adjusted via minimizing the error between the output from the final layer and the known output from the data used for training. \n\nWithout loss of generality, here I consider a simplest neural network which only possesses fully connected layers, meaning that every neuron in each layer connects all neurons of the upper and lower layers. The mathematical logic behind is analogous to other structures of neural network. Firstly, I used a series of graphs to illustrate how the data flows to the final layer and introduce the notations used in the derivation. Then, a general formulation is present subsequently.\n\n# A 6-layer neural network \n\nThe following four graphs illustrate how the data evolves along the neural network and the notations used in the derivation.\n\n![fig](2019-02-08-Machinelearningseries2/step1.png)    \n\n![fig](2019-02-08-Machinelearningseries2/step2.png)    \n\n![fig](2019-02-08-Machinelearningseries2/step3.png)    \n\n![fig](2019-02-08-Machinelearningseries2/step4.png)   \n\n![fig](2019-02-08-Machinelearningseries2/step5.png) \n\n![fig](2019-02-08-Machinelearningseries2/step8.png)         \n\n![fig](2019-02-08-Machinelearningseries2/step7.png)     \n\n![fig](2019-02-08-Machinelearningseries2/step6.png)     \n\n\n\n# 1 Forward flow of the neural network\n\nConsider a neural network with \\\\(k+1\\\\) layers including the input layer and the output layer. The input data is consisting of \\\\(n\\\\) samples with \\\\(L_{1}\\\\) features\n\n![fig](2019-02-08-Machinelearningseries2/1.png)   \n\nThe output label is given accordingly\n\n![fig](2019-02-08-Machinelearningseries2/2.png)   \n\nwhere the label on the top left denotes the index of the sample. Too abstract? Imagine that sample \\\\(^{1}\\boldsymbol{x}\\\\) corresponds to model 1 while sample \\\\(^{2}\\boldsymbol{x}\\\\) corresponds to model 2. Then the output can be either an array of two vectors indicating the probabilities of model 1 and model 2, for example, \\\\(\\{(1,0),(0,1)\\}\\\\), or a vector of two elements \\\\(\\{0,1\\}\\\\) where 0 indicates model 1 and 1 indicates model 2 or whatever you label them. The purpose is to use a huge amount of data sets to train the neural network, more precisely to compute the weight matrix among the adjacent pair of layers, to fit the output layer to the output vectors. Will see it later on.\n\nNow, let's feed one sample (the first one \\\\(^{1}\\boldsymbol{x}\\\\)) to the neural network to see how to compute the output layer. Later, we will see how to train the network with multiple samples. Assume the second layer has \\\\(L_{2}\\\\) neurons\n\n![fig](2019-02-08-Machinelearningseries2/3.png)   \n\nNote that the first layer is the input layer in which we feed one sample with \\\\(L_{1}\\\\) feature to the neural network at first. Then the weight matrix from the first layer to the second layer is defined as \n\n![fig](2019-02-08-Machinelearningseries2/4.png)   \n\nThus, multiplying the weight matrix Eq.4 with the neurons of the upper layer Eq.3 yields\n\n![fig](2019-02-08-Machinelearningseries2/5.png)   \n\nMore generally, a bias term (constant term) is incorporated as follows\n\n![fig](2019-02-08-Machinelearningseries2/6.png) \n\nwhich can also be written in the form if we absorb the constant vector \\\\(\\boldsymbol{b}_{1}\\\\) into the weight matrix  \n\n![fig](2019-02-08-Machinelearningseries2/78.png) \n\nAfter the transformation, an activation function is applied to \\\\(\\boldsymbol{z}^{(2)}\\\\) elementwisely. For a model classification problem, the sigmoid function and the hyperbolic tangent function are widely used. Here we use the sigmoid function for instance\n\n![fig](2019-02-08-Machinelearningseries2/9.png) \n\nTill now, the transformation from the first layer (the input layer) to the second layer (the first hidden layer) is done. This process can be generalized as .\n\n![fig](2019-02-08-Machinelearningseries2/9-1.png) \n\nwhere \\\\(\\boldsymbol{a}'\\\\) is the vector \\\\(\\boldsymbol{a}\\\\) absorbing 1 at the end as what I did in Eq.8. Note that \\\\(\\boldsymbol{a}^{(1)}=^{1}\\boldsymbol{x}\\\\).\n\nFinally, the neural network will return \\\\(\\boldsymbol{a}^{(k+1)}\\\\) with \\\\(L_{k+1}\\\\) elements from the output layer. Given the corresponding output label \\\\(\\boldsymbol{y}^{(1)}\\\\), we can compute the error between the feedback \\\\(\\boldsymbol{a}^{(k+1)}\\\\) and the output label \\\\(\\boldsymbol{y}^{(1)}\\\\). This is normally called the loss of the result to the output. There are several candidate loss functions for model classification like the least square, the cross-entropy function. We take the least square function as the example\n\n![fig](2019-02-08-Machinelearningseries2/10.png) \n\nSo far, we have computed out the loss of the neural network with a bunch of randomly initialized weight matrix. No doubt, the loss would be huge. Our aim is to minimized the loss \\\\(J\\\\) by tuning the weight matrix. How? Remember your advanced calculus in the high school or the university? \\\\(J\\\\) can be envisaged as a function of every entry in the weight matrix that we want to adjust. Thus, the derivative of \\\\(J\\\\) with respect to each entries of the weight matrix would tell us how to tune the weight matrix to minimize the loss. This method is called gradient descend. And the loss can also propagate backwards to determine the gradient of the entries of the weight matrix at each layer. The full process to tune the weight matrix is also called Backward Propagation. \n\n\n# 2 Backward propagation\n## From the \\\\(k+1\\\\)th layer to the \\\\(k\\\\)th layer\n\nLet us start from the final layer (the \\\\(k+1\\\\)th layer) to the previous one (the \\\\(k\\\\)th layer). Note that the variable of our concern is the entry of the weight matrix from the \\\\(k\\\\)th layer to the \\\\(k+1\\\\)th layer, \\\\(\\theta_{L_{k+1}\\times L_{k}}^{(k)}\\\\). Here I only consider tuning \\\\(\\theta\\\\) instead of \\\\(\\theta'\\\\), meaning that the bias terms are not tuned. Updating the bias terms is similar and you can practice it afterward. The derivative of the loss function with respect to the matrix is defined as \n\n![fig](2019-02-08-Machinelearningseries2/11.png) \n\nAt the mean time, from the loss function Eq.10, we obtain the derivative according to the chain rule\n\n![fig](2019-02-08-Machinelearningseries2/12.png) \n\nwhere\n\n![fig](2019-02-08-Machinelearningseries2/13-15.png) \n\nand\n\n![fig](2019-02-08-Machinelearningseries2/16.png) \n\nwhere \\\\(\\otimes\\\\) is the outer product. Simplifying the gradient Eq.12 yields\n\n![fig](2019-02-08-Machinelearningseries2/17.png) \n\nIf we define\n\n![fig](2019-02-08-Machinelearningseries2/18.png) \n\nThe gradient Eq.17 can be further simplified as\n\n![fig](2019-02-08-Machinelearningseries2/19.png) \n\nNote that we define the outer product of two column vectors is the element-wise produce of the corresponding elements\n\n![fig](2019-02-08-Machinelearningseries2/19-1.png) \n\nNow, as \\\\(\\boldsymbol{z}^{(k+1)}\\\\), \\\\(\\boldsymbol{a}^{(k+1)}\\\\) and \\\\(^{1}\\boldsymbol{y}\\\\) are known, we can update the weight matrix \\\\(\\theta^{(k)}\\\\) by\n\n![fig](2019-02-08-Machinelearningseries2/20.png) \n\nwhere \\\\(\\lambda\\\\) is a constant called the learning rate given in advance. \n\n## From the \\\\(k\\\\)th layer to the \\\\(k-1\\\\)th layer\n\nLet's do the calculation one more time from the \\\\(k\\\\)th layer to the \\\\(k-1\\\\)th layer. At the end of this section, we will get a general formula to update all weight matrix via which we can develop the algorithm for a deep neural network. \n\nNow we consider one more previous weight matrix \\\\(\\theta^{(k-1)}\\\\). The derivative of the loss function with respect to that matrix yields \n\n![fig](2019-02-08-Machinelearningseries2/21.png) \n\nThe first two terms on the right hand side are the same as Eq.12. The third term \\\\(\\frac{\\partial\\boldsymbol{z}^{(k+1)}}{\\partial\\boldsymbol{a}^{(k)}}\\\\) produces the weight matrix from the \\\\(k+1\\\\)th layer to the \\\\(k\\\\)th layer\n\n![fig](2019-02-08-Machinelearningseries2/22.png) \n\nThe last two terms on the right hand side are similar to what we have done above. Finally, we get\n\n![fig](2019-02-08-Machinelearningseries2/23.png) \n\nComparing Eq.19 and Eq.23 tells us that we can update the error\n\n![fig](2019-02-08-Machinelearningseries2/24.png) \n\nfor each transition among layers. This is how the error propagates backwards along the neural network and where the name comes from. Note that this expression is a slightly different from the formula in Chapter 9.2 of the [machine learning course](https://www.coursera.org/course/ml) by Andrew Ng of Standford. Do you see why is that? \n\n# 3 Training multiple samples\n\nWe have derived mathematically how to train one sample on a neural network. How about multiple samples? Easy. Because all the weight matrix of the neural network are shared for all samples, we can update the weight matrix by a fraction of error of each sample. Normally this fraction is \\\\(\\frac{1}{\\text{sample size}}\\\\) where in our example the sample size is \\\\(n\\\\)\n\n![fig](2019-02-08-Machinelearningseries2/25.png) \n\nThen, the weight matrix is tuned to minimize the error of samples. \n\n# 4 Program a neural network \n\nTill now, we have derived a general formula Eq.23 to allow us to update all weight matrix. After updating, the loss function is applied again to examine if the error is sufficiently small. If not, update the weight matrix again till meeting our criterion. Understanding the math behind is a huge step towards the expert level but not the final one. Whether you can equip it via code is essential. Here I attached my code in Python from my perspective as a reference. The user can add any number of hidden layers and deploy any number of neurons there. It is a bit like a minimalistic version of tensorflow. \n\n```Python\nimport numpy as np\nimport pandas as pd\n\nclass neuralnetwork:\n    # initialize parameters\n    def __init__(self,num_sample,num_hidden_layer_units,num_input_feature,num_output_feature,bias,learningrate):\n        self.learningrate=learningrate # learning rate\n        self.num_sample = num_sample  # number of the samples\n        self.num_hidden_layer_units = num_hidden_layer_units # a list indicating the number of hidden layers and how many neurons for each layer\n        self.num_hidden_layer = len(num_hidden_layer_units) # the number of the hidden layers\n        self.weight_layer = []  # initialize the weight matrix\n        self.bias = bias   # bias for the input layer and for the hidden layers\n        assert len(self.bias) == self.num_hidden_layer+1, \"The length of the biases should equal the length of the hidden layers plus 1!!!\"\n        self.units = [num_input_feature] + num_hidden_layer_units + [num_output_feature]\n        # randomly initialize the weight matrix\n        for num_layer in range(0,len(self.units)-1):\n            temp_bias = np.zeros((1,self.units[num_layer+1]))\n            temp_bias.fill(self.bias[num_layer])\n            self.weight_layer.append(np.concatenate((np.random.randn(self.units[num_layer+1],\n                                                self.units[num_layer]),temp_bias.T),axis = 1))\n\n    # the activation function: sigmoid\n    # could be replaced by whatever you want\n    def sigmoid(self,x):\n        y = 1/(1+np.exp(-x))\n        return y\n\n    # train function requires the training data, accuracy and iteration limit\n    def train(self, input, output,accuracy, iteration_limit):\n        go_on = True\n        i = 0 # iteration indicator\n        error = []  # error list recoding errors for all iterations\n        iteration = []\n        while go_on:\n            iteration.append(i)\n            error_acc = 0   # initialize error for every iteration\n            stderror = []   # standard error\n            sample_Z = []   # Z value of neurons for every sample\n            sample_a = []   # sigmoid value of Z for every sample\n            # loop all samples\n            for sample_iter in range(self.num_sample):\n                Zlayer = []\n                a = []\n                a.append(input[sample_iter])    # place the input as the first a value\n                # forward computing Z and a values for all layers\n                for forward_layer in range(len(self.units)-1):\n                    Zlayer.append(np.matmul(self.weight_layer[forward_layer], np.concatenate((a[forward_layer],[1]))))\n                    a.append(self.sigmoid(Zlayer[forward_layer]))\n                # standard error by computing the distance between output layer and true output\n                stderror.append(a[len(a)-1]-output[sample_iter])\n                # loss function defined as the sum of the least square\n                # can be replaced by other functions like cross-entropy\n                error_acc += (1/2*np.sum((stderror[sample_iter])**2))\n                sample_a.append(a)  # store a values for updating\n                sample_Z.append(Zlayer) # store Z values for updating\n            error.append(error_acc) # store error for this iteration\n\n            # backward propagate errors to update the weight matrix\n            i += 1\n            if error[i-1] <accuracy or i >iteration_limit:\n                go_on = False\n            else:\n                for sample_iter in range(self.num_sample):\n                    delta = stderror[sample_iter]  # delta: standard error defined as the derivative of the loss function\n                    # initialize g'(z): the derivative of the activation function at the output layer\n                    deriv_sigmoid =  sample_a[sample_iter][len(sample_a[sample_iter])-1] *\\\n                                 (1 - sample_a[sample_iter][len(sample_a[sample_iter])-1])\n                    # backward propagation\n                    for backward_layer in list(reversed(range(len(self.units)-1))):\n                        temp_weight = self.weight_layer[backward_layer] # store the temporary kth matrix\n                        # update the kth matrix\n                        self.weight_layer[backward_layer][:,:-1] += - self.learningrate/self.num_sample *\\\n                            np.outer(delta * deriv_sigmoid, sample_a[sample_iter][backward_layer])\n                        # update delta and derivative of the activation function\n                        delta = np.dot(temp_weight[:,:-1].T,delta * deriv_sigmoid)\n                        deriv_sigmoid = sample_a[sample_iter][backward_layer] *\\\n                                 (1 - sample_a[sample_iter][backward_layer])\n        self.learningspeed = {'error': error, 'iteration': iteration}\n        self.lsdf = pd.DataFrame(self.learningspeed)\n        return sample_a, self.weight_layer\n\n    # predict\n    def predict(self,input,weight):\n        out = input+[1]\n        for i in range(len(weight)):\n            out = np.dot(weight[i],np.array(out))\n            out = self.sigmoid(out)\n            out = np.concatenate((out,[1]))\n        return out[:-1]\n\n\n# test\ninputx = np.array(([0.2, 0.5, 0.5,0.3], [0.1, 0.2, 0.15,0.1],[0.7,0.9,0.4,0.8]))\noutputy = np.array(([0.5, 0.4], [0.9, 0.1],[0.3,0.5]))\n\n# build the neural network\nnn=neuralnetwork(num_sample=inputx.shape[0],num_hidden_layer_units=[15,14,15,16],num_input_feature=inputx.shape[1],\n             num_output_feature=outputy.shape[1], bias=[0.1,0.2,0.3,0.4,0.4],learningrate=0.2)\n\n# set the accuracy and the iteration limit\nacc = 1e-7\niter = 20000\n# train the neural network\nout_a,weight = nn.train(inputx,outputy,accuracy = acc,iteration_limit=iter)\n# plot the learning process\nnn.lsdf.plot(x='iteration',y='error')\n\n# predict\ninput = [0.19, 0.51, 0.49,0.29]\nout = nn.predict(input,weight)\n\n```\n\nYou can also clone it [on my Github](https://github.com/xl0418/Tensorflow/blob/master/NeuralNetwork.py) \n\n# The end\n\nMy code is obviously not the most efficient one as a lot of loops are used. But in another sense it is easy to read for a starter. As you see in the derivation and in the code, there are a huge amount of independent computing that can be parallelized to speed up. So the future plan is to parallelize the code on GPU which may substantially improve the efficiency of the neural network. It would also be a good practice for you to step into the machine learning field. \n\n# Reference\n\n- An introduction to the math used in Machine Learning:  [The Matrix Calculus You Need For Deep Learning\n](https://explained.ai/matrix-calculus/index.html).\n\n- A concrete derivation of backward propagation for a two-layer neural network in Chinese [here](http://www.cnblogs.com/charlotte77/p/5629865.html#!comments).","slug":"2019-02-08-Machinelearningseries2","published":1,"updated":"2022-09-17T02:04:05.126Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl85g865x00154gkrfjxudrhj","content":"<p>There are tons of documents out there to explain how neural network works in different angles. So I guess people don’t mind me adding one more from my perspective. Hopefully, someone may get inspired from this post.</p>\n<span id=\"more\"></span>\n\n<p>In short, the neural network is a kind of system that transforms the input data into its corresponding output (or labels), strictly speaking, for a supervised learning. This system is consisting of three types of layers, i.e. the input layer, the hidden layer and the output layer. Normally, the hidden layer may have multiple layers according to one’s design. Among layers, the data from the upper layer are transformed to the data in the lower layer via a linear combination with an initialized weight matrix. After that, a nonlinear transformation that is generally called the activation function is applied to the data that would be converted to a form for the next round until reaching the output layer. To assure the neural network feedback the correct output, people need to train the neural network by adjusting the weight matrix. They are usually adjusted via minimizing the error between the output from the final layer and the known output from the data used for training. </p>\n<p>Without loss of generality, here I consider a simplest neural network which only possesses fully connected layers, meaning that every neuron in each layer connects all neurons of the upper and lower layers. The mathematical logic behind is analogous to other structures of neural network. Firstly, I used a series of graphs to illustrate how the data flows to the final layer and introduce the notations used in the derivation. Then, a general formulation is present subsequently.</p>\n<h1 id=\"A-6-layer-neural-network\"><a href=\"#A-6-layer-neural-network\" class=\"headerlink\" title=\"A 6-layer neural network\"></a>A 6-layer neural network</h1><p>The following four graphs illustrate how the data evolves along the neural network and the notations used in the derivation.</p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/step1.png\" alt=\"fig\">    </p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/step2.png\" alt=\"fig\">    </p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/step3.png\" alt=\"fig\">    </p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/step4.png\" alt=\"fig\">   </p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/step5.png\" alt=\"fig\"> </p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/step8.png\" alt=\"fig\">         </p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/step7.png\" alt=\"fig\">     </p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/step6.png\" alt=\"fig\">     </p>\n<h1 id=\"1-Forward-flow-of-the-neural-network\"><a href=\"#1-Forward-flow-of-the-neural-network\" class=\"headerlink\" title=\"1 Forward flow of the neural network\"></a>1 Forward flow of the neural network</h1><p>Consider a neural network with \\(k+1\\) layers including the input layer and the output layer. The input data is consisting of \\(n\\) samples with \\(L_{1}\\) features</p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/1.png\" alt=\"fig\">   </p>\n<p>The output label is given accordingly</p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/2.png\" alt=\"fig\">   </p>\n<p>where the label on the top left denotes the index of the sample. Too abstract? Imagine that sample \\(^{1}\\boldsymbol{x}\\) corresponds to model 1 while sample \\(^{2}\\boldsymbol{x}\\) corresponds to model 2. Then the output can be either an array of two vectors indicating the probabilities of model 1 and model 2, for example, \\({(1,0),(0,1)}\\), or a vector of two elements \\({0,1}\\) where 0 indicates model 1 and 1 indicates model 2 or whatever you label them. The purpose is to use a huge amount of data sets to train the neural network, more precisely to compute the weight matrix among the adjacent pair of layers, to fit the output layer to the output vectors. Will see it later on.</p>\n<p>Now, let’s feed one sample (the first one \\(^{1}\\boldsymbol{x}\\)) to the neural network to see how to compute the output layer. Later, we will see how to train the network with multiple samples. Assume the second layer has \\(L_{2}\\) neurons</p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/3.png\" alt=\"fig\">   </p>\n<p>Note that the first layer is the input layer in which we feed one sample with \\(L_{1}\\) feature to the neural network at first. Then the weight matrix from the first layer to the second layer is defined as </p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/4.png\" alt=\"fig\">   </p>\n<p>Thus, multiplying the weight matrix Eq.4 with the neurons of the upper layer Eq.3 yields</p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/5.png\" alt=\"fig\">   </p>\n<p>More generally, a bias term (constant term) is incorporated as follows</p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/6.png\" alt=\"fig\"> </p>\n<p>which can also be written in the form if we absorb the constant vector \\(\\boldsymbol{b}_{1}\\) into the weight matrix  </p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/78.png\" alt=\"fig\"> </p>\n<p>After the transformation, an activation function is applied to \\(\\boldsymbol{z}^{(2)}\\) elementwisely. For a model classification problem, the sigmoid function and the hyperbolic tangent function are widely used. Here we use the sigmoid function for instance</p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/9.png\" alt=\"fig\"> </p>\n<p>Till now, the transformation from the first layer (the input layer) to the second layer (the first hidden layer) is done. This process can be generalized as .</p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/9-1.png\" alt=\"fig\"> </p>\n<p>where \\(\\boldsymbol{a}’\\) is the vector \\(\\boldsymbol{a}\\) absorbing 1 at the end as what I did in Eq.8. Note that \\(\\boldsymbol{a}^{(1)}&#x3D;^{1}\\boldsymbol{x}\\).</p>\n<p>Finally, the neural network will return \\(\\boldsymbol{a}^{(k+1)}\\) with \\(L_{k+1}\\) elements from the output layer. Given the corresponding output label \\(\\boldsymbol{y}^{(1)}\\), we can compute the error between the feedback \\(\\boldsymbol{a}^{(k+1)}\\) and the output label \\(\\boldsymbol{y}^{(1)}\\). This is normally called the loss of the result to the output. There are several candidate loss functions for model classification like the least square, the cross-entropy function. We take the least square function as the example</p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/10.png\" alt=\"fig\"> </p>\n<p>So far, we have computed out the loss of the neural network with a bunch of randomly initialized weight matrix. No doubt, the loss would be huge. Our aim is to minimized the loss \\(J\\) by tuning the weight matrix. How? Remember your advanced calculus in the high school or the university? \\(J\\) can be envisaged as a function of every entry in the weight matrix that we want to adjust. Thus, the derivative of \\(J\\) with respect to each entries of the weight matrix would tell us how to tune the weight matrix to minimize the loss. This method is called gradient descend. And the loss can also propagate backwards to determine the gradient of the entries of the weight matrix at each layer. The full process to tune the weight matrix is also called Backward Propagation. </p>\n<h1 id=\"2-Backward-propagation\"><a href=\"#2-Backward-propagation\" class=\"headerlink\" title=\"2 Backward propagation\"></a>2 Backward propagation</h1><h2 id=\"From-the-k-1-th-layer-to-the-k-th-layer\"><a href=\"#From-the-k-1-th-layer-to-the-k-th-layer\" class=\"headerlink\" title=\"From the \\(k+1\\)th layer to the \\(k\\)th layer\"></a>From the \\(k+1\\)th layer to the \\(k\\)th layer</h2><p>Let us start from the final layer (the \\(k+1\\)th layer) to the previous one (the \\(k\\)th layer). Note that the variable of our concern is the entry of the weight matrix from the \\(k\\)th layer to the \\(k+1\\)th layer, \\(\\theta_{L_{k+1}\\times L_{k}}^{(k)}\\). Here I only consider tuning \\(\\theta\\) instead of \\(\\theta’\\), meaning that the bias terms are not tuned. Updating the bias terms is similar and you can practice it afterward. The derivative of the loss function with respect to the matrix is defined as </p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/11.png\" alt=\"fig\"> </p>\n<p>At the mean time, from the loss function Eq.10, we obtain the derivative according to the chain rule</p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/12.png\" alt=\"fig\"> </p>\n<p>where</p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/13-15.png\" alt=\"fig\"> </p>\n<p>and</p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/16.png\" alt=\"fig\"> </p>\n<p>where \\(\\otimes\\) is the outer product. Simplifying the gradient Eq.12 yields</p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/17.png\" alt=\"fig\"> </p>\n<p>If we define</p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/18.png\" alt=\"fig\"> </p>\n<p>The gradient Eq.17 can be further simplified as</p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/19.png\" alt=\"fig\"> </p>\n<p>Note that we define the outer product of two column vectors is the element-wise produce of the corresponding elements</p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/19-1.png\" alt=\"fig\"> </p>\n<p>Now, as \\(\\boldsymbol{z}^{(k+1)}\\), \\(\\boldsymbol{a}^{(k+1)}\\) and \\(^{1}\\boldsymbol{y}\\) are known, we can update the weight matrix \\(\\theta^{(k)}\\) by</p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/20.png\" alt=\"fig\"> </p>\n<p>where \\(\\lambda\\) is a constant called the learning rate given in advance. </p>\n<h2 id=\"From-the-k-th-layer-to-the-k-1-th-layer\"><a href=\"#From-the-k-th-layer-to-the-k-1-th-layer\" class=\"headerlink\" title=\"From the \\(k\\)th layer to the \\(k-1\\)th layer\"></a>From the \\(k\\)th layer to the \\(k-1\\)th layer</h2><p>Let’s do the calculation one more time from the \\(k\\)th layer to the \\(k-1\\)th layer. At the end of this section, we will get a general formula to update all weight matrix via which we can develop the algorithm for a deep neural network. </p>\n<p>Now we consider one more previous weight matrix \\(\\theta^{(k-1)}\\). The derivative of the loss function with respect to that matrix yields </p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/21.png\" alt=\"fig\"> </p>\n<p>The first two terms on the right hand side are the same as Eq.12. The third term \\(\\frac{\\partial\\boldsymbol{z}^{(k+1)}}{\\partial\\boldsymbol{a}^{(k)}}\\) produces the weight matrix from the \\(k+1\\)th layer to the \\(k\\)th layer</p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/22.png\" alt=\"fig\"> </p>\n<p>The last two terms on the right hand side are similar to what we have done above. Finally, we get</p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/23.png\" alt=\"fig\"> </p>\n<p>Comparing Eq.19 and Eq.23 tells us that we can update the error</p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/24.png\" alt=\"fig\"> </p>\n<p>for each transition among layers. This is how the error propagates backwards along the neural network and where the name comes from. Note that this expression is a slightly different from the formula in Chapter 9.2 of the <a href=\"https://www.coursera.org/course/ml\">machine learning course</a> by Andrew Ng of Standford. Do you see why is that? </p>\n<h1 id=\"3-Training-multiple-samples\"><a href=\"#3-Training-multiple-samples\" class=\"headerlink\" title=\"3 Training multiple samples\"></a>3 Training multiple samples</h1><p>We have derived mathematically how to train one sample on a neural network. How about multiple samples? Easy. Because all the weight matrix of the neural network are shared for all samples, we can update the weight matrix by a fraction of error of each sample. Normally this fraction is \\(\\frac{1}{\\text{sample size}}\\) where in our example the sample size is \\(n\\)</p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/25.png\" alt=\"fig\"> </p>\n<p>Then, the weight matrix is tuned to minimize the error of samples. </p>\n<h1 id=\"4-Program-a-neural-network\"><a href=\"#4-Program-a-neural-network\" class=\"headerlink\" title=\"4 Program a neural network\"></a>4 Program a neural network</h1><p>Till now, we have derived a general formula Eq.23 to allow us to update all weight matrix. After updating, the loss function is applied again to examine if the error is sufficiently small. If not, update the weight matrix again till meeting our criterion. Understanding the math behind is a huge step towards the expert level but not the final one. Whether you can equip it via code is essential. Here I attached my code in Python from my perspective as a reference. The user can add any number of hidden layers and deploy any number of neurons there. It is a bit like a minimalistic version of tensorflow. </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">neuralnetwork</span>:</span><br><span class=\"line\">    <span class=\"comment\"># initialize parameters</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self,num_sample,num_hidden_layer_units,num_input_feature,num_output_feature,bias,learningrate</span>):</span><br><span class=\"line\">        self.learningrate=learningrate <span class=\"comment\"># learning rate</span></span><br><span class=\"line\">        self.num_sample = num_sample  <span class=\"comment\"># number of the samples</span></span><br><span class=\"line\">        self.num_hidden_layer_units = num_hidden_layer_units <span class=\"comment\"># a list indicating the number of hidden layers and how many neurons for each layer</span></span><br><span class=\"line\">        self.num_hidden_layer = <span class=\"built_in\">len</span>(num_hidden_layer_units) <span class=\"comment\"># the number of the hidden layers</span></span><br><span class=\"line\">        self.weight_layer = []  <span class=\"comment\"># initialize the weight matrix</span></span><br><span class=\"line\">        self.bias = bias   <span class=\"comment\"># bias for the input layer and for the hidden layers</span></span><br><span class=\"line\">        <span class=\"keyword\">assert</span> <span class=\"built_in\">len</span>(self.bias) == self.num_hidden_layer+<span class=\"number\">1</span>, <span class=\"string\">&quot;The length of the biases should equal the length of the hidden layers plus 1!!!&quot;</span></span><br><span class=\"line\">        self.units = [num_input_feature] + num_hidden_layer_units + [num_output_feature]</span><br><span class=\"line\">        <span class=\"comment\"># randomly initialize the weight matrix</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> num_layer <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">0</span>,<span class=\"built_in\">len</span>(self.units)-<span class=\"number\">1</span>):</span><br><span class=\"line\">            temp_bias = np.zeros((<span class=\"number\">1</span>,self.units[num_layer+<span class=\"number\">1</span>]))</span><br><span class=\"line\">            temp_bias.fill(self.bias[num_layer])</span><br><span class=\"line\">            self.weight_layer.append(np.concatenate((np.random.randn(self.units[num_layer+<span class=\"number\">1</span>],</span><br><span class=\"line\">                                                self.units[num_layer]),temp_bias.T),axis = <span class=\"number\">1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># the activation function: sigmoid</span></span><br><span class=\"line\">    <span class=\"comment\"># could be replaced by whatever you want</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">sigmoid</span>(<span class=\"params\">self,x</span>):</span><br><span class=\"line\">        y = <span class=\"number\">1</span>/(<span class=\"number\">1</span>+np.exp(-x))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> y</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># train function requires the training data, accuracy and iteration limit</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">train</span>(<span class=\"params\">self, <span class=\"built_in\">input</span>, output,accuracy, iteration_limit</span>):</span><br><span class=\"line\">        go_on = <span class=\"literal\">True</span></span><br><span class=\"line\">        i = <span class=\"number\">0</span> <span class=\"comment\"># iteration indicator</span></span><br><span class=\"line\">        error = []  <span class=\"comment\"># error list recoding errors for all iterations</span></span><br><span class=\"line\">        iteration = []</span><br><span class=\"line\">        <span class=\"keyword\">while</span> go_on:</span><br><span class=\"line\">            iteration.append(i)</span><br><span class=\"line\">            error_acc = <span class=\"number\">0</span>   <span class=\"comment\"># initialize error for every iteration</span></span><br><span class=\"line\">            stderror = []   <span class=\"comment\"># standard error</span></span><br><span class=\"line\">            sample_Z = []   <span class=\"comment\"># Z value of neurons for every sample</span></span><br><span class=\"line\">            sample_a = []   <span class=\"comment\"># sigmoid value of Z for every sample</span></span><br><span class=\"line\">            <span class=\"comment\"># loop all samples</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> sample_iter <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(self.num_sample):</span><br><span class=\"line\">                Zlayer = []</span><br><span class=\"line\">                a = []</span><br><span class=\"line\">                a.append(<span class=\"built_in\">input</span>[sample_iter])    <span class=\"comment\"># place the input as the first a value</span></span><br><span class=\"line\">                <span class=\"comment\"># forward computing Z and a values for all layers</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> forward_layer <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(self.units)-<span class=\"number\">1</span>):</span><br><span class=\"line\">                    Zlayer.append(np.matmul(self.weight_layer[forward_layer], np.concatenate((a[forward_layer],[<span class=\"number\">1</span>]))))</span><br><span class=\"line\">                    a.append(self.sigmoid(Zlayer[forward_layer]))</span><br><span class=\"line\">                <span class=\"comment\"># standard error by computing the distance between output layer and true output</span></span><br><span class=\"line\">                stderror.append(a[<span class=\"built_in\">len</span>(a)-<span class=\"number\">1</span>]-output[sample_iter])</span><br><span class=\"line\">                <span class=\"comment\"># loss function defined as the sum of the least square</span></span><br><span class=\"line\">                <span class=\"comment\"># can be replaced by other functions like cross-entropy</span></span><br><span class=\"line\">                error_acc += (<span class=\"number\">1</span>/<span class=\"number\">2</span>*np.<span class=\"built_in\">sum</span>((stderror[sample_iter])**<span class=\"number\">2</span>))</span><br><span class=\"line\">                sample_a.append(a)  <span class=\"comment\"># store a values for updating</span></span><br><span class=\"line\">                sample_Z.append(Zlayer) <span class=\"comment\"># store Z values for updating</span></span><br><span class=\"line\">            error.append(error_acc) <span class=\"comment\"># store error for this iteration</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\"># backward propagate errors to update the weight matrix</span></span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> error[i-<span class=\"number\">1</span>] &lt;accuracy <span class=\"keyword\">or</span> i &gt;iteration_limit:</span><br><span class=\"line\">                go_on = <span class=\"literal\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">for</span> sample_iter <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(self.num_sample):</span><br><span class=\"line\">                    delta = stderror[sample_iter]  <span class=\"comment\"># delta: standard error defined as the derivative of the loss function</span></span><br><span class=\"line\">                    <span class=\"comment\"># initialize g&#x27;(z): the derivative of the activation function at the output layer</span></span><br><span class=\"line\">                    deriv_sigmoid =  sample_a[sample_iter][<span class=\"built_in\">len</span>(sample_a[sample_iter])-<span class=\"number\">1</span>] *\\</span><br><span class=\"line\">                                 (<span class=\"number\">1</span> - sample_a[sample_iter][<span class=\"built_in\">len</span>(sample_a[sample_iter])-<span class=\"number\">1</span>])</span><br><span class=\"line\">                    <span class=\"comment\"># backward propagation</span></span><br><span class=\"line\">                    <span class=\"keyword\">for</span> backward_layer <span class=\"keyword\">in</span> <span class=\"built_in\">list</span>(<span class=\"built_in\">reversed</span>(<span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(self.units)-<span class=\"number\">1</span>))):</span><br><span class=\"line\">                        temp_weight = self.weight_layer[backward_layer] <span class=\"comment\"># store the temporary kth matrix</span></span><br><span class=\"line\">                        <span class=\"comment\"># update the kth matrix</span></span><br><span class=\"line\">                        self.weight_layer[backward_layer][:,:-<span class=\"number\">1</span>] += - self.learningrate/self.num_sample *\\</span><br><span class=\"line\">                            np.outer(delta * deriv_sigmoid, sample_a[sample_iter][backward_layer])</span><br><span class=\"line\">                        <span class=\"comment\"># update delta and derivative of the activation function</span></span><br><span class=\"line\">                        delta = np.dot(temp_weight[:,:-<span class=\"number\">1</span>].T,delta * deriv_sigmoid)</span><br><span class=\"line\">                        deriv_sigmoid = sample_a[sample_iter][backward_layer] *\\</span><br><span class=\"line\">                                 (<span class=\"number\">1</span> - sample_a[sample_iter][backward_layer])</span><br><span class=\"line\">        self.learningspeed = &#123;<span class=\"string\">&#x27;error&#x27;</span>: error, <span class=\"string\">&#x27;iteration&#x27;</span>: iteration&#125;</span><br><span class=\"line\">        self.lsdf = pd.DataFrame(self.learningspeed)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sample_a, self.weight_layer</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># predict</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">predict</span>(<span class=\"params\">self,<span class=\"built_in\">input</span>,weight</span>):</span><br><span class=\"line\">        out = <span class=\"built_in\">input</span>+[<span class=\"number\">1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(weight)):</span><br><span class=\"line\">            out = np.dot(weight[i],np.array(out))</span><br><span class=\"line\">            out = self.sigmoid(out)</span><br><span class=\"line\">            out = np.concatenate((out,[<span class=\"number\">1</span>]))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> out[:-<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># test</span></span><br><span class=\"line\">inputx = np.array(([<span class=\"number\">0.2</span>, <span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>,<span class=\"number\">0.3</span>], [<span class=\"number\">0.1</span>, <span class=\"number\">0.2</span>, <span class=\"number\">0.15</span>,<span class=\"number\">0.1</span>],[<span class=\"number\">0.7</span>,<span class=\"number\">0.9</span>,<span class=\"number\">0.4</span>,<span class=\"number\">0.8</span>]))</span><br><span class=\"line\">outputy = np.array(([<span class=\"number\">0.5</span>, <span class=\"number\">0.4</span>], [<span class=\"number\">0.9</span>, <span class=\"number\">0.1</span>],[<span class=\"number\">0.3</span>,<span class=\"number\">0.5</span>]))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># build the neural network</span></span><br><span class=\"line\">nn=neuralnetwork(num_sample=inputx.shape[<span class=\"number\">0</span>],num_hidden_layer_units=[<span class=\"number\">15</span>,<span class=\"number\">14</span>,<span class=\"number\">15</span>,<span class=\"number\">16</span>],num_input_feature=inputx.shape[<span class=\"number\">1</span>],</span><br><span class=\"line\">             num_output_feature=outputy.shape[<span class=\"number\">1</span>], bias=[<span class=\"number\">0.1</span>,<span class=\"number\">0.2</span>,<span class=\"number\">0.3</span>,<span class=\"number\">0.4</span>,<span class=\"number\">0.4</span>],learningrate=<span class=\"number\">0.2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># set the accuracy and the iteration limit</span></span><br><span class=\"line\">acc = <span class=\"number\">1e-7</span></span><br><span class=\"line\"><span class=\"built_in\">iter</span> = <span class=\"number\">20000</span></span><br><span class=\"line\"><span class=\"comment\"># train the neural network</span></span><br><span class=\"line\">out_a,weight = nn.train(inputx,outputy,accuracy = acc,iteration_limit=<span class=\"built_in\">iter</span>)</span><br><span class=\"line\"><span class=\"comment\"># plot the learning process</span></span><br><span class=\"line\">nn.lsdf.plot(x=<span class=\"string\">&#x27;iteration&#x27;</span>,y=<span class=\"string\">&#x27;error&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># predict</span></span><br><span class=\"line\"><span class=\"built_in\">input</span> = [<span class=\"number\">0.19</span>, <span class=\"number\">0.51</span>, <span class=\"number\">0.49</span>,<span class=\"number\">0.29</span>]</span><br><span class=\"line\">out = nn.predict(<span class=\"built_in\">input</span>,weight)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>You can also clone it <a href=\"https://github.com/xl0418/Tensorflow/blob/master/NeuralNetwork.py\">on my Github</a> </p>\n<h1 id=\"The-end\"><a href=\"#The-end\" class=\"headerlink\" title=\"The end\"></a>The end</h1><p>My code is obviously not the most efficient one as a lot of loops are used. But in another sense it is easy to read for a starter. As you see in the derivation and in the code, there are a huge amount of independent computing that can be parallelized to speed up. So the future plan is to parallelize the code on GPU which may substantially improve the efficiency of the neural network. It would also be a good practice for you to step into the machine learning field. </p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><ul>\n<li><p>An introduction to the math used in Machine Learning:  <a href=\"https://explained.ai/matrix-calculus/index.html\">The Matrix Calculus You Need For Deep Learning\n</a>.</p>\n</li>\n<li><p>A concrete derivation of backward propagation for a two-layer neural network in Chinese <a href=\"http://www.cnblogs.com/charlotte77/p/5629865.html#!comments\">here</a>.</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>There are tons of documents out there to explain how neural network works in different angles. So I guess people don’t mind me adding one more from my perspective. Hopefully, someone may get inspired from this post.</p>","more":"<p>In short, the neural network is a kind of system that transforms the input data into its corresponding output (or labels), strictly speaking, for a supervised learning. This system is consisting of three types of layers, i.e. the input layer, the hidden layer and the output layer. Normally, the hidden layer may have multiple layers according to one’s design. Among layers, the data from the upper layer are transformed to the data in the lower layer via a linear combination with an initialized weight matrix. After that, a nonlinear transformation that is generally called the activation function is applied to the data that would be converted to a form for the next round until reaching the output layer. To assure the neural network feedback the correct output, people need to train the neural network by adjusting the weight matrix. They are usually adjusted via minimizing the error between the output from the final layer and the known output from the data used for training. </p>\n<p>Without loss of generality, here I consider a simplest neural network which only possesses fully connected layers, meaning that every neuron in each layer connects all neurons of the upper and lower layers. The mathematical logic behind is analogous to other structures of neural network. Firstly, I used a series of graphs to illustrate how the data flows to the final layer and introduce the notations used in the derivation. Then, a general formulation is present subsequently.</p>\n<h1 id=\"A-6-layer-neural-network\"><a href=\"#A-6-layer-neural-network\" class=\"headerlink\" title=\"A 6-layer neural network\"></a>A 6-layer neural network</h1><p>The following four graphs illustrate how the data evolves along the neural network and the notations used in the derivation.</p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/step1.png\" alt=\"fig\">    </p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/step2.png\" alt=\"fig\">    </p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/step3.png\" alt=\"fig\">    </p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/step4.png\" alt=\"fig\">   </p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/step5.png\" alt=\"fig\"> </p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/step8.png\" alt=\"fig\">         </p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/step7.png\" alt=\"fig\">     </p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/step6.png\" alt=\"fig\">     </p>\n<h1 id=\"1-Forward-flow-of-the-neural-network\"><a href=\"#1-Forward-flow-of-the-neural-network\" class=\"headerlink\" title=\"1 Forward flow of the neural network\"></a>1 Forward flow of the neural network</h1><p>Consider a neural network with \\(k+1\\) layers including the input layer and the output layer. The input data is consisting of \\(n\\) samples with \\(L_{1}\\) features</p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/1.png\" alt=\"fig\">   </p>\n<p>The output label is given accordingly</p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/2.png\" alt=\"fig\">   </p>\n<p>where the label on the top left denotes the index of the sample. Too abstract? Imagine that sample \\(^{1}\\boldsymbol{x}\\) corresponds to model 1 while sample \\(^{2}\\boldsymbol{x}\\) corresponds to model 2. Then the output can be either an array of two vectors indicating the probabilities of model 1 and model 2, for example, \\({(1,0),(0,1)}\\), or a vector of two elements \\({0,1}\\) where 0 indicates model 1 and 1 indicates model 2 or whatever you label them. The purpose is to use a huge amount of data sets to train the neural network, more precisely to compute the weight matrix among the adjacent pair of layers, to fit the output layer to the output vectors. Will see it later on.</p>\n<p>Now, let’s feed one sample (the first one \\(^{1}\\boldsymbol{x}\\)) to the neural network to see how to compute the output layer. Later, we will see how to train the network with multiple samples. Assume the second layer has \\(L_{2}\\) neurons</p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/3.png\" alt=\"fig\">   </p>\n<p>Note that the first layer is the input layer in which we feed one sample with \\(L_{1}\\) feature to the neural network at first. Then the weight matrix from the first layer to the second layer is defined as </p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/4.png\" alt=\"fig\">   </p>\n<p>Thus, multiplying the weight matrix Eq.4 with the neurons of the upper layer Eq.3 yields</p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/5.png\" alt=\"fig\">   </p>\n<p>More generally, a bias term (constant term) is incorporated as follows</p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/6.png\" alt=\"fig\"> </p>\n<p>which can also be written in the form if we absorb the constant vector \\(\\boldsymbol{b}_{1}\\) into the weight matrix  </p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/78.png\" alt=\"fig\"> </p>\n<p>After the transformation, an activation function is applied to \\(\\boldsymbol{z}^{(2)}\\) elementwisely. For a model classification problem, the sigmoid function and the hyperbolic tangent function are widely used. Here we use the sigmoid function for instance</p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/9.png\" alt=\"fig\"> </p>\n<p>Till now, the transformation from the first layer (the input layer) to the second layer (the first hidden layer) is done. This process can be generalized as .</p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/9-1.png\" alt=\"fig\"> </p>\n<p>where \\(\\boldsymbol{a}’\\) is the vector \\(\\boldsymbol{a}\\) absorbing 1 at the end as what I did in Eq.8. Note that \\(\\boldsymbol{a}^{(1)}&#x3D;^{1}\\boldsymbol{x}\\).</p>\n<p>Finally, the neural network will return \\(\\boldsymbol{a}^{(k+1)}\\) with \\(L_{k+1}\\) elements from the output layer. Given the corresponding output label \\(\\boldsymbol{y}^{(1)}\\), we can compute the error between the feedback \\(\\boldsymbol{a}^{(k+1)}\\) and the output label \\(\\boldsymbol{y}^{(1)}\\). This is normally called the loss of the result to the output. There are several candidate loss functions for model classification like the least square, the cross-entropy function. We take the least square function as the example</p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/10.png\" alt=\"fig\"> </p>\n<p>So far, we have computed out the loss of the neural network with a bunch of randomly initialized weight matrix. No doubt, the loss would be huge. Our aim is to minimized the loss \\(J\\) by tuning the weight matrix. How? Remember your advanced calculus in the high school or the university? \\(J\\) can be envisaged as a function of every entry in the weight matrix that we want to adjust. Thus, the derivative of \\(J\\) with respect to each entries of the weight matrix would tell us how to tune the weight matrix to minimize the loss. This method is called gradient descend. And the loss can also propagate backwards to determine the gradient of the entries of the weight matrix at each layer. The full process to tune the weight matrix is also called Backward Propagation. </p>\n<h1 id=\"2-Backward-propagation\"><a href=\"#2-Backward-propagation\" class=\"headerlink\" title=\"2 Backward propagation\"></a>2 Backward propagation</h1><h2 id=\"From-the-k-1-th-layer-to-the-k-th-layer\"><a href=\"#From-the-k-1-th-layer-to-the-k-th-layer\" class=\"headerlink\" title=\"From the \\(k+1\\)th layer to the \\(k\\)th layer\"></a>From the \\(k+1\\)th layer to the \\(k\\)th layer</h2><p>Let us start from the final layer (the \\(k+1\\)th layer) to the previous one (the \\(k\\)th layer). Note that the variable of our concern is the entry of the weight matrix from the \\(k\\)th layer to the \\(k+1\\)th layer, \\(\\theta_{L_{k+1}\\times L_{k}}^{(k)}\\). Here I only consider tuning \\(\\theta\\) instead of \\(\\theta’\\), meaning that the bias terms are not tuned. Updating the bias terms is similar and you can practice it afterward. The derivative of the loss function with respect to the matrix is defined as </p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/11.png\" alt=\"fig\"> </p>\n<p>At the mean time, from the loss function Eq.10, we obtain the derivative according to the chain rule</p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/12.png\" alt=\"fig\"> </p>\n<p>where</p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/13-15.png\" alt=\"fig\"> </p>\n<p>and</p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/16.png\" alt=\"fig\"> </p>\n<p>where \\(\\otimes\\) is the outer product. Simplifying the gradient Eq.12 yields</p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/17.png\" alt=\"fig\"> </p>\n<p>If we define</p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/18.png\" alt=\"fig\"> </p>\n<p>The gradient Eq.17 can be further simplified as</p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/19.png\" alt=\"fig\"> </p>\n<p>Note that we define the outer product of two column vectors is the element-wise produce of the corresponding elements</p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/19-1.png\" alt=\"fig\"> </p>\n<p>Now, as \\(\\boldsymbol{z}^{(k+1)}\\), \\(\\boldsymbol{a}^{(k+1)}\\) and \\(^{1}\\boldsymbol{y}\\) are known, we can update the weight matrix \\(\\theta^{(k)}\\) by</p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/20.png\" alt=\"fig\"> </p>\n<p>where \\(\\lambda\\) is a constant called the learning rate given in advance. </p>\n<h2 id=\"From-the-k-th-layer-to-the-k-1-th-layer\"><a href=\"#From-the-k-th-layer-to-the-k-1-th-layer\" class=\"headerlink\" title=\"From the \\(k\\)th layer to the \\(k-1\\)th layer\"></a>From the \\(k\\)th layer to the \\(k-1\\)th layer</h2><p>Let’s do the calculation one more time from the \\(k\\)th layer to the \\(k-1\\)th layer. At the end of this section, we will get a general formula to update all weight matrix via which we can develop the algorithm for a deep neural network. </p>\n<p>Now we consider one more previous weight matrix \\(\\theta^{(k-1)}\\). The derivative of the loss function with respect to that matrix yields </p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/21.png\" alt=\"fig\"> </p>\n<p>The first two terms on the right hand side are the same as Eq.12. The third term \\(\\frac{\\partial\\boldsymbol{z}^{(k+1)}}{\\partial\\boldsymbol{a}^{(k)}}\\) produces the weight matrix from the \\(k+1\\)th layer to the \\(k\\)th layer</p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/22.png\" alt=\"fig\"> </p>\n<p>The last two terms on the right hand side are similar to what we have done above. Finally, we get</p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/23.png\" alt=\"fig\"> </p>\n<p>Comparing Eq.19 and Eq.23 tells us that we can update the error</p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/24.png\" alt=\"fig\"> </p>\n<p>for each transition among layers. This is how the error propagates backwards along the neural network and where the name comes from. Note that this expression is a slightly different from the formula in Chapter 9.2 of the <a href=\"https://www.coursera.org/course/ml\">machine learning course</a> by Andrew Ng of Standford. Do you see why is that? </p>\n<h1 id=\"3-Training-multiple-samples\"><a href=\"#3-Training-multiple-samples\" class=\"headerlink\" title=\"3 Training multiple samples\"></a>3 Training multiple samples</h1><p>We have derived mathematically how to train one sample on a neural network. How about multiple samples? Easy. Because all the weight matrix of the neural network are shared for all samples, we can update the weight matrix by a fraction of error of each sample. Normally this fraction is \\(\\frac{1}{\\text{sample size}}\\) where in our example the sample size is \\(n\\)</p>\n<p><img src=\"/2019-02-08-Machinelearningseries2/25.png\" alt=\"fig\"> </p>\n<p>Then, the weight matrix is tuned to minimize the error of samples. </p>\n<h1 id=\"4-Program-a-neural-network\"><a href=\"#4-Program-a-neural-network\" class=\"headerlink\" title=\"4 Program a neural network\"></a>4 Program a neural network</h1><p>Till now, we have derived a general formula Eq.23 to allow us to update all weight matrix. After updating, the loss function is applied again to examine if the error is sufficiently small. If not, update the weight matrix again till meeting our criterion. Understanding the math behind is a huge step towards the expert level but not the final one. Whether you can equip it via code is essential. Here I attached my code in Python from my perspective as a reference. The user can add any number of hidden layers and deploy any number of neurons there. It is a bit like a minimalistic version of tensorflow. </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">neuralnetwork</span>:</span><br><span class=\"line\">    <span class=\"comment\"># initialize parameters</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self,num_sample,num_hidden_layer_units,num_input_feature,num_output_feature,bias,learningrate</span>):</span><br><span class=\"line\">        self.learningrate=learningrate <span class=\"comment\"># learning rate</span></span><br><span class=\"line\">        self.num_sample = num_sample  <span class=\"comment\"># number of the samples</span></span><br><span class=\"line\">        self.num_hidden_layer_units = num_hidden_layer_units <span class=\"comment\"># a list indicating the number of hidden layers and how many neurons for each layer</span></span><br><span class=\"line\">        self.num_hidden_layer = <span class=\"built_in\">len</span>(num_hidden_layer_units) <span class=\"comment\"># the number of the hidden layers</span></span><br><span class=\"line\">        self.weight_layer = []  <span class=\"comment\"># initialize the weight matrix</span></span><br><span class=\"line\">        self.bias = bias   <span class=\"comment\"># bias for the input layer and for the hidden layers</span></span><br><span class=\"line\">        <span class=\"keyword\">assert</span> <span class=\"built_in\">len</span>(self.bias) == self.num_hidden_layer+<span class=\"number\">1</span>, <span class=\"string\">&quot;The length of the biases should equal the length of the hidden layers plus 1!!!&quot;</span></span><br><span class=\"line\">        self.units = [num_input_feature] + num_hidden_layer_units + [num_output_feature]</span><br><span class=\"line\">        <span class=\"comment\"># randomly initialize the weight matrix</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> num_layer <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">0</span>,<span class=\"built_in\">len</span>(self.units)-<span class=\"number\">1</span>):</span><br><span class=\"line\">            temp_bias = np.zeros((<span class=\"number\">1</span>,self.units[num_layer+<span class=\"number\">1</span>]))</span><br><span class=\"line\">            temp_bias.fill(self.bias[num_layer])</span><br><span class=\"line\">            self.weight_layer.append(np.concatenate((np.random.randn(self.units[num_layer+<span class=\"number\">1</span>],</span><br><span class=\"line\">                                                self.units[num_layer]),temp_bias.T),axis = <span class=\"number\">1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># the activation function: sigmoid</span></span><br><span class=\"line\">    <span class=\"comment\"># could be replaced by whatever you want</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">sigmoid</span>(<span class=\"params\">self,x</span>):</span><br><span class=\"line\">        y = <span class=\"number\">1</span>/(<span class=\"number\">1</span>+np.exp(-x))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> y</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># train function requires the training data, accuracy and iteration limit</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">train</span>(<span class=\"params\">self, <span class=\"built_in\">input</span>, output,accuracy, iteration_limit</span>):</span><br><span class=\"line\">        go_on = <span class=\"literal\">True</span></span><br><span class=\"line\">        i = <span class=\"number\">0</span> <span class=\"comment\"># iteration indicator</span></span><br><span class=\"line\">        error = []  <span class=\"comment\"># error list recoding errors for all iterations</span></span><br><span class=\"line\">        iteration = []</span><br><span class=\"line\">        <span class=\"keyword\">while</span> go_on:</span><br><span class=\"line\">            iteration.append(i)</span><br><span class=\"line\">            error_acc = <span class=\"number\">0</span>   <span class=\"comment\"># initialize error for every iteration</span></span><br><span class=\"line\">            stderror = []   <span class=\"comment\"># standard error</span></span><br><span class=\"line\">            sample_Z = []   <span class=\"comment\"># Z value of neurons for every sample</span></span><br><span class=\"line\">            sample_a = []   <span class=\"comment\"># sigmoid value of Z for every sample</span></span><br><span class=\"line\">            <span class=\"comment\"># loop all samples</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> sample_iter <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(self.num_sample):</span><br><span class=\"line\">                Zlayer = []</span><br><span class=\"line\">                a = []</span><br><span class=\"line\">                a.append(<span class=\"built_in\">input</span>[sample_iter])    <span class=\"comment\"># place the input as the first a value</span></span><br><span class=\"line\">                <span class=\"comment\"># forward computing Z and a values for all layers</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> forward_layer <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(self.units)-<span class=\"number\">1</span>):</span><br><span class=\"line\">                    Zlayer.append(np.matmul(self.weight_layer[forward_layer], np.concatenate((a[forward_layer],[<span class=\"number\">1</span>]))))</span><br><span class=\"line\">                    a.append(self.sigmoid(Zlayer[forward_layer]))</span><br><span class=\"line\">                <span class=\"comment\"># standard error by computing the distance between output layer and true output</span></span><br><span class=\"line\">                stderror.append(a[<span class=\"built_in\">len</span>(a)-<span class=\"number\">1</span>]-output[sample_iter])</span><br><span class=\"line\">                <span class=\"comment\"># loss function defined as the sum of the least square</span></span><br><span class=\"line\">                <span class=\"comment\"># can be replaced by other functions like cross-entropy</span></span><br><span class=\"line\">                error_acc += (<span class=\"number\">1</span>/<span class=\"number\">2</span>*np.<span class=\"built_in\">sum</span>((stderror[sample_iter])**<span class=\"number\">2</span>))</span><br><span class=\"line\">                sample_a.append(a)  <span class=\"comment\"># store a values for updating</span></span><br><span class=\"line\">                sample_Z.append(Zlayer) <span class=\"comment\"># store Z values for updating</span></span><br><span class=\"line\">            error.append(error_acc) <span class=\"comment\"># store error for this iteration</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\"># backward propagate errors to update the weight matrix</span></span><br><span class=\"line\">            i += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> error[i-<span class=\"number\">1</span>] &lt;accuracy <span class=\"keyword\">or</span> i &gt;iteration_limit:</span><br><span class=\"line\">                go_on = <span class=\"literal\">False</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"keyword\">for</span> sample_iter <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(self.num_sample):</span><br><span class=\"line\">                    delta = stderror[sample_iter]  <span class=\"comment\"># delta: standard error defined as the derivative of the loss function</span></span><br><span class=\"line\">                    <span class=\"comment\"># initialize g&#x27;(z): the derivative of the activation function at the output layer</span></span><br><span class=\"line\">                    deriv_sigmoid =  sample_a[sample_iter][<span class=\"built_in\">len</span>(sample_a[sample_iter])-<span class=\"number\">1</span>] *\\</span><br><span class=\"line\">                                 (<span class=\"number\">1</span> - sample_a[sample_iter][<span class=\"built_in\">len</span>(sample_a[sample_iter])-<span class=\"number\">1</span>])</span><br><span class=\"line\">                    <span class=\"comment\"># backward propagation</span></span><br><span class=\"line\">                    <span class=\"keyword\">for</span> backward_layer <span class=\"keyword\">in</span> <span class=\"built_in\">list</span>(<span class=\"built_in\">reversed</span>(<span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(self.units)-<span class=\"number\">1</span>))):</span><br><span class=\"line\">                        temp_weight = self.weight_layer[backward_layer] <span class=\"comment\"># store the temporary kth matrix</span></span><br><span class=\"line\">                        <span class=\"comment\"># update the kth matrix</span></span><br><span class=\"line\">                        self.weight_layer[backward_layer][:,:-<span class=\"number\">1</span>] += - self.learningrate/self.num_sample *\\</span><br><span class=\"line\">                            np.outer(delta * deriv_sigmoid, sample_a[sample_iter][backward_layer])</span><br><span class=\"line\">                        <span class=\"comment\"># update delta and derivative of the activation function</span></span><br><span class=\"line\">                        delta = np.dot(temp_weight[:,:-<span class=\"number\">1</span>].T,delta * deriv_sigmoid)</span><br><span class=\"line\">                        deriv_sigmoid = sample_a[sample_iter][backward_layer] *\\</span><br><span class=\"line\">                                 (<span class=\"number\">1</span> - sample_a[sample_iter][backward_layer])</span><br><span class=\"line\">        self.learningspeed = &#123;<span class=\"string\">&#x27;error&#x27;</span>: error, <span class=\"string\">&#x27;iteration&#x27;</span>: iteration&#125;</span><br><span class=\"line\">        self.lsdf = pd.DataFrame(self.learningspeed)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sample_a, self.weight_layer</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># predict</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">predict</span>(<span class=\"params\">self,<span class=\"built_in\">input</span>,weight</span>):</span><br><span class=\"line\">        out = <span class=\"built_in\">input</span>+[<span class=\"number\">1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(weight)):</span><br><span class=\"line\">            out = np.dot(weight[i],np.array(out))</span><br><span class=\"line\">            out = self.sigmoid(out)</span><br><span class=\"line\">            out = np.concatenate((out,[<span class=\"number\">1</span>]))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> out[:-<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># test</span></span><br><span class=\"line\">inputx = np.array(([<span class=\"number\">0.2</span>, <span class=\"number\">0.5</span>, <span class=\"number\">0.5</span>,<span class=\"number\">0.3</span>], [<span class=\"number\">0.1</span>, <span class=\"number\">0.2</span>, <span class=\"number\">0.15</span>,<span class=\"number\">0.1</span>],[<span class=\"number\">0.7</span>,<span class=\"number\">0.9</span>,<span class=\"number\">0.4</span>,<span class=\"number\">0.8</span>]))</span><br><span class=\"line\">outputy = np.array(([<span class=\"number\">0.5</span>, <span class=\"number\">0.4</span>], [<span class=\"number\">0.9</span>, <span class=\"number\">0.1</span>],[<span class=\"number\">0.3</span>,<span class=\"number\">0.5</span>]))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># build the neural network</span></span><br><span class=\"line\">nn=neuralnetwork(num_sample=inputx.shape[<span class=\"number\">0</span>],num_hidden_layer_units=[<span class=\"number\">15</span>,<span class=\"number\">14</span>,<span class=\"number\">15</span>,<span class=\"number\">16</span>],num_input_feature=inputx.shape[<span class=\"number\">1</span>],</span><br><span class=\"line\">             num_output_feature=outputy.shape[<span class=\"number\">1</span>], bias=[<span class=\"number\">0.1</span>,<span class=\"number\">0.2</span>,<span class=\"number\">0.3</span>,<span class=\"number\">0.4</span>,<span class=\"number\">0.4</span>],learningrate=<span class=\"number\">0.2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># set the accuracy and the iteration limit</span></span><br><span class=\"line\">acc = <span class=\"number\">1e-7</span></span><br><span class=\"line\"><span class=\"built_in\">iter</span> = <span class=\"number\">20000</span></span><br><span class=\"line\"><span class=\"comment\"># train the neural network</span></span><br><span class=\"line\">out_a,weight = nn.train(inputx,outputy,accuracy = acc,iteration_limit=<span class=\"built_in\">iter</span>)</span><br><span class=\"line\"><span class=\"comment\"># plot the learning process</span></span><br><span class=\"line\">nn.lsdf.plot(x=<span class=\"string\">&#x27;iteration&#x27;</span>,y=<span class=\"string\">&#x27;error&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># predict</span></span><br><span class=\"line\"><span class=\"built_in\">input</span> = [<span class=\"number\">0.19</span>, <span class=\"number\">0.51</span>, <span class=\"number\">0.49</span>,<span class=\"number\">0.29</span>]</span><br><span class=\"line\">out = nn.predict(<span class=\"built_in\">input</span>,weight)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>You can also clone it <a href=\"https://github.com/xl0418/Tensorflow/blob/master/NeuralNetwork.py\">on my Github</a> </p>\n<h1 id=\"The-end\"><a href=\"#The-end\" class=\"headerlink\" title=\"The end\"></a>The end</h1><p>My code is obviously not the most efficient one as a lot of loops are used. But in another sense it is easy to read for a starter. As you see in the derivation and in the code, there are a huge amount of independent computing that can be parallelized to speed up. So the future plan is to parallelize the code on GPU which may substantially improve the efficiency of the neural network. It would also be a good practice for you to step into the machine learning field. </p>\n<h1 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h1><ul>\n<li><p>An introduction to the math used in Machine Learning:  <a href=\"https://explained.ai/matrix-calculus/index.html\">The Matrix Calculus You Need For Deep Learning\n</a>.</p>\n</li>\n<li><p>A concrete derivation of backward propagation for a two-layer neural network in Chinese <a href=\"http://www.cnblogs.com/charlotte77/p/5629865.html#!comments\">here</a>.</p>\n</li>\n</ul>"},{"title":"Bash & R: Dealing with big data; read it! don't source it!","date":"2019-03-20T07:00:00.000Z","_content":"\nRecently, I was focusing on my 3rd PhD project with mathematical modeling. It was about the extension to the [neutral theory](https://www.nature.com/scitable/knowledge/library/neutral-theory-of-species-diversity-13259703). I am not gonna reveal it now but will bring back in the future.  So I was away from the blog for a while and have to put machine learning series aside, although the derivation of the recurrent neural network is done. It is coming soon as well. Finally, the mathematical model has been done. I have some time to talk something that I've been doing except the modeling when waiting for the simulation results. In this post, I am gonna record a silly issue about loading data in R after extracting the a subset of a big data by Bash.  \n\n<!--more-->\n\n# The right matrix format to load in R\n\nIf you have tracked my posts, you may remember that I used a bash script to extract a matrix out of a big and complex structured m file (see [here](https://xl0418.github.io/2018/10/29/2018-10-29-sed/)). But I mistakenly modified the matrix to fit the matrix format in R.\n\n![fig](2019-03-20-readdatadon/d.png) \n\nWhat's wrong with this format? It is a function to call instead of a data to load. Thus if the data in the `structure()` is very big, like 10000x10000, it is very time-consuming to run the function in R. But our aim is to read the matrix of this size or even larger. It is not supposed to be problematic for R. \n\nAfter a while of brainstorm, I kind of thought it might be due to the matrix format and the way I load the data in R. The command `source()` actually calls the function written in the sourced file.  Thus, to create a matrix by using `structure()` it is easy to exceed the memory size. \n\nThe solution is that we could use `read.csv()` to load the data into R, which is much faster and more efficient for large data sets. To achieve that, we need rewrite the raw data in a csv format. The following is how it looks like in the notepad \n\n![fig](2019-03-20-readdatadon/rewrittendata.png) \n\nNotice that the first line is left blank. It is supposed to put the headers for columns. Then we can directly read it in R by using \n\n```R\nx = read.csv(data,header = FALSE)\n```\n\nSuper fast and it's done. \n\nFinally, to extract the matrix from the raw data, you can just follow what I did before ([here](https://xl0418.github.io/2018/10/29/2018-10-29-sed/))). And replace the 6-15th lines with \n\n```Bash\nA=$(grep -c 'D'{'length(D)+1'}' = \\[' HDs\"$j$i\".Rdata)\nB=$[$A-1]\nsed '/D'{'length(D)+1'}'/{G;s/\\nX\\{'$B'\\}//;tend;x;s/^/X/;x;P;d};p;d;:end;s/D'{'length(D)+1'}'/D/;:a;n;ba' HDs\"$j$i\".Rdata>HDt\"$j$i\".Rdata\nsed -n '/D = \\[/,/\\];/p' HDt\"$j$i\".Rdata>HD\"$j$i\".csv\nsed -i -e 's/D = \\[//' -e 's/\\];//' -e 's/ /,/g' -e 's/,;//g' HD\"$j$i\".csv\n```\n\nwhere I just replace the space by the comma and delete the first and last line of the raw matrix. The `;` at the end of each line is also removed.\n\nEnjoy!\n\n","source":"_posts/2019-03-20-readdatadon.md","raw":"---\ntitle: \"Bash & R: Dealing with big data; read it! don't source it!\"\ncategories: [Research,Bash,sed]\ntags: [data analysis, bash, R]\ndate: 2019-03-20\n\n---\n\nRecently, I was focusing on my 3rd PhD project with mathematical modeling. It was about the extension to the [neutral theory](https://www.nature.com/scitable/knowledge/library/neutral-theory-of-species-diversity-13259703). I am not gonna reveal it now but will bring back in the future.  So I was away from the blog for a while and have to put machine learning series aside, although the derivation of the recurrent neural network is done. It is coming soon as well. Finally, the mathematical model has been done. I have some time to talk something that I've been doing except the modeling when waiting for the simulation results. In this post, I am gonna record a silly issue about loading data in R after extracting the a subset of a big data by Bash.  \n\n<!--more-->\n\n# The right matrix format to load in R\n\nIf you have tracked my posts, you may remember that I used a bash script to extract a matrix out of a big and complex structured m file (see [here](https://xl0418.github.io/2018/10/29/2018-10-29-sed/)). But I mistakenly modified the matrix to fit the matrix format in R.\n\n![fig](2019-03-20-readdatadon/d.png) \n\nWhat's wrong with this format? It is a function to call instead of a data to load. Thus if the data in the `structure()` is very big, like 10000x10000, it is very time-consuming to run the function in R. But our aim is to read the matrix of this size or even larger. It is not supposed to be problematic for R. \n\nAfter a while of brainstorm, I kind of thought it might be due to the matrix format and the way I load the data in R. The command `source()` actually calls the function written in the sourced file.  Thus, to create a matrix by using `structure()` it is easy to exceed the memory size. \n\nThe solution is that we could use `read.csv()` to load the data into R, which is much faster and more efficient for large data sets. To achieve that, we need rewrite the raw data in a csv format. The following is how it looks like in the notepad \n\n![fig](2019-03-20-readdatadon/rewrittendata.png) \n\nNotice that the first line is left blank. It is supposed to put the headers for columns. Then we can directly read it in R by using \n\n```R\nx = read.csv(data,header = FALSE)\n```\n\nSuper fast and it's done. \n\nFinally, to extract the matrix from the raw data, you can just follow what I did before ([here](https://xl0418.github.io/2018/10/29/2018-10-29-sed/))). And replace the 6-15th lines with \n\n```Bash\nA=$(grep -c 'D'{'length(D)+1'}' = \\[' HDs\"$j$i\".Rdata)\nB=$[$A-1]\nsed '/D'{'length(D)+1'}'/{G;s/\\nX\\{'$B'\\}//;tend;x;s/^/X/;x;P;d};p;d;:end;s/D'{'length(D)+1'}'/D/;:a;n;ba' HDs\"$j$i\".Rdata>HDt\"$j$i\".Rdata\nsed -n '/D = \\[/,/\\];/p' HDt\"$j$i\".Rdata>HD\"$j$i\".csv\nsed -i -e 's/D = \\[//' -e 's/\\];//' -e 's/ /,/g' -e 's/,;//g' HD\"$j$i\".csv\n```\n\nwhere I just replace the space by the comma and delete the first and last line of the raw matrix. The `;` at the end of each line is also removed.\n\nEnjoy!\n\n","slug":"2019-03-20-readdatadon","published":1,"updated":"2022-09-17T02:04:05.178Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl85g865y00174gkr2x3740kp","content":"<p>Recently, I was focusing on my 3rd PhD project with mathematical modeling. It was about the extension to the <a href=\"https://www.nature.com/scitable/knowledge/library/neutral-theory-of-species-diversity-13259703\">neutral theory</a>. I am not gonna reveal it now but will bring back in the future.  So I was away from the blog for a while and have to put machine learning series aside, although the derivation of the recurrent neural network is done. It is coming soon as well. Finally, the mathematical model has been done. I have some time to talk something that I’ve been doing except the modeling when waiting for the simulation results. In this post, I am gonna record a silly issue about loading data in R after extracting the a subset of a big data by Bash.  </p>\n<span id=\"more\"></span>\n\n<h1 id=\"The-right-matrix-format-to-load-in-R\"><a href=\"#The-right-matrix-format-to-load-in-R\" class=\"headerlink\" title=\"The right matrix format to load in R\"></a>The right matrix format to load in R</h1><p>If you have tracked my posts, you may remember that I used a bash script to extract a matrix out of a big and complex structured m file (see <a href=\"https://xl0418.github.io/2018/10/29/2018-10-29-sed/\">here</a>). But I mistakenly modified the matrix to fit the matrix format in R.</p>\n<p><img src=\"/2019-03-20-readdatadon/d.png\" alt=\"fig\"> </p>\n<p>What’s wrong with this format? It is a function to call instead of a data to load. Thus if the data in the <code>structure()</code> is very big, like 10000x10000, it is very time-consuming to run the function in R. But our aim is to read the matrix of this size or even larger. It is not supposed to be problematic for R. </p>\n<p>After a while of brainstorm, I kind of thought it might be due to the matrix format and the way I load the data in R. The command <code>source()</code> actually calls the function written in the sourced file.  Thus, to create a matrix by using <code>structure()</code> it is easy to exceed the memory size. </p>\n<p>The solution is that we could use <code>read.csv()</code> to load the data into R, which is much faster and more efficient for large data sets. To achieve that, we need rewrite the raw data in a csv format. The following is how it looks like in the notepad </p>\n<p><img src=\"/2019-03-20-readdatadon/rewrittendata.png\" alt=\"fig\"> </p>\n<p>Notice that the first line is left blank. It is supposed to put the headers for columns. Then we can directly read it in R by using </p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x <span class=\"operator\">=</span> read.csv<span class=\"punctuation\">(</span>data<span class=\"punctuation\">,</span>header <span class=\"operator\">=</span> <span class=\"literal\">FALSE</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>Super fast and it’s done. </p>\n<p>Finally, to extract the matrix from the raw data, you can just follow what I did before (<a href=\"https://xl0418.github.io/2018/10/29/2018-10-29-sed/\">here</a>)). And replace the 6-15th lines with </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A=$(grep -c <span class=\"string\">&#x27;D&#x27;</span>&#123;<span class=\"string\">&#x27;length(D)+1&#x27;</span>&#125;<span class=\"string\">&#x27; = \\[&#x27;</span> HDs<span class=\"string\">&quot;$j<span class=\"variable\">$i</span>&quot;</span>.Rdata)</span><br><span class=\"line\">B=$[<span class=\"variable\">$A</span>-1]</span><br><span class=\"line\">sed <span class=\"string\">&#x27;/D&#x27;</span>&#123;<span class=\"string\">&#x27;length(D)+1&#x27;</span>&#125;<span class=\"string\">&#x27;/&#123;G;s/\\nX\\&#123;&#x27;</span><span class=\"variable\">$B</span><span class=\"string\">&#x27;\\&#125;//;tend;x;s/^/X/;x;P;d&#125;;p;d;:end;s/D&#x27;</span>&#123;<span class=\"string\">&#x27;length(D)+1&#x27;</span>&#125;<span class=\"string\">&#x27;/D/;:a;n;ba&#x27;</span> HDs<span class=\"string\">&quot;$j<span class=\"variable\">$i</span>&quot;</span>.Rdata&gt;HDt<span class=\"string\">&quot;$j<span class=\"variable\">$i</span>&quot;</span>.Rdata</span><br><span class=\"line\">sed -n <span class=\"string\">&#x27;/D = \\[/,/\\];/p&#x27;</span> HDt<span class=\"string\">&quot;$j<span class=\"variable\">$i</span>&quot;</span>.Rdata&gt;HD<span class=\"string\">&quot;$j<span class=\"variable\">$i</span>&quot;</span>.csv</span><br><span class=\"line\">sed -i -e <span class=\"string\">&#x27;s/D = \\[//&#x27;</span> -e <span class=\"string\">&#x27;s/\\];//&#x27;</span> -e <span class=\"string\">&#x27;s/ /,/g&#x27;</span> -e <span class=\"string\">&#x27;s/,;//g&#x27;</span> HD<span class=\"string\">&quot;$j<span class=\"variable\">$i</span>&quot;</span>.csv</span><br></pre></td></tr></table></figure>\n\n<p>where I just replace the space by the comma and delete the first and last line of the raw matrix. The <code>;</code> at the end of each line is also removed.</p>\n<p>Enjoy!</p>\n","site":{"data":{}},"excerpt":"<p>Recently, I was focusing on my 3rd PhD project with mathematical modeling. It was about the extension to the <a href=\"https://www.nature.com/scitable/knowledge/library/neutral-theory-of-species-diversity-13259703\">neutral theory</a>. I am not gonna reveal it now but will bring back in the future.  So I was away from the blog for a while and have to put machine learning series aside, although the derivation of the recurrent neural network is done. It is coming soon as well. Finally, the mathematical model has been done. I have some time to talk something that I’ve been doing except the modeling when waiting for the simulation results. In this post, I am gonna record a silly issue about loading data in R after extracting the a subset of a big data by Bash.  </p>","more":"<h1 id=\"The-right-matrix-format-to-load-in-R\"><a href=\"#The-right-matrix-format-to-load-in-R\" class=\"headerlink\" title=\"The right matrix format to load in R\"></a>The right matrix format to load in R</h1><p>If you have tracked my posts, you may remember that I used a bash script to extract a matrix out of a big and complex structured m file (see <a href=\"https://xl0418.github.io/2018/10/29/2018-10-29-sed/\">here</a>). But I mistakenly modified the matrix to fit the matrix format in R.</p>\n<p><img src=\"/2019-03-20-readdatadon/d.png\" alt=\"fig\"> </p>\n<p>What’s wrong with this format? It is a function to call instead of a data to load. Thus if the data in the <code>structure()</code> is very big, like 10000x10000, it is very time-consuming to run the function in R. But our aim is to read the matrix of this size or even larger. It is not supposed to be problematic for R. </p>\n<p>After a while of brainstorm, I kind of thought it might be due to the matrix format and the way I load the data in R. The command <code>source()</code> actually calls the function written in the sourced file.  Thus, to create a matrix by using <code>structure()</code> it is easy to exceed the memory size. </p>\n<p>The solution is that we could use <code>read.csv()</code> to load the data into R, which is much faster and more efficient for large data sets. To achieve that, we need rewrite the raw data in a csv format. The following is how it looks like in the notepad </p>\n<p><img src=\"/2019-03-20-readdatadon/rewrittendata.png\" alt=\"fig\"> </p>\n<p>Notice that the first line is left blank. It is supposed to put the headers for columns. Then we can directly read it in R by using </p>\n<figure class=\"highlight r\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x <span class=\"operator\">=</span> read.csv<span class=\"punctuation\">(</span>data<span class=\"punctuation\">,</span>header <span class=\"operator\">=</span> <span class=\"literal\">FALSE</span><span class=\"punctuation\">)</span></span><br></pre></td></tr></table></figure>\n\n<p>Super fast and it’s done. </p>\n<p>Finally, to extract the matrix from the raw data, you can just follow what I did before (<a href=\"https://xl0418.github.io/2018/10/29/2018-10-29-sed/\">here</a>)). And replace the 6-15th lines with </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A=$(grep -c <span class=\"string\">&#x27;D&#x27;</span>&#123;<span class=\"string\">&#x27;length(D)+1&#x27;</span>&#125;<span class=\"string\">&#x27; = \\[&#x27;</span> HDs<span class=\"string\">&quot;$j<span class=\"variable\">$i</span>&quot;</span>.Rdata)</span><br><span class=\"line\">B=$[<span class=\"variable\">$A</span>-1]</span><br><span class=\"line\">sed <span class=\"string\">&#x27;/D&#x27;</span>&#123;<span class=\"string\">&#x27;length(D)+1&#x27;</span>&#125;<span class=\"string\">&#x27;/&#123;G;s/\\nX\\&#123;&#x27;</span><span class=\"variable\">$B</span><span class=\"string\">&#x27;\\&#125;//;tend;x;s/^/X/;x;P;d&#125;;p;d;:end;s/D&#x27;</span>&#123;<span class=\"string\">&#x27;length(D)+1&#x27;</span>&#125;<span class=\"string\">&#x27;/D/;:a;n;ba&#x27;</span> HDs<span class=\"string\">&quot;$j<span class=\"variable\">$i</span>&quot;</span>.Rdata&gt;HDt<span class=\"string\">&quot;$j<span class=\"variable\">$i</span>&quot;</span>.Rdata</span><br><span class=\"line\">sed -n <span class=\"string\">&#x27;/D = \\[/,/\\];/p&#x27;</span> HDt<span class=\"string\">&quot;$j<span class=\"variable\">$i</span>&quot;</span>.Rdata&gt;HD<span class=\"string\">&quot;$j<span class=\"variable\">$i</span>&quot;</span>.csv</span><br><span class=\"line\">sed -i -e <span class=\"string\">&#x27;s/D = \\[//&#x27;</span> -e <span class=\"string\">&#x27;s/\\];//&#x27;</span> -e <span class=\"string\">&#x27;s/ /,/g&#x27;</span> -e <span class=\"string\">&#x27;s/,;//g&#x27;</span> HD<span class=\"string\">&quot;$j<span class=\"variable\">$i</span>&quot;</span>.csv</span><br></pre></td></tr></table></figure>\n\n<p>where I just replace the space by the comma and delete the first and last line of the raw matrix. The <code>;</code> at the end of each line is also removed.</p>\n<p>Enjoy!</p>"},{"title":"Approximate Bayesian Computation: standard version and its variant ABC-SMC","date":"2019-06-21T07:00:00.000Z","_content":"\nIn the last few months of my PhD project, it is unimaginable that how busy it could be. You need to focus on the current work to finish them, analyzing data, writing paper, structuring the final thesis etc. whilst think about the future, going to industry or staying in academia. To me, I enjoy the process of researching, learning new techs, tackling with challenges. This is the essential need that I want. The outer environment is to support decorating the need to make the environment attractive. So it feels like clothes to human, no matter what kind of clothes they are their essential function is to cover the body that human wants, keeping warm and comfortable. But undoubtedly if available human is chasing after the most fancy clothes that meet human's additional requirements besides the basic need. Think through this, when I know clearly what I want, what kind of job I want to do is clear, meeting my basic need and seeking the most luxury that I fit. \n\nThe words above are more like a conclusion that I came up with in the last few months and an excuse/explanation of no posting. Here, I would like to record some evolutionary algorithms that I used in the projects I have done and the animations of them. I still have no time to go into the details and cannot post at a normal frequency for a while (at least before my graduation). But I promise I will concretize them in the future.     \n\n<!--more-->\n\n# The standard Approximate Bayesian Computation\n\nWith the development of computer science, people start to be able to solve more problems that are high computationally demanding. In 2013, Toni *et al*. overviewed the standard ABC algorithm and developed a sequential Monte Carlo variant to accelerate the convergence of parameters. This series of ABC-like methods is usually called \"likelihood-free\" method, or more precisely \"analytic likelihood-free method\". The basic idea is that it exploits the computational power of computer to generate large amount of data under the focal model and pick up the parameters that produce the data that is most analogous to the reality. Thus, people claim that the obtained parameters are the most likely parameters to reassemble the truth. \n\nIn my project of studying trait-population model, I modified this method a bit and successfully recovered the model parameters from simulation experiments. Later on, I applied our model to baleen whales and found the baleen whales are undergoing a weak environmental adaptation and a relatively strong competition (paper submitted soon).\n\nHere, I would like to show you an animation of how ABC algorithm works.  \n\n<video width=\"100%\" height=\"800\" src=\"MCMC3chains_test3.mp4\" controls=\"controls\">\nThe `<video>` tag is not supported by your browser.\n</video>\n\nIn the video, three Monte Carlo chains are deployed. They are independent of each other, exploring the parameter space from different initial conditions. Normally, it is hard to judge when the chain converges. So, you need to run a long time to check. One alternative way is to calculate the autocorrelation of the chain. You can google that if you want to know more details. \n\n# ABC-SMC for parameter estimation and model selection\n\nApproximate Bayesian Computation-Sequential Monte Carlo algorithm is an parallelized extension to the standard ABC algorithm. The basic idea is to do many sample simulations at one generation. Then, the best fit parameters are chosen to gain higher weight to be sampled in the next generation. With the generation proceeds, the best fit parameters converge to the \"true values\". To do model selection, the models are simply treated as one parameter but at a sequential level advanced to the other parameters. That means you need to chose models first and then sample parameters to complete the sampling process.\n\nThe following figure shows how the samples converges to the true value for parameter estimation. It started with a uniform prior information of &alpha;.\n![fig](2019-06-21-ABCalgorithm/Rplot2.png) \n\nThe following figure shows how model selection works under ABC-SMC algorithm. The details are coming in the future.\n![fig](2019-06-21-ABCalgorithm/modelseleSMC.png) \n\n","source":"_posts/2019-06-21-ABCalgorithm.md","raw":"---\ntitle: \"Approximate Bayesian Computation: standard version and its variant ABC-SMC\"\ncategories: [Research,Algorithm,ABC]\ntags: [data analysis, ABC, Animation]\ndate: 2019-06-21\n\n---\n\nIn the last few months of my PhD project, it is unimaginable that how busy it could be. You need to focus on the current work to finish them, analyzing data, writing paper, structuring the final thesis etc. whilst think about the future, going to industry or staying in academia. To me, I enjoy the process of researching, learning new techs, tackling with challenges. This is the essential need that I want. The outer environment is to support decorating the need to make the environment attractive. So it feels like clothes to human, no matter what kind of clothes they are their essential function is to cover the body that human wants, keeping warm and comfortable. But undoubtedly if available human is chasing after the most fancy clothes that meet human's additional requirements besides the basic need. Think through this, when I know clearly what I want, what kind of job I want to do is clear, meeting my basic need and seeking the most luxury that I fit. \n\nThe words above are more like a conclusion that I came up with in the last few months and an excuse/explanation of no posting. Here, I would like to record some evolutionary algorithms that I used in the projects I have done and the animations of them. I still have no time to go into the details and cannot post at a normal frequency for a while (at least before my graduation). But I promise I will concretize them in the future.     \n\n<!--more-->\n\n# The standard Approximate Bayesian Computation\n\nWith the development of computer science, people start to be able to solve more problems that are high computationally demanding. In 2013, Toni *et al*. overviewed the standard ABC algorithm and developed a sequential Monte Carlo variant to accelerate the convergence of parameters. This series of ABC-like methods is usually called \"likelihood-free\" method, or more precisely \"analytic likelihood-free method\". The basic idea is that it exploits the computational power of computer to generate large amount of data under the focal model and pick up the parameters that produce the data that is most analogous to the reality. Thus, people claim that the obtained parameters are the most likely parameters to reassemble the truth. \n\nIn my project of studying trait-population model, I modified this method a bit and successfully recovered the model parameters from simulation experiments. Later on, I applied our model to baleen whales and found the baleen whales are undergoing a weak environmental adaptation and a relatively strong competition (paper submitted soon).\n\nHere, I would like to show you an animation of how ABC algorithm works.  \n\n<video width=\"100%\" height=\"800\" src=\"MCMC3chains_test3.mp4\" controls=\"controls\">\nThe `<video>` tag is not supported by your browser.\n</video>\n\nIn the video, three Monte Carlo chains are deployed. They are independent of each other, exploring the parameter space from different initial conditions. Normally, it is hard to judge when the chain converges. So, you need to run a long time to check. One alternative way is to calculate the autocorrelation of the chain. You can google that if you want to know more details. \n\n# ABC-SMC for parameter estimation and model selection\n\nApproximate Bayesian Computation-Sequential Monte Carlo algorithm is an parallelized extension to the standard ABC algorithm. The basic idea is to do many sample simulations at one generation. Then, the best fit parameters are chosen to gain higher weight to be sampled in the next generation. With the generation proceeds, the best fit parameters converge to the \"true values\". To do model selection, the models are simply treated as one parameter but at a sequential level advanced to the other parameters. That means you need to chose models first and then sample parameters to complete the sampling process.\n\nThe following figure shows how the samples converges to the true value for parameter estimation. It started with a uniform prior information of &alpha;.\n![fig](2019-06-21-ABCalgorithm/Rplot2.png) \n\nThe following figure shows how model selection works under ABC-SMC algorithm. The details are coming in the future.\n![fig](2019-06-21-ABCalgorithm/modelseleSMC.png) \n\n","slug":"2019-06-21-ABCalgorithm","published":1,"updated":"2022-09-17T02:04:05.179Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl85g865y00194gkrbl9422jq","content":"<p>In the last few months of my PhD project, it is unimaginable that how busy it could be. You need to focus on the current work to finish them, analyzing data, writing paper, structuring the final thesis etc. whilst think about the future, going to industry or staying in academia. To me, I enjoy the process of researching, learning new techs, tackling with challenges. This is the essential need that I want. The outer environment is to support decorating the need to make the environment attractive. So it feels like clothes to human, no matter what kind of clothes they are their essential function is to cover the body that human wants, keeping warm and comfortable. But undoubtedly if available human is chasing after the most fancy clothes that meet human’s additional requirements besides the basic need. Think through this, when I know clearly what I want, what kind of job I want to do is clear, meeting my basic need and seeking the most luxury that I fit. </p>\n<p>The words above are more like a conclusion that I came up with in the last few months and an excuse&#x2F;explanation of no posting. Here, I would like to record some evolutionary algorithms that I used in the projects I have done and the animations of them. I still have no time to go into the details and cannot post at a normal frequency for a while (at least before my graduation). But I promise I will concretize them in the future.     </p>\n<span id=\"more\"></span>\n\n<h1 id=\"The-standard-Approximate-Bayesian-Computation\"><a href=\"#The-standard-Approximate-Bayesian-Computation\" class=\"headerlink\" title=\"The standard Approximate Bayesian Computation\"></a>The standard Approximate Bayesian Computation</h1><p>With the development of computer science, people start to be able to solve more problems that are high computationally demanding. In 2013, Toni <em>et al</em>. overviewed the standard ABC algorithm and developed a sequential Monte Carlo variant to accelerate the convergence of parameters. This series of ABC-like methods is usually called “likelihood-free” method, or more precisely “analytic likelihood-free method”. The basic idea is that it exploits the computational power of computer to generate large amount of data under the focal model and pick up the parameters that produce the data that is most analogous to the reality. Thus, people claim that the obtained parameters are the most likely parameters to reassemble the truth. </p>\n<p>In my project of studying trait-population model, I modified this method a bit and successfully recovered the model parameters from simulation experiments. Later on, I applied our model to baleen whales and found the baleen whales are undergoing a weak environmental adaptation and a relatively strong competition (paper submitted soon).</p>\n<p>Here, I would like to show you an animation of how ABC algorithm works.  </p>\n<video width=\"100%\" height=\"800\" src=\"MCMC3chains_test3.mp4\" controls=\"controls\">\nThe `<video>` tag is not supported by your browser.\n</video>\n\n<p>In the video, three Monte Carlo chains are deployed. They are independent of each other, exploring the parameter space from different initial conditions. Normally, it is hard to judge when the chain converges. So, you need to run a long time to check. One alternative way is to calculate the autocorrelation of the chain. You can google that if you want to know more details. </p>\n<h1 id=\"ABC-SMC-for-parameter-estimation-and-model-selection\"><a href=\"#ABC-SMC-for-parameter-estimation-and-model-selection\" class=\"headerlink\" title=\"ABC-SMC for parameter estimation and model selection\"></a>ABC-SMC for parameter estimation and model selection</h1><p>Approximate Bayesian Computation-Sequential Monte Carlo algorithm is an parallelized extension to the standard ABC algorithm. The basic idea is to do many sample simulations at one generation. Then, the best fit parameters are chosen to gain higher weight to be sampled in the next generation. With the generation proceeds, the best fit parameters converge to the “true values”. To do model selection, the models are simply treated as one parameter but at a sequential level advanced to the other parameters. That means you need to chose models first and then sample parameters to complete the sampling process.</p>\n<p>The following figure shows how the samples converges to the true value for parameter estimation. It started with a uniform prior information of &amp;alpha;.<br><img src=\"/2019-06-21-ABCalgorithm/Rplot2.png\" alt=\"fig\"> </p>\n<p>The following figure shows how model selection works under ABC-SMC algorithm. The details are coming in the future.<br><img src=\"/2019-06-21-ABCalgorithm/modelseleSMC.png\" alt=\"fig\"> </p>\n","site":{"data":{}},"excerpt":"<p>In the last few months of my PhD project, it is unimaginable that how busy it could be. You need to focus on the current work to finish them, analyzing data, writing paper, structuring the final thesis etc. whilst think about the future, going to industry or staying in academia. To me, I enjoy the process of researching, learning new techs, tackling with challenges. This is the essential need that I want. The outer environment is to support decorating the need to make the environment attractive. So it feels like clothes to human, no matter what kind of clothes they are their essential function is to cover the body that human wants, keeping warm and comfortable. But undoubtedly if available human is chasing after the most fancy clothes that meet human’s additional requirements besides the basic need. Think through this, when I know clearly what I want, what kind of job I want to do is clear, meeting my basic need and seeking the most luxury that I fit. </p>\n<p>The words above are more like a conclusion that I came up with in the last few months and an excuse&#x2F;explanation of no posting. Here, I would like to record some evolutionary algorithms that I used in the projects I have done and the animations of them. I still have no time to go into the details and cannot post at a normal frequency for a while (at least before my graduation). But I promise I will concretize them in the future.     </p>","more":"<h1 id=\"The-standard-Approximate-Bayesian-Computation\"><a href=\"#The-standard-Approximate-Bayesian-Computation\" class=\"headerlink\" title=\"The standard Approximate Bayesian Computation\"></a>The standard Approximate Bayesian Computation</h1><p>With the development of computer science, people start to be able to solve more problems that are high computationally demanding. In 2013, Toni <em>et al</em>. overviewed the standard ABC algorithm and developed a sequential Monte Carlo variant to accelerate the convergence of parameters. This series of ABC-like methods is usually called “likelihood-free” method, or more precisely “analytic likelihood-free method”. The basic idea is that it exploits the computational power of computer to generate large amount of data under the focal model and pick up the parameters that produce the data that is most analogous to the reality. Thus, people claim that the obtained parameters are the most likely parameters to reassemble the truth. </p>\n<p>In my project of studying trait-population model, I modified this method a bit and successfully recovered the model parameters from simulation experiments. Later on, I applied our model to baleen whales and found the baleen whales are undergoing a weak environmental adaptation and a relatively strong competition (paper submitted soon).</p>\n<p>Here, I would like to show you an animation of how ABC algorithm works.  </p>\n<video width=\"100%\" height=\"800\" src=\"MCMC3chains_test3.mp4\" controls=\"controls\">\nThe `<video>` tag is not supported by your browser.\n</video>\n\n<p>In the video, three Monte Carlo chains are deployed. They are independent of each other, exploring the parameter space from different initial conditions. Normally, it is hard to judge when the chain converges. So, you need to run a long time to check. One alternative way is to calculate the autocorrelation of the chain. You can google that if you want to know more details. </p>\n<h1 id=\"ABC-SMC-for-parameter-estimation-and-model-selection\"><a href=\"#ABC-SMC-for-parameter-estimation-and-model-selection\" class=\"headerlink\" title=\"ABC-SMC for parameter estimation and model selection\"></a>ABC-SMC for parameter estimation and model selection</h1><p>Approximate Bayesian Computation-Sequential Monte Carlo algorithm is an parallelized extension to the standard ABC algorithm. The basic idea is to do many sample simulations at one generation. Then, the best fit parameters are chosen to gain higher weight to be sampled in the next generation. With the generation proceeds, the best fit parameters converge to the “true values”. To do model selection, the models are simply treated as one parameter but at a sequential level advanced to the other parameters. That means you need to chose models first and then sample parameters to complete the sampling process.</p>\n<p>The following figure shows how the samples converges to the true value for parameter estimation. It started with a uniform prior information of &amp;alpha;.<br><img src=\"/2019-06-21-ABCalgorithm/Rplot2.png\" alt=\"fig\"> </p>\n<p>The following figure shows how model selection works under ABC-SMC algorithm. The details are coming in the future.<br><img src=\"/2019-06-21-ABCalgorithm/modelseleSMC.png\" alt=\"fig\"> </p>"},{"title":"An animation to show how traits of species evolve with their abundance","date":"2019-06-21T07:00:00.000Z","_content":"\nDo you like comics? I am a comics fan, majorly favoring Japanese comics and some Chinese comics with the rise of Chinese comics industry in recent years. Why do I mention this? I mean to say drawings are usually the most straight way to express abstract ideas. This is why I want to show an animation of our model to explain such complex mechanism instead of using tons of papers filled with equations.   \n\n<!--more-->\n\n# An animation of trait-population coevolution for a single attraction\n\nWe have constructed a mathematical model to describe how traits of species interplay with their abundance under environmental adaptation and competition along a phylogenetic tree. For simplicity, we assume one attraction in the community that pull traits evolve toward one single optimum trait that better utilize natural resource. In this model, population dynamics weight the species' competitive power, i.e. the species with large population size gains more competitive power. We would like to see what kind of trait pattern under such mechanism. The animation below shows how it works along a given phylogenetic tree.  \n \n<video width=\"100%\" height=\"800\" src=\"singlespecies5.mp4\" controls=\"controls\">\nThe `<video>` tag is not supported by your browser.\n</video>\n\nThe video is consisting of two models showing different magnitude of attraction towards the optimum for 5 species. The area of red dots denote the population size of that species.\\\\(x\\\\) axis denotes the evolutionary time while \\\\(y\\\\) denotes the trait values. The optimum trait is assumed as 0 without loss of generality. The highlighted by green lineage is the destined species giving birth and going extinct. More details are coming after the paper submission.  \n\n# An animation of trait-population coevolution for multiple attractions\n\nIn the following video, 15 species are evolving under 5 attractions. You can see how they compete with each other and explore the new niches. \n\n<video width=\"100%\" height=\"800\" src=\"multi6species15.mp4\" controls=\"controls\">\nThe `<video>` tag is not supported by your browser.\n</video>\n\nHave fun!\n\n<img src=\"2019-06-21-TPmodel/guixianren_s.png\" width=\"50%\" height=\"50%\">\n","source":"_posts/2019-06-21-TPmodel.md","raw":"---\ntitle: \"An animation to show how traits of species evolve with their abundance\"\ncategories: [Research,Phd projects,trait-population model]\ntags: [Animation,ecology, evolution]\ndate: 2019-06-21\n\n---\n\nDo you like comics? I am a comics fan, majorly favoring Japanese comics and some Chinese comics with the rise of Chinese comics industry in recent years. Why do I mention this? I mean to say drawings are usually the most straight way to express abstract ideas. This is why I want to show an animation of our model to explain such complex mechanism instead of using tons of papers filled with equations.   \n\n<!--more-->\n\n# An animation of trait-population coevolution for a single attraction\n\nWe have constructed a mathematical model to describe how traits of species interplay with their abundance under environmental adaptation and competition along a phylogenetic tree. For simplicity, we assume one attraction in the community that pull traits evolve toward one single optimum trait that better utilize natural resource. In this model, population dynamics weight the species' competitive power, i.e. the species with large population size gains more competitive power. We would like to see what kind of trait pattern under such mechanism. The animation below shows how it works along a given phylogenetic tree.  \n \n<video width=\"100%\" height=\"800\" src=\"singlespecies5.mp4\" controls=\"controls\">\nThe `<video>` tag is not supported by your browser.\n</video>\n\nThe video is consisting of two models showing different magnitude of attraction towards the optimum for 5 species. The area of red dots denote the population size of that species.\\\\(x\\\\) axis denotes the evolutionary time while \\\\(y\\\\) denotes the trait values. The optimum trait is assumed as 0 without loss of generality. The highlighted by green lineage is the destined species giving birth and going extinct. More details are coming after the paper submission.  \n\n# An animation of trait-population coevolution for multiple attractions\n\nIn the following video, 15 species are evolving under 5 attractions. You can see how they compete with each other and explore the new niches. \n\n<video width=\"100%\" height=\"800\" src=\"multi6species15.mp4\" controls=\"controls\">\nThe `<video>` tag is not supported by your browser.\n</video>\n\nHave fun!\n\n<img src=\"2019-06-21-TPmodel/guixianren_s.png\" width=\"50%\" height=\"50%\">\n","slug":"2019-06-21-TPmodel","published":1,"updated":"2022-09-17T02:04:05.231Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl85g865z001d4gkrhndx6250","content":"<p>Do you like comics? I am a comics fan, majorly favoring Japanese comics and some Chinese comics with the rise of Chinese comics industry in recent years. Why do I mention this? I mean to say drawings are usually the most straight way to express abstract ideas. This is why I want to show an animation of our model to explain such complex mechanism instead of using tons of papers filled with equations.   </p>\n<span id=\"more\"></span>\n\n<h1 id=\"An-animation-of-trait-population-coevolution-for-a-single-attraction\"><a href=\"#An-animation-of-trait-population-coevolution-for-a-single-attraction\" class=\"headerlink\" title=\"An animation of trait-population coevolution for a single attraction\"></a>An animation of trait-population coevolution for a single attraction</h1><p>We have constructed a mathematical model to describe how traits of species interplay with their abundance under environmental adaptation and competition along a phylogenetic tree. For simplicity, we assume one attraction in the community that pull traits evolve toward one single optimum trait that better utilize natural resource. In this model, population dynamics weight the species’ competitive power, i.e. the species with large population size gains more competitive power. We would like to see what kind of trait pattern under such mechanism. The animation below shows how it works along a given phylogenetic tree.  </p>\n<video width=\"100%\" height=\"800\" src=\"singlespecies5.mp4\" controls=\"controls\">\nThe `<video>` tag is not supported by your browser.\n</video>\n\n<p>The video is consisting of two models showing different magnitude of attraction towards the optimum for 5 species. The area of red dots denote the population size of that species.\\(x\\) axis denotes the evolutionary time while \\(y\\) denotes the trait values. The optimum trait is assumed as 0 without loss of generality. The highlighted by green lineage is the destined species giving birth and going extinct. More details are coming after the paper submission.  </p>\n<h1 id=\"An-animation-of-trait-population-coevolution-for-multiple-attractions\"><a href=\"#An-animation-of-trait-population-coevolution-for-multiple-attractions\" class=\"headerlink\" title=\"An animation of trait-population coevolution for multiple attractions\"></a>An animation of trait-population coevolution for multiple attractions</h1><p>In the following video, 15 species are evolving under 5 attractions. You can see how they compete with each other and explore the new niches. </p>\n<video width=\"100%\" height=\"800\" src=\"multi6species15.mp4\" controls=\"controls\">\nThe `<video>` tag is not supported by your browser.\n</video>\n\n<p>Have fun!</p>\n<img src=\"2019-06-21-TPmodel/guixianren_s.png\" width=\"50%\" height=\"50%\">\n","site":{"data":{}},"excerpt":"<p>Do you like comics? I am a comics fan, majorly favoring Japanese comics and some Chinese comics with the rise of Chinese comics industry in recent years. Why do I mention this? I mean to say drawings are usually the most straight way to express abstract ideas. This is why I want to show an animation of our model to explain such complex mechanism instead of using tons of papers filled with equations.   </p>","more":"<h1 id=\"An-animation-of-trait-population-coevolution-for-a-single-attraction\"><a href=\"#An-animation-of-trait-population-coevolution-for-a-single-attraction\" class=\"headerlink\" title=\"An animation of trait-population coevolution for a single attraction\"></a>An animation of trait-population coevolution for a single attraction</h1><p>We have constructed a mathematical model to describe how traits of species interplay with their abundance under environmental adaptation and competition along a phylogenetic tree. For simplicity, we assume one attraction in the community that pull traits evolve toward one single optimum trait that better utilize natural resource. In this model, population dynamics weight the species’ competitive power, i.e. the species with large population size gains more competitive power. We would like to see what kind of trait pattern under such mechanism. The animation below shows how it works along a given phylogenetic tree.  </p>\n<video width=\"100%\" height=\"800\" src=\"singlespecies5.mp4\" controls=\"controls\">\nThe `<video>` tag is not supported by your browser.\n</video>\n\n<p>The video is consisting of two models showing different magnitude of attraction towards the optimum for 5 species. The area of red dots denote the population size of that species.\\(x\\) axis denotes the evolutionary time while \\(y\\) denotes the trait values. The optimum trait is assumed as 0 without loss of generality. The highlighted by green lineage is the destined species giving birth and going extinct. More details are coming after the paper submission.  </p>\n<h1 id=\"An-animation-of-trait-population-coevolution-for-multiple-attractions\"><a href=\"#An-animation-of-trait-population-coevolution-for-multiple-attractions\" class=\"headerlink\" title=\"An animation of trait-population coevolution for multiple attractions\"></a>An animation of trait-population coevolution for multiple attractions</h1><p>In the following video, 15 species are evolving under 5 attractions. You can see how they compete with each other and explore the new niches. </p>\n<video width=\"100%\" height=\"800\" src=\"multi6species15.mp4\" controls=\"controls\">\nThe `<video>` tag is not supported by your browser.\n</video>\n\n<p>Have fun!</p>\n<img src=\"2019-06-21-TPmodel/guixianren_s.png\" width=\"50%\" height=\"50%\">"},{"title":"GUI your model - a way to sell theoretical models to empiricists ","date":"2020-03-09T07:00:00.000Z","_content":"\nThesis submitted! Finally, I could have a bit of time to update this blog before getting feedback from reviewers of two submitted papers. So, I will dig several pits as what I did before and see if in the future I could fill them : - ) The first pit stems from my thinking of that how we, biological theoritians, are able to sell  our work to empiricists. Our work and interest are to stablish complex mathematical models to mimic biological processes to reveal the underlying mechanisms, which form the observed phenomenon. We could code the processes, do statistic analysis to select the most prominent mechanism, infer the likely generating parameters. However, empiricists may have problems even setting up an environment for a programming language in which we used to deploy our models as their focuses are on field or lab experiments which I have not a clue of what they are (exaggerated).  Therefore, to bridge the worlds of empiricists and theoritians, a concrete tool is imperative. GUI (Graphical User Interface) of an abstract model is the right way. (This is the way!  -- Mandalorian).  In this blog, I introduce one GUI example of my model and show how it works within a few clicks. \n\n<!--more-->\n\n# A brief introduction of the trait evolution model\n\nDiversity in traits of species has long been intriguing to biologists. One of the most famous examples is the Galápagos finches, which is also known as Darwin finches. Darwin's Finches comprise a group of about 15 species. Their beak sizes are evidenced to associate with the size of seeds that are available in environment, showing apparent evolutionary evidence responding to ecological changes. In the species *Geospiza fortis*, people found that the beak size of the birds is larger when large seeds are more available. Conversely, when small seeds become more available for some years, small beaks are pervasive in the population.\n\nIn our model of trait evolution with population dynamics, we incorporate the phylogenetic information into consideration. Furthermore, abundance of species plays a role in species interaction, hence,  tunes the trait evolution pace. An animation has been posted before [here](https://xl0418.github.io/2019/06/21/2019-06-21-TPmodel/), which illustrates how the traits of species evolve along a given phylogeny. The manuscript is under review. Details can be found there once it gets published.  \n\nWith this model, empiricists can input the phylogenies and simulate the traits of interest. Using approximate Bayesian computation methods and comparing the simulated traits with the observed traits, one can infer the strength of the environment stabilizing selection and competition. The purpose of designing a GUI is to free empiricists hands from implementing the code. Instead, only a few clicks can do all the work.\n\n# GUI \n\nI use `tkinter` to develop the GUI. It has an exhaustive [document](https://docs.python.org/3/library/tkinter.html) to help you get familiar with it. So, I am not ganna show you how to code it. You can find the code [here](https://github.com/xl0418/Trait_pop_model_sim/tree/UI-branch). But I would like to show you why empiricists would love it!\n\nThe whole model and nearly all its functions are wrapped into this interface.  \n\n<img src=\"2020-03-09-GUI-traitevolution/p1.png\" width=\"100%\" height=\"100%\">\n\nIn the page of Parameter Inference, users can specify their own phylogenies with observed traits data and also assign a folder to store the output. The structure of the algorithm (ABC) can be set by giving the number of iterations and particles for each iteration. The larger the values are, the accurate the inference is. But it also takes longer time for computation. Parallel computation has been implemented with threads being indicating how many threads you want to exploit. We have three summary statistics to compare the similarity between the simulated traits and the empirical traits. Details can be found in the paper. \n\nAs usually we don't know how many iterations are sufficient to get a good enough result, we may start with a small number of iterations to check if the results converge. If not, we can continue with this Continue Parameter Inference page.   <img src=\"2020-03-09-GUI-traitevolution/p2.png\" width=\"100%\" height=\"100%\">\n\nIn this page, one additional setting appears. You can specify the previous result on which you want to continue. Then, set a continue number of the iterations while the number of the particles inherits from the previous result. This page offers a choice of cutting jobs into pieces and running them at different time. \n\nAlthough ABC approach is a nice likelihood-free method for parameter inference, high computational demanding limits its applicability. Normally, I need to work with a cluster to free my desktop for other works. So in the page of Generate Cluster Scripts, one can set all parameters aforementioned and click one button to generate a script to submit jobs on the cluster. This is one example of the peregrine cluster of the University of Groningen. You can modify it accordingly.   <img src=\"2020-03-09-GUI-traitevolution/p3.png\" width=\"100%\" height=\"100%\">\n\nFurthermore, one can even do data analysis on the results by using GUI. Here, I set a plotting function to investigate the distributions of the estimated parameters. \n\n  <img src=\"2020-03-09-GUI-traitevolution/p4.png\" width=\"100%\" height=\"100%\">\n\nMore functions can be developed. With GUI, empiricists would love to try theoritian's models. One may argue that it is convenient but the model is hidden behind the interface so that it lost the model's plasticity. Well, when you succeed to attract empiricists' attention, GUI's job is done. Further model adjustification relies on collaboration. You have already sold your work!  \n\n ","source":"_posts/2020-03-09-GUI-traitevolution.md","raw":"---\ntitle: \"GUI your model - a way to sell theoretical models to empiricists \"\ncategories: [Research,Python, GUI]\ntags: [Python,GUI, models]\ndate: 2020-03-09\n\n---\n\nThesis submitted! Finally, I could have a bit of time to update this blog before getting feedback from reviewers of two submitted papers. So, I will dig several pits as what I did before and see if in the future I could fill them : - ) The first pit stems from my thinking of that how we, biological theoritians, are able to sell  our work to empiricists. Our work and interest are to stablish complex mathematical models to mimic biological processes to reveal the underlying mechanisms, which form the observed phenomenon. We could code the processes, do statistic analysis to select the most prominent mechanism, infer the likely generating parameters. However, empiricists may have problems even setting up an environment for a programming language in which we used to deploy our models as their focuses are on field or lab experiments which I have not a clue of what they are (exaggerated).  Therefore, to bridge the worlds of empiricists and theoritians, a concrete tool is imperative. GUI (Graphical User Interface) of an abstract model is the right way. (This is the way!  -- Mandalorian).  In this blog, I introduce one GUI example of my model and show how it works within a few clicks. \n\n<!--more-->\n\n# A brief introduction of the trait evolution model\n\nDiversity in traits of species has long been intriguing to biologists. One of the most famous examples is the Galápagos finches, which is also known as Darwin finches. Darwin's Finches comprise a group of about 15 species. Their beak sizes are evidenced to associate with the size of seeds that are available in environment, showing apparent evolutionary evidence responding to ecological changes. In the species *Geospiza fortis*, people found that the beak size of the birds is larger when large seeds are more available. Conversely, when small seeds become more available for some years, small beaks are pervasive in the population.\n\nIn our model of trait evolution with population dynamics, we incorporate the phylogenetic information into consideration. Furthermore, abundance of species plays a role in species interaction, hence,  tunes the trait evolution pace. An animation has been posted before [here](https://xl0418.github.io/2019/06/21/2019-06-21-TPmodel/), which illustrates how the traits of species evolve along a given phylogeny. The manuscript is under review. Details can be found there once it gets published.  \n\nWith this model, empiricists can input the phylogenies and simulate the traits of interest. Using approximate Bayesian computation methods and comparing the simulated traits with the observed traits, one can infer the strength of the environment stabilizing selection and competition. The purpose of designing a GUI is to free empiricists hands from implementing the code. Instead, only a few clicks can do all the work.\n\n# GUI \n\nI use `tkinter` to develop the GUI. It has an exhaustive [document](https://docs.python.org/3/library/tkinter.html) to help you get familiar with it. So, I am not ganna show you how to code it. You can find the code [here](https://github.com/xl0418/Trait_pop_model_sim/tree/UI-branch). But I would like to show you why empiricists would love it!\n\nThe whole model and nearly all its functions are wrapped into this interface.  \n\n<img src=\"2020-03-09-GUI-traitevolution/p1.png\" width=\"100%\" height=\"100%\">\n\nIn the page of Parameter Inference, users can specify their own phylogenies with observed traits data and also assign a folder to store the output. The structure of the algorithm (ABC) can be set by giving the number of iterations and particles for each iteration. The larger the values are, the accurate the inference is. But it also takes longer time for computation. Parallel computation has been implemented with threads being indicating how many threads you want to exploit. We have three summary statistics to compare the similarity between the simulated traits and the empirical traits. Details can be found in the paper. \n\nAs usually we don't know how many iterations are sufficient to get a good enough result, we may start with a small number of iterations to check if the results converge. If not, we can continue with this Continue Parameter Inference page.   <img src=\"2020-03-09-GUI-traitevolution/p2.png\" width=\"100%\" height=\"100%\">\n\nIn this page, one additional setting appears. You can specify the previous result on which you want to continue. Then, set a continue number of the iterations while the number of the particles inherits from the previous result. This page offers a choice of cutting jobs into pieces and running them at different time. \n\nAlthough ABC approach is a nice likelihood-free method for parameter inference, high computational demanding limits its applicability. Normally, I need to work with a cluster to free my desktop for other works. So in the page of Generate Cluster Scripts, one can set all parameters aforementioned and click one button to generate a script to submit jobs on the cluster. This is one example of the peregrine cluster of the University of Groningen. You can modify it accordingly.   <img src=\"2020-03-09-GUI-traitevolution/p3.png\" width=\"100%\" height=\"100%\">\n\nFurthermore, one can even do data analysis on the results by using GUI. Here, I set a plotting function to investigate the distributions of the estimated parameters. \n\n  <img src=\"2020-03-09-GUI-traitevolution/p4.png\" width=\"100%\" height=\"100%\">\n\nMore functions can be developed. With GUI, empiricists would love to try theoritian's models. One may argue that it is convenient but the model is hidden behind the interface so that it lost the model's plasticity. Well, when you succeed to attract empiricists' attention, GUI's job is done. Further model adjustification relies on collaboration. You have already sold your work!  \n\n ","slug":"2020-03-09-GUI-traitevolution","published":1,"updated":"2022-09-17T02:04:05.591Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl85g8660001f4gkrd9x3gder","content":"<p>Thesis submitted! Finally, I could have a bit of time to update this blog before getting feedback from reviewers of two submitted papers. So, I will dig several pits as what I did before and see if in the future I could fill them : - ) The first pit stems from my thinking of that how we, biological theoritians, are able to sell  our work to empiricists. Our work and interest are to stablish complex mathematical models to mimic biological processes to reveal the underlying mechanisms, which form the observed phenomenon. We could code the processes, do statistic analysis to select the most prominent mechanism, infer the likely generating parameters. However, empiricists may have problems even setting up an environment for a programming language in which we used to deploy our models as their focuses are on field or lab experiments which I have not a clue of what they are (exaggerated).  Therefore, to bridge the worlds of empiricists and theoritians, a concrete tool is imperative. GUI (Graphical User Interface) of an abstract model is the right way. (This is the way!  – Mandalorian).  In this blog, I introduce one GUI example of my model and show how it works within a few clicks. </p>\n<span id=\"more\"></span>\n\n<h1 id=\"A-brief-introduction-of-the-trait-evolution-model\"><a href=\"#A-brief-introduction-of-the-trait-evolution-model\" class=\"headerlink\" title=\"A brief introduction of the trait evolution model\"></a>A brief introduction of the trait evolution model</h1><p>Diversity in traits of species has long been intriguing to biologists. One of the most famous examples is the Galápagos finches, which is also known as Darwin finches. Darwin’s Finches comprise a group of about 15 species. Their beak sizes are evidenced to associate with the size of seeds that are available in environment, showing apparent evolutionary evidence responding to ecological changes. In the species <em>Geospiza fortis</em>, people found that the beak size of the birds is larger when large seeds are more available. Conversely, when small seeds become more available for some years, small beaks are pervasive in the population.</p>\n<p>In our model of trait evolution with population dynamics, we incorporate the phylogenetic information into consideration. Furthermore, abundance of species plays a role in species interaction, hence,  tunes the trait evolution pace. An animation has been posted before <a href=\"https://xl0418.github.io/2019/06/21/2019-06-21-TPmodel/\">here</a>, which illustrates how the traits of species evolve along a given phylogeny. The manuscript is under review. Details can be found there once it gets published.  </p>\n<p>With this model, empiricists can input the phylogenies and simulate the traits of interest. Using approximate Bayesian computation methods and comparing the simulated traits with the observed traits, one can infer the strength of the environment stabilizing selection and competition. The purpose of designing a GUI is to free empiricists hands from implementing the code. Instead, only a few clicks can do all the work.</p>\n<h1 id=\"GUI\"><a href=\"#GUI\" class=\"headerlink\" title=\"GUI\"></a>GUI</h1><p>I use <code>tkinter</code> to develop the GUI. It has an exhaustive <a href=\"https://docs.python.org/3/library/tkinter.html\">document</a> to help you get familiar with it. So, I am not ganna show you how to code it. You can find the code <a href=\"https://github.com/xl0418/Trait_pop_model_sim/tree/UI-branch\">here</a>. But I would like to show you why empiricists would love it!</p>\n<p>The whole model and nearly all its functions are wrapped into this interface.  </p>\n<img src=\"2020-03-09-GUI-traitevolution/p1.png\" width=\"100%\" height=\"100%\">\n\n<p>In the page of Parameter Inference, users can specify their own phylogenies with observed traits data and also assign a folder to store the output. The structure of the algorithm (ABC) can be set by giving the number of iterations and particles for each iteration. The larger the values are, the accurate the inference is. But it also takes longer time for computation. Parallel computation has been implemented with threads being indicating how many threads you want to exploit. We have three summary statistics to compare the similarity between the simulated traits and the empirical traits. Details can be found in the paper. </p>\n<p>As usually we don’t know how many iterations are sufficient to get a good enough result, we may start with a small number of iterations to check if the results converge. If not, we can continue with this Continue Parameter Inference page.   <img src=\"2020-03-09-GUI-traitevolution/p2.png\" width=\"100%\" height=\"100%\"></p>\n<p>In this page, one additional setting appears. You can specify the previous result on which you want to continue. Then, set a continue number of the iterations while the number of the particles inherits from the previous result. This page offers a choice of cutting jobs into pieces and running them at different time. </p>\n<p>Although ABC approach is a nice likelihood-free method for parameter inference, high computational demanding limits its applicability. Normally, I need to work with a cluster to free my desktop for other works. So in the page of Generate Cluster Scripts, one can set all parameters aforementioned and click one button to generate a script to submit jobs on the cluster. This is one example of the peregrine cluster of the University of Groningen. You can modify it accordingly.   <img src=\"2020-03-09-GUI-traitevolution/p3.png\" width=\"100%\" height=\"100%\"></p>\n<p>Furthermore, one can even do data analysis on the results by using GUI. Here, I set a plotting function to investigate the distributions of the estimated parameters. </p>\n  <img src=\"2020-03-09-GUI-traitevolution/p4.png\" width=\"100%\" height=\"100%\">\n\n<p>More functions can be developed. With GUI, empiricists would love to try theoritian’s models. One may argue that it is convenient but the model is hidden behind the interface so that it lost the model’s plasticity. Well, when you succeed to attract empiricists’ attention, GUI’s job is done. Further model adjustification relies on collaboration. You have already sold your work!  </p>\n","site":{"data":{}},"excerpt":"<p>Thesis submitted! Finally, I could have a bit of time to update this blog before getting feedback from reviewers of two submitted papers. So, I will dig several pits as what I did before and see if in the future I could fill them : - ) The first pit stems from my thinking of that how we, biological theoritians, are able to sell  our work to empiricists. Our work and interest are to stablish complex mathematical models to mimic biological processes to reveal the underlying mechanisms, which form the observed phenomenon. We could code the processes, do statistic analysis to select the most prominent mechanism, infer the likely generating parameters. However, empiricists may have problems even setting up an environment for a programming language in which we used to deploy our models as their focuses are on field or lab experiments which I have not a clue of what they are (exaggerated).  Therefore, to bridge the worlds of empiricists and theoritians, a concrete tool is imperative. GUI (Graphical User Interface) of an abstract model is the right way. (This is the way!  – Mandalorian).  In this blog, I introduce one GUI example of my model and show how it works within a few clicks. </p>","more":"<h1 id=\"A-brief-introduction-of-the-trait-evolution-model\"><a href=\"#A-brief-introduction-of-the-trait-evolution-model\" class=\"headerlink\" title=\"A brief introduction of the trait evolution model\"></a>A brief introduction of the trait evolution model</h1><p>Diversity in traits of species has long been intriguing to biologists. One of the most famous examples is the Galápagos finches, which is also known as Darwin finches. Darwin’s Finches comprise a group of about 15 species. Their beak sizes are evidenced to associate with the size of seeds that are available in environment, showing apparent evolutionary evidence responding to ecological changes. In the species <em>Geospiza fortis</em>, people found that the beak size of the birds is larger when large seeds are more available. Conversely, when small seeds become more available for some years, small beaks are pervasive in the population.</p>\n<p>In our model of trait evolution with population dynamics, we incorporate the phylogenetic information into consideration. Furthermore, abundance of species plays a role in species interaction, hence,  tunes the trait evolution pace. An animation has been posted before <a href=\"https://xl0418.github.io/2019/06/21/2019-06-21-TPmodel/\">here</a>, which illustrates how the traits of species evolve along a given phylogeny. The manuscript is under review. Details can be found there once it gets published.  </p>\n<p>With this model, empiricists can input the phylogenies and simulate the traits of interest. Using approximate Bayesian computation methods and comparing the simulated traits with the observed traits, one can infer the strength of the environment stabilizing selection and competition. The purpose of designing a GUI is to free empiricists hands from implementing the code. Instead, only a few clicks can do all the work.</p>\n<h1 id=\"GUI\"><a href=\"#GUI\" class=\"headerlink\" title=\"GUI\"></a>GUI</h1><p>I use <code>tkinter</code> to develop the GUI. It has an exhaustive <a href=\"https://docs.python.org/3/library/tkinter.html\">document</a> to help you get familiar with it. So, I am not ganna show you how to code it. You can find the code <a href=\"https://github.com/xl0418/Trait_pop_model_sim/tree/UI-branch\">here</a>. But I would like to show you why empiricists would love it!</p>\n<p>The whole model and nearly all its functions are wrapped into this interface.  </p>\n<img src=\"2020-03-09-GUI-traitevolution/p1.png\" width=\"100%\" height=\"100%\">\n\n<p>In the page of Parameter Inference, users can specify their own phylogenies with observed traits data and also assign a folder to store the output. The structure of the algorithm (ABC) can be set by giving the number of iterations and particles for each iteration. The larger the values are, the accurate the inference is. But it also takes longer time for computation. Parallel computation has been implemented with threads being indicating how many threads you want to exploit. We have three summary statistics to compare the similarity between the simulated traits and the empirical traits. Details can be found in the paper. </p>\n<p>As usually we don’t know how many iterations are sufficient to get a good enough result, we may start with a small number of iterations to check if the results converge. If not, we can continue with this Continue Parameter Inference page.   <img src=\"2020-03-09-GUI-traitevolution/p2.png\" width=\"100%\" height=\"100%\"></p>\n<p>In this page, one additional setting appears. You can specify the previous result on which you want to continue. Then, set a continue number of the iterations while the number of the particles inherits from the previous result. This page offers a choice of cutting jobs into pieces and running them at different time. </p>\n<p>Although ABC approach is a nice likelihood-free method for parameter inference, high computational demanding limits its applicability. Normally, I need to work with a cluster to free my desktop for other works. So in the page of Generate Cluster Scripts, one can set all parameters aforementioned and click one button to generate a script to submit jobs on the cluster. This is one example of the peregrine cluster of the University of Groningen. You can modify it accordingly.   <img src=\"2020-03-09-GUI-traitevolution/p3.png\" width=\"100%\" height=\"100%\"></p>\n<p>Furthermore, one can even do data analysis on the results by using GUI. Here, I set a plotting function to investigate the distributions of the estimated parameters. </p>\n  <img src=\"2020-03-09-GUI-traitevolution/p4.png\" width=\"100%\" height=\"100%\">\n\n<p>More functions can be developed. With GUI, empiricists would love to try theoritian’s models. One may argue that it is convenient but the model is hidden behind the interface so that it lost the model’s plasticity. Well, when you succeed to attract empiricists’ attention, GUI’s job is done. Further model adjustification relies on collaboration. You have already sold your work!  </p>"},{"title":"A user-friendly approximate Bayesian computation package in Python with an application on the coronavirus outbreak in the Netherlands","date":"2020-03-18T07:00:00.000Z","_content":"\nApproximate Bayesian computation (ABC) is a kind of likelihood-free method that utilizes computational power to generate a huge amount of simulations with randomly chosen parameters to hit the target - the observations. The generating parameters that produce the results that are most analogous to the observations are recognized as the best inference of the truth. This is analogous to the idea of neural networks of machine learning. The difference is that ABC requests process-based modeling, which bases on knowledge of the underlying mechanism behind the data. In contrast, neural networks neglect such process-based modeling but only needs to construct a neural net structure to train for fitting data. Thus, the advantage of neural networks is that it provides a general inference approach without need of knowing the mechanisms. Nevertheless, the disadvantage is also on it. The interpretation of the processes behind the data is lacking.  This is why it is widely used in pattern recognition but in biological processes interpretation. Both methods have limited structure types although the combination of them can be infinite. Therefore, coding a general framework to fit any type of models is feasible. While Tensorflow of Google and Pytoch of Facebook stand out in machine learning as the examples of such general frameworks, not many groups are focusing on ABC development. Only a recent [package](https://arxiv.org/pdf/1711.04694.pdf) by Dutta et al. in Python is released setting a good example. Here I would like to share a simple version with an application to the recent coronavirus outbreak in the Netherlands. Just for fun and keeping my coding skills warm in the period of quarantine regulation. \n\n<!--more-->\n\n# A brief introduction of the ABC\n\nApproximate Bayesian computation constitutes a family of computational methods with different algorithms that base on Bayesian statistics. An overview of this approach can be found [here](https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1002803). The following figure from Sunnaker et al. summarizes the idea accurately. <img src=\"2020-03-18-generalABC/abc_scheme.png\" width=\"100%\" height=\"100%\">\n\nNormally, one iteration that constitutes the above mentioned steps is not enough to get a convergent estimation. Hence, taking the posterior distribution of the estimates as the prior distribution in the next iteration to presume the algorithm learning is usually used. This is why ABC like approaches are computational demanding. However, parallel computation can ameliorate it a bit. \n\nIn my toy package, users can prescribe the number of the iterations and the simulations in each iteration. After initializing the model and parameters for the first iteration, parameter inference can be done automatically. The code is [here](https://github.com/xl0418/ABCer). Welcome for comments.\n\n# The coronavirus outbreak in the Netherlands \n\nSince 27th February 2020 the first infected was reported in NL, the coronavirus pandemic has caused over 1700 infections so far.  \n\n<img src=\"2020-03-18-generalABC/data.png\" width=\"70%\" height=\"70%\">\n\nAs an illustration of how this general ABC approach works, I would like to estimate parameters of 2 models and make inference on the future growth of the infected cases. Note that this is only a toy example. Models are very simple and may have analytic solutions. But my purpose here is to show how this ABC package (ABCer) works for different models in a likelihood-free way. \n\n# The usage of the package ABCer \n\nAs aforementioned, with this package you only need to provide the observation data and specify your model, the parameters to be estimated, the structure of the algorithm, i.e. the number of the iterations and the simulations per iteration, and the prior distribution of the parameters. \n\nFor example, from the observation of the coronavirus outbreak and previous experience of pandemic, an exponential growth model is expected to describe the virus infection. \n\n```Python\nfrom ABCer import ABCer\nimport numpy as np\n\n# Model 1\ndef model1(para, time_survey=np.arange(18)):\n    y = para[0] * np.exp(para[1] * time_survey)\n    return y\n```\n\nSo far, I obtained the infection data for 18 days. Hence, I am ganna use these data to compute the similarity between simulations and the observations in ABC algorithm. \n\nNow, we can specify the structure of the ABC, provide the observed data and initialize the model and the parameters in the algorithm. For example, here we chose 50 iterations and 10000 simulations for each iteration.  \n\n```Python\n# The data of the coronavirus outbreak in NL from 27-2-2020 to 17-03-2020\nobservations = np.array([\n    1.0, 7.0, 10.0, 24.0, 38.0, 82.0, 128.0, 188.0, 265.0, 321.0, 382.0, 503.0,\n    614.0, 804.0, 959.0, 1135.0, 1413.0, 1705.0\n])\ntime = np.arange(len(observations))\n\n# Initialize the ABC approach\ntest_ABC1 = ABCer(iterations=50, particles=10000, observations=observations)\ntest_ABC1.initialize_model(model1)\ntest_ABC1.initialize_parameters([0.0, 1.0])\n\n# Launch...\ntest_list1 = test_ABC1.ABC(prior_paras=[0.0, 1.0, 1.0, 2.0])\n```\n\nThe mean of the estimates for each iteration will be printed out. In this example, the values tend to stabilize with the proceeding of the algorithm, indicating convergence achieved. \n\n<img src=\"2020-03-18-generalABC/setup_model1.gif\" width=\"100%\" height=\"100%\">\n\nNow, we can use the inferred parameters to make prediction of the infection.\n\n```python\nimport matplotlib.pyplot as plt\n# The true data\nplt.plot(time, observations, 'o')\n\n# Collect the inferred parameters\npara_inferred = []\npara_inferred.append(np.mean(test_list1[0][20, :]))\npara_inferred.append(np.mean(test_list1[1][20, :]))\n\n# Predict the infection till 21 days\nextend_time = np.arange(21)\ny_inferred = model1(para_inferred, np.arange(21))\n\n# Plot the prediction\nplt.plot(extend_time, y_inferred, 'x', color='r')\nplt.xlabel(\"Days\")\nplt.ylabel('Number of infected cases')\n```\n\nThe red cross denotes the estimate infection. Well, it seems that this model has a lower increase than the observation at the beginning stage but a higher increase than expected later on. This is probably due to the government didn't take any measures at the beginning so that the increase is big. But when it realized how serious the situation is the government started to take action so that the spread of the virus is limited. \n\n<img src=\"2020-03-18-generalABC/Predict1.png\" width=\"70%\" height=\"70%\">\n\n# Another candidate model\n\nNow, we can test any models and estimate their parameters in the same way. Here I tried an additional simple model - a polynomial model - to see if we get a nicer regression.\n\n <img src=\"2020-03-18-generalABC/setup_model2.gif\" width=\"100%\" height=\"100%\">\n\nThe prediction fits the observed data better at the beginning phase. But in the latter phase the infection is underestimated. This means a polynomial model with up to second order cannot fit the data very well. \n\n<img src=\"2020-03-18-generalABC/Predict2.png\" width=\"70%\" height=\"70%\">\n\n# Conclusion\n\nOk, as I said the purpose of this post is to show you how the general ABC approach works with different models in a user-friendly manner. To investigate the best fitting model, a model should consider how the society and the government act accordingly like the quarantine, self-protection behavior, etc. This ABCer package is just a simplest example. More complex structure of the algorithm, distinct summary statistics, the perturbation kernel across iterations can be implemented in the package. Feel free to explore!  \n\n ","source":"_posts/2020-03-18-generalABC.md","raw":"---\ntitle: \"A user-friendly approximate Bayesian computation package in Python with an application on the coronavirus outbreak in the Netherlands\"\ncategories: [Research,Algorithm, ABC]\ntags: [Python, ABC, algorithm]\ndate: 2020-03-18\n\n---\n\nApproximate Bayesian computation (ABC) is a kind of likelihood-free method that utilizes computational power to generate a huge amount of simulations with randomly chosen parameters to hit the target - the observations. The generating parameters that produce the results that are most analogous to the observations are recognized as the best inference of the truth. This is analogous to the idea of neural networks of machine learning. The difference is that ABC requests process-based modeling, which bases on knowledge of the underlying mechanism behind the data. In contrast, neural networks neglect such process-based modeling but only needs to construct a neural net structure to train for fitting data. Thus, the advantage of neural networks is that it provides a general inference approach without need of knowing the mechanisms. Nevertheless, the disadvantage is also on it. The interpretation of the processes behind the data is lacking.  This is why it is widely used in pattern recognition but in biological processes interpretation. Both methods have limited structure types although the combination of them can be infinite. Therefore, coding a general framework to fit any type of models is feasible. While Tensorflow of Google and Pytoch of Facebook stand out in machine learning as the examples of such general frameworks, not many groups are focusing on ABC development. Only a recent [package](https://arxiv.org/pdf/1711.04694.pdf) by Dutta et al. in Python is released setting a good example. Here I would like to share a simple version with an application to the recent coronavirus outbreak in the Netherlands. Just for fun and keeping my coding skills warm in the period of quarantine regulation. \n\n<!--more-->\n\n# A brief introduction of the ABC\n\nApproximate Bayesian computation constitutes a family of computational methods with different algorithms that base on Bayesian statistics. An overview of this approach can be found [here](https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1002803). The following figure from Sunnaker et al. summarizes the idea accurately. <img src=\"2020-03-18-generalABC/abc_scheme.png\" width=\"100%\" height=\"100%\">\n\nNormally, one iteration that constitutes the above mentioned steps is not enough to get a convergent estimation. Hence, taking the posterior distribution of the estimates as the prior distribution in the next iteration to presume the algorithm learning is usually used. This is why ABC like approaches are computational demanding. However, parallel computation can ameliorate it a bit. \n\nIn my toy package, users can prescribe the number of the iterations and the simulations in each iteration. After initializing the model and parameters for the first iteration, parameter inference can be done automatically. The code is [here](https://github.com/xl0418/ABCer). Welcome for comments.\n\n# The coronavirus outbreak in the Netherlands \n\nSince 27th February 2020 the first infected was reported in NL, the coronavirus pandemic has caused over 1700 infections so far.  \n\n<img src=\"2020-03-18-generalABC/data.png\" width=\"70%\" height=\"70%\">\n\nAs an illustration of how this general ABC approach works, I would like to estimate parameters of 2 models and make inference on the future growth of the infected cases. Note that this is only a toy example. Models are very simple and may have analytic solutions. But my purpose here is to show how this ABC package (ABCer) works for different models in a likelihood-free way. \n\n# The usage of the package ABCer \n\nAs aforementioned, with this package you only need to provide the observation data and specify your model, the parameters to be estimated, the structure of the algorithm, i.e. the number of the iterations and the simulations per iteration, and the prior distribution of the parameters. \n\nFor example, from the observation of the coronavirus outbreak and previous experience of pandemic, an exponential growth model is expected to describe the virus infection. \n\n```Python\nfrom ABCer import ABCer\nimport numpy as np\n\n# Model 1\ndef model1(para, time_survey=np.arange(18)):\n    y = para[0] * np.exp(para[1] * time_survey)\n    return y\n```\n\nSo far, I obtained the infection data for 18 days. Hence, I am ganna use these data to compute the similarity between simulations and the observations in ABC algorithm. \n\nNow, we can specify the structure of the ABC, provide the observed data and initialize the model and the parameters in the algorithm. For example, here we chose 50 iterations and 10000 simulations for each iteration.  \n\n```Python\n# The data of the coronavirus outbreak in NL from 27-2-2020 to 17-03-2020\nobservations = np.array([\n    1.0, 7.0, 10.0, 24.0, 38.0, 82.0, 128.0, 188.0, 265.0, 321.0, 382.0, 503.0,\n    614.0, 804.0, 959.0, 1135.0, 1413.0, 1705.0\n])\ntime = np.arange(len(observations))\n\n# Initialize the ABC approach\ntest_ABC1 = ABCer(iterations=50, particles=10000, observations=observations)\ntest_ABC1.initialize_model(model1)\ntest_ABC1.initialize_parameters([0.0, 1.0])\n\n# Launch...\ntest_list1 = test_ABC1.ABC(prior_paras=[0.0, 1.0, 1.0, 2.0])\n```\n\nThe mean of the estimates for each iteration will be printed out. In this example, the values tend to stabilize with the proceeding of the algorithm, indicating convergence achieved. \n\n<img src=\"2020-03-18-generalABC/setup_model1.gif\" width=\"100%\" height=\"100%\">\n\nNow, we can use the inferred parameters to make prediction of the infection.\n\n```python\nimport matplotlib.pyplot as plt\n# The true data\nplt.plot(time, observations, 'o')\n\n# Collect the inferred parameters\npara_inferred = []\npara_inferred.append(np.mean(test_list1[0][20, :]))\npara_inferred.append(np.mean(test_list1[1][20, :]))\n\n# Predict the infection till 21 days\nextend_time = np.arange(21)\ny_inferred = model1(para_inferred, np.arange(21))\n\n# Plot the prediction\nplt.plot(extend_time, y_inferred, 'x', color='r')\nplt.xlabel(\"Days\")\nplt.ylabel('Number of infected cases')\n```\n\nThe red cross denotes the estimate infection. Well, it seems that this model has a lower increase than the observation at the beginning stage but a higher increase than expected later on. This is probably due to the government didn't take any measures at the beginning so that the increase is big. But when it realized how serious the situation is the government started to take action so that the spread of the virus is limited. \n\n<img src=\"2020-03-18-generalABC/Predict1.png\" width=\"70%\" height=\"70%\">\n\n# Another candidate model\n\nNow, we can test any models and estimate their parameters in the same way. Here I tried an additional simple model - a polynomial model - to see if we get a nicer regression.\n\n <img src=\"2020-03-18-generalABC/setup_model2.gif\" width=\"100%\" height=\"100%\">\n\nThe prediction fits the observed data better at the beginning phase. But in the latter phase the infection is underestimated. This means a polynomial model with up to second order cannot fit the data very well. \n\n<img src=\"2020-03-18-generalABC/Predict2.png\" width=\"70%\" height=\"70%\">\n\n# Conclusion\n\nOk, as I said the purpose of this post is to show you how the general ABC approach works with different models in a user-friendly manner. To investigate the best fitting model, a model should consider how the society and the government act accordingly like the quarantine, self-protection behavior, etc. This ABCer package is just a simplest example. More complex structure of the algorithm, distinct summary statistics, the perturbation kernel across iterations can be implemented in the package. Feel free to explore!  \n\n ","slug":"2020-03-18-generalABC","published":1,"updated":"2022-09-17T02:04:05.592Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl85g8660001k4gkrd5xgg0vj","content":"<p>Approximate Bayesian computation (ABC) is a kind of likelihood-free method that utilizes computational power to generate a huge amount of simulations with randomly chosen parameters to hit the target - the observations. The generating parameters that produce the results that are most analogous to the observations are recognized as the best inference of the truth. This is analogous to the idea of neural networks of machine learning. The difference is that ABC requests process-based modeling, which bases on knowledge of the underlying mechanism behind the data. In contrast, neural networks neglect such process-based modeling but only needs to construct a neural net structure to train for fitting data. Thus, the advantage of neural networks is that it provides a general inference approach without need of knowing the mechanisms. Nevertheless, the disadvantage is also on it. The interpretation of the processes behind the data is lacking.  This is why it is widely used in pattern recognition but in biological processes interpretation. Both methods have limited structure types although the combination of them can be infinite. Therefore, coding a general framework to fit any type of models is feasible. While Tensorflow of Google and Pytoch of Facebook stand out in machine learning as the examples of such general frameworks, not many groups are focusing on ABC development. Only a recent <a href=\"https://arxiv.org/pdf/1711.04694.pdf\">package</a> by Dutta et al. in Python is released setting a good example. Here I would like to share a simple version with an application to the recent coronavirus outbreak in the Netherlands. Just for fun and keeping my coding skills warm in the period of quarantine regulation. </p>\n<span id=\"more\"></span>\n\n<h1 id=\"A-brief-introduction-of-the-ABC\"><a href=\"#A-brief-introduction-of-the-ABC\" class=\"headerlink\" title=\"A brief introduction of the ABC\"></a>A brief introduction of the ABC</h1><p>Approximate Bayesian computation constitutes a family of computational methods with different algorithms that base on Bayesian statistics. An overview of this approach can be found <a href=\"https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1002803\">here</a>. The following figure from Sunnaker et al. summarizes the idea accurately. <img src=\"2020-03-18-generalABC/abc_scheme.png\" width=\"100%\" height=\"100%\"></p>\n<p>Normally, one iteration that constitutes the above mentioned steps is not enough to get a convergent estimation. Hence, taking the posterior distribution of the estimates as the prior distribution in the next iteration to presume the algorithm learning is usually used. This is why ABC like approaches are computational demanding. However, parallel computation can ameliorate it a bit. </p>\n<p>In my toy package, users can prescribe the number of the iterations and the simulations in each iteration. After initializing the model and parameters for the first iteration, parameter inference can be done automatically. The code is <a href=\"https://github.com/xl0418/ABCer\">here</a>. Welcome for comments.</p>\n<h1 id=\"The-coronavirus-outbreak-in-the-Netherlands\"><a href=\"#The-coronavirus-outbreak-in-the-Netherlands\" class=\"headerlink\" title=\"The coronavirus outbreak in the Netherlands\"></a>The coronavirus outbreak in the Netherlands</h1><p>Since 27th February 2020 the first infected was reported in NL, the coronavirus pandemic has caused over 1700 infections so far.  </p>\n<img src=\"2020-03-18-generalABC/data.png\" width=\"70%\" height=\"70%\">\n\n<p>As an illustration of how this general ABC approach works, I would like to estimate parameters of 2 models and make inference on the future growth of the infected cases. Note that this is only a toy example. Models are very simple and may have analytic solutions. But my purpose here is to show how this ABC package (ABCer) works for different models in a likelihood-free way. </p>\n<h1 id=\"The-usage-of-the-package-ABCer\"><a href=\"#The-usage-of-the-package-ABCer\" class=\"headerlink\" title=\"The usage of the package ABCer\"></a>The usage of the package ABCer</h1><p>As aforementioned, with this package you only need to provide the observation data and specify your model, the parameters to be estimated, the structure of the algorithm, i.e. the number of the iterations and the simulations per iteration, and the prior distribution of the parameters. </p>\n<p>For example, from the observation of the coronavirus outbreak and previous experience of pandemic, an exponential growth model is expected to describe the virus infection. </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> ABCer <span class=\"keyword\">import</span> ABCer</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Model 1</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">model1</span>(<span class=\"params\">para, time_survey=np.arange(<span class=\"params\"><span class=\"number\">18</span></span>)</span>):</span><br><span class=\"line\">    y = para[<span class=\"number\">0</span>] * np.exp(para[<span class=\"number\">1</span>] * time_survey)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> y</span><br></pre></td></tr></table></figure>\n\n<p>So far, I obtained the infection data for 18 days. Hence, I am ganna use these data to compute the similarity between simulations and the observations in ABC algorithm. </p>\n<p>Now, we can specify the structure of the ABC, provide the observed data and initialize the model and the parameters in the algorithm. For example, here we chose 50 iterations and 10000 simulations for each iteration.  </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># The data of the coronavirus outbreak in NL from 27-2-2020 to 17-03-2020</span></span><br><span class=\"line\">observations = np.array([</span><br><span class=\"line\">    <span class=\"number\">1.0</span>, <span class=\"number\">7.0</span>, <span class=\"number\">10.0</span>, <span class=\"number\">24.0</span>, <span class=\"number\">38.0</span>, <span class=\"number\">82.0</span>, <span class=\"number\">128.0</span>, <span class=\"number\">188.0</span>, <span class=\"number\">265.0</span>, <span class=\"number\">321.0</span>, <span class=\"number\">382.0</span>, <span class=\"number\">503.0</span>,</span><br><span class=\"line\">    <span class=\"number\">614.0</span>, <span class=\"number\">804.0</span>, <span class=\"number\">959.0</span>, <span class=\"number\">1135.0</span>, <span class=\"number\">1413.0</span>, <span class=\"number\">1705.0</span></span><br><span class=\"line\">])</span><br><span class=\"line\">time = np.arange(<span class=\"built_in\">len</span>(observations))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Initialize the ABC approach</span></span><br><span class=\"line\">test_ABC1 = ABCer(iterations=<span class=\"number\">50</span>, particles=<span class=\"number\">10000</span>, observations=observations)</span><br><span class=\"line\">test_ABC1.initialize_model(model1)</span><br><span class=\"line\">test_ABC1.initialize_parameters([<span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Launch...</span></span><br><span class=\"line\">test_list1 = test_ABC1.ABC(prior_paras=[<span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">2.0</span>])</span><br></pre></td></tr></table></figure>\n\n<p>The mean of the estimates for each iteration will be printed out. In this example, the values tend to stabilize with the proceeding of the algorithm, indicating convergence achieved. </p>\n<img src=\"2020-03-18-generalABC/setup_model1.gif\" width=\"100%\" height=\"100%\">\n\n<p>Now, we can use the inferred parameters to make prediction of the infection.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"comment\"># The true data</span></span><br><span class=\"line\">plt.plot(time, observations, <span class=\"string\">&#x27;o&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Collect the inferred parameters</span></span><br><span class=\"line\">para_inferred = []</span><br><span class=\"line\">para_inferred.append(np.mean(test_list1[<span class=\"number\">0</span>][<span class=\"number\">20</span>, :]))</span><br><span class=\"line\">para_inferred.append(np.mean(test_list1[<span class=\"number\">1</span>][<span class=\"number\">20</span>, :]))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Predict the infection till 21 days</span></span><br><span class=\"line\">extend_time = np.arange(<span class=\"number\">21</span>)</span><br><span class=\"line\">y_inferred = model1(para_inferred, np.arange(<span class=\"number\">21</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Plot the prediction</span></span><br><span class=\"line\">plt.plot(extend_time, y_inferred, <span class=\"string\">&#x27;x&#x27;</span>, color=<span class=\"string\">&#x27;r&#x27;</span>)</span><br><span class=\"line\">plt.xlabel(<span class=\"string\">&quot;Days&quot;</span>)</span><br><span class=\"line\">plt.ylabel(<span class=\"string\">&#x27;Number of infected cases&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>The red cross denotes the estimate infection. Well, it seems that this model has a lower increase than the observation at the beginning stage but a higher increase than expected later on. This is probably due to the government didn’t take any measures at the beginning so that the increase is big. But when it realized how serious the situation is the government started to take action so that the spread of the virus is limited. </p>\n<img src=\"2020-03-18-generalABC/Predict1.png\" width=\"70%\" height=\"70%\">\n\n<h1 id=\"Another-candidate-model\"><a href=\"#Another-candidate-model\" class=\"headerlink\" title=\"Another candidate model\"></a>Another candidate model</h1><p>Now, we can test any models and estimate their parameters in the same way. Here I tried an additional simple model - a polynomial model - to see if we get a nicer regression.</p>\n <img src=\"2020-03-18-generalABC/setup_model2.gif\" width=\"100%\" height=\"100%\">\n\n<p>The prediction fits the observed data better at the beginning phase. But in the latter phase the infection is underestimated. This means a polynomial model with up to second order cannot fit the data very well. </p>\n<img src=\"2020-03-18-generalABC/Predict2.png\" width=\"70%\" height=\"70%\">\n\n<h1 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h1><p>Ok, as I said the purpose of this post is to show you how the general ABC approach works with different models in a user-friendly manner. To investigate the best fitting model, a model should consider how the society and the government act accordingly like the quarantine, self-protection behavior, etc. This ABCer package is just a simplest example. More complex structure of the algorithm, distinct summary statistics, the perturbation kernel across iterations can be implemented in the package. Feel free to explore!  </p>\n","site":{"data":{}},"excerpt":"<p>Approximate Bayesian computation (ABC) is a kind of likelihood-free method that utilizes computational power to generate a huge amount of simulations with randomly chosen parameters to hit the target - the observations. The generating parameters that produce the results that are most analogous to the observations are recognized as the best inference of the truth. This is analogous to the idea of neural networks of machine learning. The difference is that ABC requests process-based modeling, which bases on knowledge of the underlying mechanism behind the data. In contrast, neural networks neglect such process-based modeling but only needs to construct a neural net structure to train for fitting data. Thus, the advantage of neural networks is that it provides a general inference approach without need of knowing the mechanisms. Nevertheless, the disadvantage is also on it. The interpretation of the processes behind the data is lacking.  This is why it is widely used in pattern recognition but in biological processes interpretation. Both methods have limited structure types although the combination of them can be infinite. Therefore, coding a general framework to fit any type of models is feasible. While Tensorflow of Google and Pytoch of Facebook stand out in machine learning as the examples of such general frameworks, not many groups are focusing on ABC development. Only a recent <a href=\"https://arxiv.org/pdf/1711.04694.pdf\">package</a> by Dutta et al. in Python is released setting a good example. Here I would like to share a simple version with an application to the recent coronavirus outbreak in the Netherlands. Just for fun and keeping my coding skills warm in the period of quarantine regulation. </p>","more":"<h1 id=\"A-brief-introduction-of-the-ABC\"><a href=\"#A-brief-introduction-of-the-ABC\" class=\"headerlink\" title=\"A brief introduction of the ABC\"></a>A brief introduction of the ABC</h1><p>Approximate Bayesian computation constitutes a family of computational methods with different algorithms that base on Bayesian statistics. An overview of this approach can be found <a href=\"https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1002803\">here</a>. The following figure from Sunnaker et al. summarizes the idea accurately. <img src=\"2020-03-18-generalABC/abc_scheme.png\" width=\"100%\" height=\"100%\"></p>\n<p>Normally, one iteration that constitutes the above mentioned steps is not enough to get a convergent estimation. Hence, taking the posterior distribution of the estimates as the prior distribution in the next iteration to presume the algorithm learning is usually used. This is why ABC like approaches are computational demanding. However, parallel computation can ameliorate it a bit. </p>\n<p>In my toy package, users can prescribe the number of the iterations and the simulations in each iteration. After initializing the model and parameters for the first iteration, parameter inference can be done automatically. The code is <a href=\"https://github.com/xl0418/ABCer\">here</a>. Welcome for comments.</p>\n<h1 id=\"The-coronavirus-outbreak-in-the-Netherlands\"><a href=\"#The-coronavirus-outbreak-in-the-Netherlands\" class=\"headerlink\" title=\"The coronavirus outbreak in the Netherlands\"></a>The coronavirus outbreak in the Netherlands</h1><p>Since 27th February 2020 the first infected was reported in NL, the coronavirus pandemic has caused over 1700 infections so far.  </p>\n<img src=\"2020-03-18-generalABC/data.png\" width=\"70%\" height=\"70%\">\n\n<p>As an illustration of how this general ABC approach works, I would like to estimate parameters of 2 models and make inference on the future growth of the infected cases. Note that this is only a toy example. Models are very simple and may have analytic solutions. But my purpose here is to show how this ABC package (ABCer) works for different models in a likelihood-free way. </p>\n<h1 id=\"The-usage-of-the-package-ABCer\"><a href=\"#The-usage-of-the-package-ABCer\" class=\"headerlink\" title=\"The usage of the package ABCer\"></a>The usage of the package ABCer</h1><p>As aforementioned, with this package you only need to provide the observation data and specify your model, the parameters to be estimated, the structure of the algorithm, i.e. the number of the iterations and the simulations per iteration, and the prior distribution of the parameters. </p>\n<p>For example, from the observation of the coronavirus outbreak and previous experience of pandemic, an exponential growth model is expected to describe the virus infection. </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> ABCer <span class=\"keyword\">import</span> ABCer</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Model 1</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">model1</span>(<span class=\"params\">para, time_survey=np.arange(<span class=\"params\"><span class=\"number\">18</span></span>)</span>):</span><br><span class=\"line\">    y = para[<span class=\"number\">0</span>] * np.exp(para[<span class=\"number\">1</span>] * time_survey)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> y</span><br></pre></td></tr></table></figure>\n\n<p>So far, I obtained the infection data for 18 days. Hence, I am ganna use these data to compute the similarity between simulations and the observations in ABC algorithm. </p>\n<p>Now, we can specify the structure of the ABC, provide the observed data and initialize the model and the parameters in the algorithm. For example, here we chose 50 iterations and 10000 simulations for each iteration.  </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># The data of the coronavirus outbreak in NL from 27-2-2020 to 17-03-2020</span></span><br><span class=\"line\">observations = np.array([</span><br><span class=\"line\">    <span class=\"number\">1.0</span>, <span class=\"number\">7.0</span>, <span class=\"number\">10.0</span>, <span class=\"number\">24.0</span>, <span class=\"number\">38.0</span>, <span class=\"number\">82.0</span>, <span class=\"number\">128.0</span>, <span class=\"number\">188.0</span>, <span class=\"number\">265.0</span>, <span class=\"number\">321.0</span>, <span class=\"number\">382.0</span>, <span class=\"number\">503.0</span>,</span><br><span class=\"line\">    <span class=\"number\">614.0</span>, <span class=\"number\">804.0</span>, <span class=\"number\">959.0</span>, <span class=\"number\">1135.0</span>, <span class=\"number\">1413.0</span>, <span class=\"number\">1705.0</span></span><br><span class=\"line\">])</span><br><span class=\"line\">time = np.arange(<span class=\"built_in\">len</span>(observations))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Initialize the ABC approach</span></span><br><span class=\"line\">test_ABC1 = ABCer(iterations=<span class=\"number\">50</span>, particles=<span class=\"number\">10000</span>, observations=observations)</span><br><span class=\"line\">test_ABC1.initialize_model(model1)</span><br><span class=\"line\">test_ABC1.initialize_parameters([<span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Launch...</span></span><br><span class=\"line\">test_list1 = test_ABC1.ABC(prior_paras=[<span class=\"number\">0.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">1.0</span>, <span class=\"number\">2.0</span>])</span><br></pre></td></tr></table></figure>\n\n<p>The mean of the estimates for each iteration will be printed out. In this example, the values tend to stabilize with the proceeding of the algorithm, indicating convergence achieved. </p>\n<img src=\"2020-03-18-generalABC/setup_model1.gif\" width=\"100%\" height=\"100%\">\n\n<p>Now, we can use the inferred parameters to make prediction of the infection.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"comment\"># The true data</span></span><br><span class=\"line\">plt.plot(time, observations, <span class=\"string\">&#x27;o&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Collect the inferred parameters</span></span><br><span class=\"line\">para_inferred = []</span><br><span class=\"line\">para_inferred.append(np.mean(test_list1[<span class=\"number\">0</span>][<span class=\"number\">20</span>, :]))</span><br><span class=\"line\">para_inferred.append(np.mean(test_list1[<span class=\"number\">1</span>][<span class=\"number\">20</span>, :]))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Predict the infection till 21 days</span></span><br><span class=\"line\">extend_time = np.arange(<span class=\"number\">21</span>)</span><br><span class=\"line\">y_inferred = model1(para_inferred, np.arange(<span class=\"number\">21</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Plot the prediction</span></span><br><span class=\"line\">plt.plot(extend_time, y_inferred, <span class=\"string\">&#x27;x&#x27;</span>, color=<span class=\"string\">&#x27;r&#x27;</span>)</span><br><span class=\"line\">plt.xlabel(<span class=\"string\">&quot;Days&quot;</span>)</span><br><span class=\"line\">plt.ylabel(<span class=\"string\">&#x27;Number of infected cases&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>The red cross denotes the estimate infection. Well, it seems that this model has a lower increase than the observation at the beginning stage but a higher increase than expected later on. This is probably due to the government didn’t take any measures at the beginning so that the increase is big. But when it realized how serious the situation is the government started to take action so that the spread of the virus is limited. </p>\n<img src=\"2020-03-18-generalABC/Predict1.png\" width=\"70%\" height=\"70%\">\n\n<h1 id=\"Another-candidate-model\"><a href=\"#Another-candidate-model\" class=\"headerlink\" title=\"Another candidate model\"></a>Another candidate model</h1><p>Now, we can test any models and estimate their parameters in the same way. Here I tried an additional simple model - a polynomial model - to see if we get a nicer regression.</p>\n <img src=\"2020-03-18-generalABC/setup_model2.gif\" width=\"100%\" height=\"100%\">\n\n<p>The prediction fits the observed data better at the beginning phase. But in the latter phase the infection is underestimated. This means a polynomial model with up to second order cannot fit the data very well. </p>\n<img src=\"2020-03-18-generalABC/Predict2.png\" width=\"70%\" height=\"70%\">\n\n<h1 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h1><p>Ok, as I said the purpose of this post is to show you how the general ABC approach works with different models in a user-friendly manner. To investigate the best fitting model, a model should consider how the society and the government act accordingly like the quarantine, self-protection behavior, etc. This ABCer package is just a simplest example. More complex structure of the algorithm, distinct summary statistics, the perturbation kernel across iterations can be implemented in the package. Feel free to explore!  </p>"},{"title":"The government should take a fast reaction to prevent COVID-19 development","date":"2020-04-02T07:00:00.000Z","_content":"\nThe outbreak of the COVID-19 virus has given the world a heavy punch in 2020. The growth infection over 30 countries in the world has seen the overwhelming power of the exponential spread of COVID-19 at the early stage. The White House Office of Science and Technology Policy (OSTP) pulled together a coalition research groups and companies (including Kaggle) to prepare the [COVID-19 Open Research Dataset (CORD-19)](https://www.kaggle.com/allen-institute-for-ai/CORD-19-research-challenge) to attempt to address [key open scientific questions on COVID-19](https://www.kaggle.com/allen-institute-for-ai/CORD-19-research-challenge/tasks). Those questions are drawn from [National Academies of Sciences, Engineering, and Medicine’s (NASEM)](https://www.nationalacademies.org/event/03-11-2020/standing-committee-on-emerging-infectious-diseases-and-21st-century-health-threats-virtual-meeting-1) and the [World Health Organization (WHO)](https://www.who.int/blueprint/priority-diseases/key-action/Global_Research_Forum_FINAL_VERSION_for_web_14_feb_2020.pdf?ua=1). Flooded by the daily news of how serious the pandemic becomes, I am wondering whether and to what extent the government can stop the pandemic. Specifically, if the government takes a fast response to restrict social activities, will the pandemic be stopped at an early stage? Thus, I took part in one of the competition and built an individual-based virus spread model in which I considered how the speed of the government reaction affects pandemic development. It is an one-week competition that finished in this morning. I create this post by attaching my work [**here**](https://xl0418.github.io/Kaggle_corona/). Enjoy!\n\n","source":"_posts/2020-04-02-government&pandemic.md","raw":"---\ntitle: \"The government should take a fast reaction to prevent COVID-19 development\"\ncategories: [Research,Modeling]\ntags: [Python, simulation, coronavirus, pandemic, government measure]\ndate: 2020-04-02\n---\n\nThe outbreak of the COVID-19 virus has given the world a heavy punch in 2020. The growth infection over 30 countries in the world has seen the overwhelming power of the exponential spread of COVID-19 at the early stage. The White House Office of Science and Technology Policy (OSTP) pulled together a coalition research groups and companies (including Kaggle) to prepare the [COVID-19 Open Research Dataset (CORD-19)](https://www.kaggle.com/allen-institute-for-ai/CORD-19-research-challenge) to attempt to address [key open scientific questions on COVID-19](https://www.kaggle.com/allen-institute-for-ai/CORD-19-research-challenge/tasks). Those questions are drawn from [National Academies of Sciences, Engineering, and Medicine’s (NASEM)](https://www.nationalacademies.org/event/03-11-2020/standing-committee-on-emerging-infectious-diseases-and-21st-century-health-threats-virtual-meeting-1) and the [World Health Organization (WHO)](https://www.who.int/blueprint/priority-diseases/key-action/Global_Research_Forum_FINAL_VERSION_for_web_14_feb_2020.pdf?ua=1). Flooded by the daily news of how serious the pandemic becomes, I am wondering whether and to what extent the government can stop the pandemic. Specifically, if the government takes a fast response to restrict social activities, will the pandemic be stopped at an early stage? Thus, I took part in one of the competition and built an individual-based virus spread model in which I considered how the speed of the government reaction affects pandemic development. It is an one-week competition that finished in this morning. I create this post by attaching my work [**here**](https://xl0418.github.io/Kaggle_corona/). Enjoy!\n\n","slug":"2020-04-02-government&pandemic","published":1,"updated":"2022-09-17T02:04:05.603Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl85g8661001n4gkrcs8f61c7","content":"<p>The outbreak of the COVID-19 virus has given the world a heavy punch in 2020. The growth infection over 30 countries in the world has seen the overwhelming power of the exponential spread of COVID-19 at the early stage. The White House Office of Science and Technology Policy (OSTP) pulled together a coalition research groups and companies (including Kaggle) to prepare the <a href=\"https://www.kaggle.com/allen-institute-for-ai/CORD-19-research-challenge\">COVID-19 Open Research Dataset (CORD-19)</a> to attempt to address <a href=\"https://www.kaggle.com/allen-institute-for-ai/CORD-19-research-challenge/tasks\">key open scientific questions on COVID-19</a>. Those questions are drawn from <a href=\"https://www.nationalacademies.org/event/03-11-2020/standing-committee-on-emerging-infectious-diseases-and-21st-century-health-threats-virtual-meeting-1\">National Academies of Sciences, Engineering, and Medicine’s (NASEM)</a> and the <a href=\"https://www.who.int/blueprint/priority-diseases/key-action/Global_Research_Forum_FINAL_VERSION_for_web_14_feb_2020.pdf?ua=1\">World Health Organization (WHO)</a>. Flooded by the daily news of how serious the pandemic becomes, I am wondering whether and to what extent the government can stop the pandemic. Specifically, if the government takes a fast response to restrict social activities, will the pandemic be stopped at an early stage? Thus, I took part in one of the competition and built an individual-based virus spread model in which I considered how the speed of the government reaction affects pandemic development. It is an one-week competition that finished in this morning. I create this post by attaching my work <a href=\"https://xl0418.github.io/Kaggle_corona/\"><strong>here</strong></a>. Enjoy!</p>\n","site":{"data":{}},"excerpt":"","more":"<p>The outbreak of the COVID-19 virus has given the world a heavy punch in 2020. The growth infection over 30 countries in the world has seen the overwhelming power of the exponential spread of COVID-19 at the early stage. The White House Office of Science and Technology Policy (OSTP) pulled together a coalition research groups and companies (including Kaggle) to prepare the <a href=\"https://www.kaggle.com/allen-institute-for-ai/CORD-19-research-challenge\">COVID-19 Open Research Dataset (CORD-19)</a> to attempt to address <a href=\"https://www.kaggle.com/allen-institute-for-ai/CORD-19-research-challenge/tasks\">key open scientific questions on COVID-19</a>. Those questions are drawn from <a href=\"https://www.nationalacademies.org/event/03-11-2020/standing-committee-on-emerging-infectious-diseases-and-21st-century-health-threats-virtual-meeting-1\">National Academies of Sciences, Engineering, and Medicine’s (NASEM)</a> and the <a href=\"https://www.who.int/blueprint/priority-diseases/key-action/Global_Research_Forum_FINAL_VERSION_for_web_14_feb_2020.pdf?ua=1\">World Health Organization (WHO)</a>. Flooded by the daily news of how serious the pandemic becomes, I am wondering whether and to what extent the government can stop the pandemic. Specifically, if the government takes a fast response to restrict social activities, will the pandemic be stopped at an early stage? Thus, I took part in one of the competition and built an individual-based virus spread model in which I considered how the speed of the government reaction affects pandemic development. It is an one-week competition that finished in this morning. I create this post by attaching my work <a href=\"https://xl0418.github.io/Kaggle_corona/\"><strong>here</strong></a>. Enjoy!</p>\n"},{"title":"Data visualization: develop a Shiny app to track COVID-19 spread.","date":"2020-04-25T07:00:00.000Z","_content":"\nThe outbreak of the COVID-19 virus has given me a heavy punch. I have been isolated at home for almost two months with one trip to the nearest trash bin every week. What is even worse is that I cannot get any reply from job hunting. Being so stressed, I decided to develop a Shiny app to track the COVID-19 spread. Hope this may give me a sign of recovery of the world by examining daily data. More information can be found [**here**](https://liangxu-groningen.shinyapps.io/corona_shiny/). A differential equation model is still under construction. Coming soon. Enjoy!\n\n","source":"_posts/2020-04-25-Covid_19.md","raw":"---\ntitle: \"Data visualization: develop a Shiny app to track COVID-19 spread.\"\ncategories: [Research, Modeling]\ntags: [R, simulation, coronavirus, pandemic, data visualization]\ndate: 2020-04-25\n---\n\nThe outbreak of the COVID-19 virus has given me a heavy punch. I have been isolated at home for almost two months with one trip to the nearest trash bin every week. What is even worse is that I cannot get any reply from job hunting. Being so stressed, I decided to develop a Shiny app to track the COVID-19 spread. Hope this may give me a sign of recovery of the world by examining daily data. More information can be found [**here**](https://liangxu-groningen.shinyapps.io/corona_shiny/). A differential equation model is still under construction. Coming soon. Enjoy!\n\n","slug":"2020-04-25-Covid_19","published":1,"updated":"2022-09-17T02:04:05.603Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl85g8662001q4gkr1hms43aw","content":"<p>The outbreak of the COVID-19 virus has given me a heavy punch. I have been isolated at home for almost two months with one trip to the nearest trash bin every week. What is even worse is that I cannot get any reply from job hunting. Being so stressed, I decided to develop a Shiny app to track the COVID-19 spread. Hope this may give me a sign of recovery of the world by examining daily data. More information can be found <a href=\"https://liangxu-groningen.shinyapps.io/corona_shiny/\"><strong>here</strong></a>. A differential equation model is still under construction. Coming soon. Enjoy!</p>\n","site":{"data":{}},"excerpt":"","more":"<p>The outbreak of the COVID-19 virus has given me a heavy punch. I have been isolated at home for almost two months with one trip to the nearest trash bin every week. What is even worse is that I cannot get any reply from job hunting. Being so stressed, I decided to develop a Shiny app to track the COVID-19 spread. Hope this may give me a sign of recovery of the world by examining daily data. More information can be found <a href=\"https://liangxu-groningen.shinyapps.io/corona_shiny/\"><strong>here</strong></a>. A differential equation model is still under construction. Coming soon. Enjoy!</p>\n"},{"title":"Goodbye Groningen! Hello Oxford!","date":"2020-10-05T07:00:00.000Z","_content":"\nIt's been a while that I haven't updated my work and life. On 5th of June, I finally defended my thesis and obtained PhD degree. My thesis can be found [HERE](https://www.rug.nl/about-ug/latest-news/events/promoties/promoties-2020?hfId=119206). Thank my supervisor Prof. [Rampal S Etienne](https://www.rug.nl/staff/r.s.etienne/) and co-supervisor Dr. [Sander van Doorn](https://www.rug.nl/staff/g.s.van.doorn/) for their guidance in the last 5 years. Thank my  colleagues for their help on my work, thesis and the defense and the time we share together. Obtaining the degree was not the end of my acdemic life but a milestone and a new start for the next stage. \n\nSince March 2020 and even earlier, I have been looking for jobs, preferably postdoc positions. However, I don't know whether it is due to the pandemic or not, instead of offers I got many rejections. It was a tough time period for me. Without boarding on a contract, I have no income but have a family to raise.  Luckly, my wife found a job, which seems to some extent to solve our finacial crisis. This allows me to focus on searching for opportunities. Eventually, I found some positions that have a good match for my background. I contacted the group leaders and job posters and tried to highlight myself to gain an interview chance. I got some nice replies but finally they rejected me. The worse part of these rejections is that I don't even know why I got rejected and where I could improve myself. I started to have doubt on myself. Fortunately, I had one last chance in my first batch of applications.\n\nI encountered one job poster on LinkedIn in July when I was roaming on LinkedIn. Prof. [Lindsay Turnbull](https://www.plants.ox.ac.uk/people/lindsay-turnbull)'s group at University of Oxford is looking for a postdoc to do simulation modeling on community plant assembly. This is exactly compatible with what I am doing on my third project, the best fit one of all the jobs I have ever applied. So, I saw a fair chance in the research. Immediately, I made the application and sent an email to Prof. Lindsay Turnbull. Very soon, I got reply from Lindsay and we had several back and forth communications. One month later, I got an interview invitation and we had a nice chat on my work and the plan of the work of this position. After one week, a formal offer is sent to me. \n\nYear 2020 is awful. However, we should never lose hope. By this post of an update of my recent situation and experience, I would like to encourage people who have currently been in trouble. Trace the rainbow in the rain. ","source":"_posts/2020-10-05-update.md","raw":"---\ntitle: \"Goodbye Groningen! Hello Oxford!\"\ncategories: [BB life]\ntags: [Postdoc]\ndate: 2020-10-05\n\n---\n\nIt's been a while that I haven't updated my work and life. On 5th of June, I finally defended my thesis and obtained PhD degree. My thesis can be found [HERE](https://www.rug.nl/about-ug/latest-news/events/promoties/promoties-2020?hfId=119206). Thank my supervisor Prof. [Rampal S Etienne](https://www.rug.nl/staff/r.s.etienne/) and co-supervisor Dr. [Sander van Doorn](https://www.rug.nl/staff/g.s.van.doorn/) for their guidance in the last 5 years. Thank my  colleagues for their help on my work, thesis and the defense and the time we share together. Obtaining the degree was not the end of my acdemic life but a milestone and a new start for the next stage. \n\nSince March 2020 and even earlier, I have been looking for jobs, preferably postdoc positions. However, I don't know whether it is due to the pandemic or not, instead of offers I got many rejections. It was a tough time period for me. Without boarding on a contract, I have no income but have a family to raise.  Luckly, my wife found a job, which seems to some extent to solve our finacial crisis. This allows me to focus on searching for opportunities. Eventually, I found some positions that have a good match for my background. I contacted the group leaders and job posters and tried to highlight myself to gain an interview chance. I got some nice replies but finally they rejected me. The worse part of these rejections is that I don't even know why I got rejected and where I could improve myself. I started to have doubt on myself. Fortunately, I had one last chance in my first batch of applications.\n\nI encountered one job poster on LinkedIn in July when I was roaming on LinkedIn. Prof. [Lindsay Turnbull](https://www.plants.ox.ac.uk/people/lindsay-turnbull)'s group at University of Oxford is looking for a postdoc to do simulation modeling on community plant assembly. This is exactly compatible with what I am doing on my third project, the best fit one of all the jobs I have ever applied. So, I saw a fair chance in the research. Immediately, I made the application and sent an email to Prof. Lindsay Turnbull. Very soon, I got reply from Lindsay and we had several back and forth communications. One month later, I got an interview invitation and we had a nice chat on my work and the plan of the work of this position. After one week, a formal offer is sent to me. \n\nYear 2020 is awful. However, we should never lose hope. By this post of an update of my recent situation and experience, I would like to encourage people who have currently been in trouble. Trace the rainbow in the rain. ","slug":"2020-10-05-update","published":1,"updated":"2022-09-17T02:04:05.603Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl85g866s009k4gkrbqwpdz0o","content":"<p>It’s been a while that I haven’t updated my work and life. On 5th of June, I finally defended my thesis and obtained PhD degree. My thesis can be found <a href=\"https://www.rug.nl/about-ug/latest-news/events/promoties/promoties-2020?hfId=119206\">HERE</a>. Thank my supervisor Prof. <a href=\"https://www.rug.nl/staff/r.s.etienne/\">Rampal S Etienne</a> and co-supervisor Dr. <a href=\"https://www.rug.nl/staff/g.s.van.doorn/\">Sander van Doorn</a> for their guidance in the last 5 years. Thank my  colleagues for their help on my work, thesis and the defense and the time we share together. Obtaining the degree was not the end of my acdemic life but a milestone and a new start for the next stage. </p>\n<p>Since March 2020 and even earlier, I have been looking for jobs, preferably postdoc positions. However, I don’t know whether it is due to the pandemic or not, instead of offers I got many rejections. It was a tough time period for me. Without boarding on a contract, I have no income but have a family to raise.  Luckly, my wife found a job, which seems to some extent to solve our finacial crisis. This allows me to focus on searching for opportunities. Eventually, I found some positions that have a good match for my background. I contacted the group leaders and job posters and tried to highlight myself to gain an interview chance. I got some nice replies but finally they rejected me. The worse part of these rejections is that I don’t even know why I got rejected and where I could improve myself. I started to have doubt on myself. Fortunately, I had one last chance in my first batch of applications.</p>\n<p>I encountered one job poster on LinkedIn in July when I was roaming on LinkedIn. Prof. <a href=\"https://www.plants.ox.ac.uk/people/lindsay-turnbull\">Lindsay Turnbull</a>‘s group at University of Oxford is looking for a postdoc to do simulation modeling on community plant assembly. This is exactly compatible with what I am doing on my third project, the best fit one of all the jobs I have ever applied. So, I saw a fair chance in the research. Immediately, I made the application and sent an email to Prof. Lindsay Turnbull. Very soon, I got reply from Lindsay and we had several back and forth communications. One month later, I got an interview invitation and we had a nice chat on my work and the plan of the work of this position. After one week, a formal offer is sent to me. </p>\n<p>Year 2020 is awful. However, we should never lose hope. By this post of an update of my recent situation and experience, I would like to encourage people who have currently been in trouble. Trace the rainbow in the rain. </p>\n","site":{"data":{}},"excerpt":"","more":"<p>It’s been a while that I haven’t updated my work and life. On 5th of June, I finally defended my thesis and obtained PhD degree. My thesis can be found <a href=\"https://www.rug.nl/about-ug/latest-news/events/promoties/promoties-2020?hfId=119206\">HERE</a>. Thank my supervisor Prof. <a href=\"https://www.rug.nl/staff/r.s.etienne/\">Rampal S Etienne</a> and co-supervisor Dr. <a href=\"https://www.rug.nl/staff/g.s.van.doorn/\">Sander van Doorn</a> for their guidance in the last 5 years. Thank my  colleagues for their help on my work, thesis and the defense and the time we share together. Obtaining the degree was not the end of my acdemic life but a milestone and a new start for the next stage. </p>\n<p>Since March 2020 and even earlier, I have been looking for jobs, preferably postdoc positions. However, I don’t know whether it is due to the pandemic or not, instead of offers I got many rejections. It was a tough time period for me. Without boarding on a contract, I have no income but have a family to raise.  Luckly, my wife found a job, which seems to some extent to solve our finacial crisis. This allows me to focus on searching for opportunities. Eventually, I found some positions that have a good match for my background. I contacted the group leaders and job posters and tried to highlight myself to gain an interview chance. I got some nice replies but finally they rejected me. The worse part of these rejections is that I don’t even know why I got rejected and where I could improve myself. I started to have doubt on myself. Fortunately, I had one last chance in my first batch of applications.</p>\n<p>I encountered one job poster on LinkedIn in July when I was roaming on LinkedIn. Prof. <a href=\"https://www.plants.ox.ac.uk/people/lindsay-turnbull\">Lindsay Turnbull</a>‘s group at University of Oxford is looking for a postdoc to do simulation modeling on community plant assembly. This is exactly compatible with what I am doing on my third project, the best fit one of all the jobs I have ever applied. So, I saw a fair chance in the research. Immediately, I made the application and sent an email to Prof. Lindsay Turnbull. Very soon, I got reply from Lindsay and we had several back and forth communications. One month later, I got an interview invitation and we had a nice chat on my work and the plan of the work of this position. After one week, a formal offer is sent to me. </p>\n<p>Year 2020 is awful. However, we should never lose hope. By this post of an update of my recent situation and experience, I would like to encourage people who have currently been in trouble. Trace the rainbow in the rain. </p>\n"},{"title":"Might be a good presentation for theoretical models?","date":"2021-03-21T07:00:00.000Z","_content":"\nMoving from the Netherlands to the UK on 11th Jan 2021, just at the right time when brexit actually starts, when COVID-19 variant virues stopped down the UK, when everything is mess. However, we suceeded. Two grown-ups, one child and one cat. Anyway, I settled down now and started work in Oxford. Today, I'd like to share building a simple scene using [Blender](https://www.blender.org/) to present theoretical models.\n\n<!--more-->  \n\n## The plant community model\n\nThe model is to describe how plants compete and coexist in a community. My work is to study bias in inferring density dependence invovling all kinds of systematic errors and also mechanistic misunderstandings. The model is simple. Plants produce seeds. Seeds disperse over the community. Seeds grow to plants. Normally, it is abstract to show the model processes in academic research. I was thinking to present it in a more vivid manner. \n\n  ## Blender: create a small low poly scene\n\nThus, I learned Blender to create a small low poly scene. It is more like building an animation scene. \n\nPlants start with 5 apple trees. They produce apples that spread everywhere. Finally, after competition, a few grow to apple trees.\n\n<img src=\"2021-03-21-Blender/Step1.png\" width=\"100%\" height=\"100%\">\n\n<img src=\"2021-03-21-Blender/Step2.png\" width=\"100%\" height=\"100%\">\n\n<img src=\"2021-03-21-Blender/Step3.png\" width=\"100%\" height=\"100%\">\n\nA video is here. \n\n<video src='smallworld.mp4' controls='controls'  width='100%' height='100%'>The `<video>` tag is not supported by your browser.\n</video>\nWell, it looks a bit dull but a good start, doesn't it? It is a lot fun to learn a new skill!\n","source":"_posts/2021-03-21-Blender.md","raw":"---\ntitle: \"Might be a good presentation for theoretical models?\"\ncategories: [Research]\ntags: [Blender]\ndate: 2021-03-21\n\n---\n\nMoving from the Netherlands to the UK on 11th Jan 2021, just at the right time when brexit actually starts, when COVID-19 variant virues stopped down the UK, when everything is mess. However, we suceeded. Two grown-ups, one child and one cat. Anyway, I settled down now and started work in Oxford. Today, I'd like to share building a simple scene using [Blender](https://www.blender.org/) to present theoretical models.\n\n<!--more-->  \n\n## The plant community model\n\nThe model is to describe how plants compete and coexist in a community. My work is to study bias in inferring density dependence invovling all kinds of systematic errors and also mechanistic misunderstandings. The model is simple. Plants produce seeds. Seeds disperse over the community. Seeds grow to plants. Normally, it is abstract to show the model processes in academic research. I was thinking to present it in a more vivid manner. \n\n  ## Blender: create a small low poly scene\n\nThus, I learned Blender to create a small low poly scene. It is more like building an animation scene. \n\nPlants start with 5 apple trees. They produce apples that spread everywhere. Finally, after competition, a few grow to apple trees.\n\n<img src=\"2021-03-21-Blender/Step1.png\" width=\"100%\" height=\"100%\">\n\n<img src=\"2021-03-21-Blender/Step2.png\" width=\"100%\" height=\"100%\">\n\n<img src=\"2021-03-21-Blender/Step3.png\" width=\"100%\" height=\"100%\">\n\nA video is here. \n\n<video src='smallworld.mp4' controls='controls'  width='100%' height='100%'>The `<video>` tag is not supported by your browser.\n</video>\nWell, it looks a bit dull but a good start, doesn't it? It is a lot fun to learn a new skill!\n","slug":"2021-03-21-Blender","published":1,"updated":"2022-09-17T03:59:40.510Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl85g866t009l4gkr42qrda4h","content":"<p>Moving from the Netherlands to the UK on 11th Jan 2021, just at the right time when brexit actually starts, when COVID-19 variant virues stopped down the UK, when everything is mess. However, we suceeded. Two grown-ups, one child and one cat. Anyway, I settled down now and started work in Oxford. Today, I’d like to share building a simple scene using <a href=\"https://www.blender.org/\">Blender</a> to present theoretical models.</p>\n<span id=\"more\"></span>  \n\n<h2 id=\"The-plant-community-model\"><a href=\"#The-plant-community-model\" class=\"headerlink\" title=\"The plant community model\"></a>The plant community model</h2><p>The model is to describe how plants compete and coexist in a community. My work is to study bias in inferring density dependence invovling all kinds of systematic errors and also mechanistic misunderstandings. The model is simple. Plants produce seeds. Seeds disperse over the community. Seeds grow to plants. Normally, it is abstract to show the model processes in academic research. I was thinking to present it in a more vivid manner. </p>\n<h2 id=\"Blender-create-a-small-low-poly-scene\"><a href=\"#Blender-create-a-small-low-poly-scene\" class=\"headerlink\" title=\"Blender: create a small low poly scene\"></a>Blender: create a small low poly scene</h2><p>Thus, I learned Blender to create a small low poly scene. It is more like building an animation scene. </p>\n<p>Plants start with 5 apple trees. They produce apples that spread everywhere. Finally, after competition, a few grow to apple trees.</p>\n<img src=\"2021-03-21-Blender/Step1.png\" width=\"100%\" height=\"100%\">\n\n<img src=\"2021-03-21-Blender/Step2.png\" width=\"100%\" height=\"100%\">\n\n<img src=\"2021-03-21-Blender/Step3.png\" width=\"100%\" height=\"100%\">\n\n<p>A video is here. </p>\n<p><video src='smallworld.mp4' controls='controls'  width='100%' height='100%'>The <code>&lt;video&gt;</code> tag is not supported by your browser.<br></video><br>Well, it looks a bit dull but a good start, doesn’t it? It is a lot fun to learn a new skill!</p>\n","site":{"data":{}},"excerpt":"<p>Moving from the Netherlands to the UK on 11th Jan 2021, just at the right time when brexit actually starts, when COVID-19 variant virues stopped down the UK, when everything is mess. However, we suceeded. Two grown-ups, one child and one cat. Anyway, I settled down now and started work in Oxford. Today, I’d like to share building a simple scene using <a href=\"https://www.blender.org/\">Blender</a> to present theoretical models.</p>","more":"<h2 id=\"The-plant-community-model\"><a href=\"#The-plant-community-model\" class=\"headerlink\" title=\"The plant community model\"></a>The plant community model</h2><p>The model is to describe how plants compete and coexist in a community. My work is to study bias in inferring density dependence invovling all kinds of systematic errors and also mechanistic misunderstandings. The model is simple. Plants produce seeds. Seeds disperse over the community. Seeds grow to plants. Normally, it is abstract to show the model processes in academic research. I was thinking to present it in a more vivid manner. </p>\n<h2 id=\"Blender-create-a-small-low-poly-scene\"><a href=\"#Blender-create-a-small-low-poly-scene\" class=\"headerlink\" title=\"Blender: create a small low poly scene\"></a>Blender: create a small low poly scene</h2><p>Thus, I learned Blender to create a small low poly scene. It is more like building an animation scene. </p>\n<p>Plants start with 5 apple trees. They produce apples that spread everywhere. Finally, after competition, a few grow to apple trees.</p>\n<img src=\"2021-03-21-Blender/Step1.png\" width=\"100%\" height=\"100%\">\n\n<img src=\"2021-03-21-Blender/Step2.png\" width=\"100%\" height=\"100%\">\n\n<img src=\"2021-03-21-Blender/Step3.png\" width=\"100%\" height=\"100%\">\n\n<p>A video is here. </p>\n<p><video src='smallworld.mp4' controls='controls'  width='100%' height='100%'>The <code>&lt;video&gt;</code> tag is not supported by your browser.<br></video><br>Well, it looks a bit dull but a good start, doesn’t it? It is a lot fun to learn a new skill!</p>"},{"title":"Hello World","date":"2018-10-20T07:00:00.000Z","_content":"Welcome to [Liang&apos;s blog](https://xl0418.github.io/)! This site is my first blog for sharing my work experience plus a little bit life. \n\n## Categories\n\n### Research\nThis category mainly contains my PhD projects so far. More details can be found on my [**Research Gate**](https://www.researchgate.net/profile/Liang_Xu50). \n\n### BB life\nSome interesting stuff about life. **BB**, in Chinese, means **talk about**, **chat**. \n\n### Work\nNot on work yet, although 3 years ago I was a lecturer in China. \n\n### Blogging\nInteresting technologies about blogging. \n\nAt last, enjoy the blog. Hope you can find something useful. Or at least have fun :-)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ncategories: [BB life]\ntags: [info]\ndate: 2018-10-20\n\n---\nWelcome to [Liang&apos;s blog](https://xl0418.github.io/)! This site is my first blog for sharing my work experience plus a little bit life. \n\n## Categories\n\n### Research\nThis category mainly contains my PhD projects so far. More details can be found on my [**Research Gate**](https://www.researchgate.net/profile/Liang_Xu50). \n\n### BB life\nSome interesting stuff about life. **BB**, in Chinese, means **talk about**, **chat**. \n\n### Work\nNot on work yet, although 3 years ago I was a lecturer in China. \n\n### Blogging\nInteresting technologies about blogging. \n\nAt last, enjoy the blog. Hope you can find something useful. Or at least have fun :-)\n","slug":"hello-world","published":1,"updated":"2022-09-17T02:04:05.657Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl85g866t009o4gkr8rky0p3j","content":"<p>Welcome to <a href=\"https://xl0418.github.io/\">Liang&amp;apos;s blog</a>! This site is my first blog for sharing my work experience plus a little bit life. </p>\n<h2 id=\"Categories\"><a href=\"#Categories\" class=\"headerlink\" title=\"Categories\"></a>Categories</h2><h3 id=\"Research\"><a href=\"#Research\" class=\"headerlink\" title=\"Research\"></a>Research</h3><p>This category mainly contains my PhD projects so far. More details can be found on my <a href=\"https://www.researchgate.net/profile/Liang_Xu50\"><strong>Research Gate</strong></a>. </p>\n<h3 id=\"BB-life\"><a href=\"#BB-life\" class=\"headerlink\" title=\"BB life\"></a>BB life</h3><p>Some interesting stuff about life. <strong>BB</strong>, in Chinese, means <strong>talk about</strong>, <strong>chat</strong>. </p>\n<h3 id=\"Work\"><a href=\"#Work\" class=\"headerlink\" title=\"Work\"></a>Work</h3><p>Not on work yet, although 3 years ago I was a lecturer in China. </p>\n<h3 id=\"Blogging\"><a href=\"#Blogging\" class=\"headerlink\" title=\"Blogging\"></a>Blogging</h3><p>Interesting technologies about blogging. </p>\n<p>At last, enjoy the blog. Hope you can find something useful. Or at least have fun :-)</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://xl0418.github.io/\">Liang&amp;apos;s blog</a>! This site is my first blog for sharing my work experience plus a little bit life. </p>\n<h2 id=\"Categories\"><a href=\"#Categories\" class=\"headerlink\" title=\"Categories\"></a>Categories</h2><h3 id=\"Research\"><a href=\"#Research\" class=\"headerlink\" title=\"Research\"></a>Research</h3><p>This category mainly contains my PhD projects so far. More details can be found on my <a href=\"https://www.researchgate.net/profile/Liang_Xu50\"><strong>Research Gate</strong></a>. </p>\n<h3 id=\"BB-life\"><a href=\"#BB-life\" class=\"headerlink\" title=\"BB life\"></a>BB life</h3><p>Some interesting stuff about life. <strong>BB</strong>, in Chinese, means <strong>talk about</strong>, <strong>chat</strong>. </p>\n<h3 id=\"Work\"><a href=\"#Work\" class=\"headerlink\" title=\"Work\"></a>Work</h3><p>Not on work yet, although 3 years ago I was a lecturer in China. </p>\n<h3 id=\"Blogging\"><a href=\"#Blogging\" class=\"headerlink\" title=\"Blogging\"></a>Blogging</h3><p>Interesting technologies about blogging. </p>\n<p>At last, enjoy the blog. Hope you can find something useful. Or at least have fun :-)</p>\n"}],"PostAsset":[{"_id":"source/_posts/2018-10-22-IntrotoPro1/Est_S2VS.jpg","slug":"Est_S2VS.jpg","post":"cl85g865i00034gkr2j0v09x9","modified":0,"renderable":0},{"_id":"source/_posts/2018-10-22-IntrotoPro1/Powertable.jpg","slug":"Powertable.jpg","post":"cl85g865i00034gkr2j0v09x9","modified":0,"renderable":0},{"_id":"source/_posts/2018-10-22-IntrotoPro1/Trees_S2.jpg","slug":"Trees_S2.jpg","post":"cl85g865i00034gkr2j0v09x9","modified":0,"renderable":0},{"_id":"source/_posts/2018-10-29-sed/d.png","slug":"d.png","post":"cl85g865p000e4gkr7tfnhozw","modified":0,"renderable":0},{"_id":"source/_posts/2018-10-29-sed/ds.png","slug":"ds.png","post":"cl85g865p000e4gkr7tfnhozw","modified":0,"renderable":0},{"_id":"source/_posts/2018-10-29-sed/rawdata.png","slug":"rawdata.png","post":"cl85g865p000e4gkr7tfnhozw","modified":0,"renderable":0},{"_id":"source/_posts/2018-11-29-color/col1.png","slug":"col1.png","post":"cl85g865r000i4gkrf61o361n","modified":0,"renderable":0},{"_id":"source/_posts/2018-11-29-color/col2.png","slug":"col2.png","post":"cl85g865r000i4gkrf61o361n","modified":0,"renderable":0},{"_id":"source/_posts/2018-11-29-color/col3.png","slug":"col3.png","post":"cl85g865r000i4gkrf61o361n","modified":0,"renderable":0},{"_id":"source/_posts/2018-11-29-color/col4.png","slug":"col4.png","post":"cl85g865r000i4gkrf61o361n","modified":0,"renderable":0},{"_id":"source/_posts/2019-01-04-PyCUDAseries1/vsinstaller.png","slug":"vsinstaller.png","post":"cl85g865u000p4gkr8c40fsbw","modified":0,"renderable":0},{"_id":"source/_posts/2019-01-04-PyCUDAseries1/win10SDK.png","slug":"win10SDK.png","post":"cl85g865u000p4gkr8c40fsbw","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-05-ggradar2/fullscore.png","slug":"fullscore.png","post":"cl85g865s000l4gkrcg7282ew","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-05-ggradar2/lux.png","slug":"lux.png","post":"cl85g865s000l4gkrcg7282ew","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-05-ggradar2/mini.png","slug":"mini.png","post":"cl85g865s000l4gkrcg7282ew","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-05-ggradar2/multipleplots.png","slug":"multipleplots.png","post":"cl85g865s000l4gkrcg7282ew","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-05-ggradar2/multipleplotsbig.png","slug":"multipleplotsbig.png","post":"cl85g865s000l4gkrcg7282ew","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-05-ggradar2/nolegend.png","slug":"nolegend.png","post":"cl85g865s000l4gkrcg7282ew","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-05-ggradar2/roundfill.png","slug":"roundfill.png","post":"cl85g865s000l4gkrcg7282ew","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-05-ggradar2/roundnofill.png","slug":"roundnofill.png","post":"cl85g865s000l4gkrcg7282ew","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-05-ggradar2/straightfill.png","slug":"straightfill.png","post":"cl85g865s000l4gkrcg7282ew","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-05-ggradar2/straightnofill.png","slug":"straightnofill.png","post":"cl85g865s000l4gkrcg7282ew","modified":0,"renderable":0},{"_id":"source/_posts/2018-12-05-ggradar2/trend.png","slug":"trend.png","post":"cl85g865s000l4gkrcg7282ew","modified":0,"renderable":0},{"_id":"source/_posts/2018-11-30-SMCplots/Rplot1.png","slug":"Rplot1.png","post":"cl85g865t000m4gkr67h2adtj","modified":0,"renderable":0},{"_id":"source/_posts/2018-11-30-SMCplots/Rplot2.png","slug":"Rplot2.png","post":"cl85g865t000m4gkr67h2adtj","modified":0,"renderable":0},{"_id":"source/_posts/2019-01-10sed2/mfiles.png","slug":"mfiles.png","post":"cl85g865v000u4gkr9vgahe9i","modified":0,"renderable":0},{"_id":"source/_posts/2019-01-10sed2/rdatafiles.png","slug":"rdatafiles.png","post":"cl85g865v000u4gkr9vgahe9i","modified":0,"renderable":0},{"_id":"source/_posts/2019-01-14-PyCUDAseries2/gridblockthread.png","slug":"gridblockthread.png","post":"cl85g865w00104gkr5icq7o20","modified":0,"renderable":0},{"_id":"source/_posts/2019-01-14-PyCUDAseries2/speedtest.png","slug":"speedtest.png","post":"cl85g865w00104gkr5icq7o20","modified":0,"renderable":0},{"_id":"source/_posts/2019-02-01-Machinelearningseries1/modelselection1.png","slug":"modelselection1.png","post":"cl85g865x00134gkr5nm07o1y","modified":0,"renderable":0},{"_id":"source/_posts/2019-02-01-Machinelearningseries1/prediction_sample.png","slug":"prediction_sample.png","post":"cl85g865x00134gkr5nm07o1y","modified":0,"renderable":0},{"_id":"source/_posts/2019-03-20-readdatadon/d.png","slug":"d.png","post":"cl85g865y00174gkr2x3740kp","modified":0,"renderable":0},{"_id":"source/_posts/2019-03-20-readdatadon/rewrittendata.png","slug":"rewrittendata.png","post":"cl85g865y00174gkr2x3740kp","modified":0,"renderable":0},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/1.png","slug":"1.png","post":"cl85g865x00154gkrfjxudrhj","modified":0,"renderable":0},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/10.png","slug":"10.png","post":"cl85g865x00154gkrfjxudrhj","modified":0,"renderable":0},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/11.png","slug":"11.png","post":"cl85g865x00154gkrfjxudrhj","modified":0,"renderable":0},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/12.png","slug":"12.png","post":"cl85g865x00154gkrfjxudrhj","modified":0,"renderable":0},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/13-15.png","slug":"13-15.png","post":"cl85g865x00154gkrfjxudrhj","modified":0,"renderable":0},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/16.png","slug":"16.png","post":"cl85g865x00154gkrfjxudrhj","modified":0,"renderable":0},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/17.png","slug":"17.png","post":"cl85g865x00154gkrfjxudrhj","modified":0,"renderable":0},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/18.png","slug":"18.png","post":"cl85g865x00154gkrfjxudrhj","modified":0,"renderable":0},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/19-1.png","slug":"19-1.png","post":"cl85g865x00154gkrfjxudrhj","modified":0,"renderable":0},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/19.png","slug":"19.png","post":"cl85g865x00154gkrfjxudrhj","modified":0,"renderable":0},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/2.png","slug":"2.png","post":"cl85g865x00154gkrfjxudrhj","modified":0,"renderable":0},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/20.png","slug":"20.png","post":"cl85g865x00154gkrfjxudrhj","modified":0,"renderable":0},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/21.png","slug":"21.png","post":"cl85g865x00154gkrfjxudrhj","modified":0,"renderable":0},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/22.png","slug":"22.png","post":"cl85g865x00154gkrfjxudrhj","modified":0,"renderable":0},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/23.png","slug":"23.png","post":"cl85g865x00154gkrfjxudrhj","modified":0,"renderable":0},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/24.png","slug":"24.png","post":"cl85g865x00154gkrfjxudrhj","modified":0,"renderable":0},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/25.png","slug":"25.png","post":"cl85g865x00154gkrfjxudrhj","modified":0,"renderable":0},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/3.png","slug":"3.png","post":"cl85g865x00154gkrfjxudrhj","modified":0,"renderable":0},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/4.png","slug":"4.png","post":"cl85g865x00154gkrfjxudrhj","modified":0,"renderable":0},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/5.png","slug":"5.png","post":"cl85g865x00154gkrfjxudrhj","modified":0,"renderable":0},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/6.png","slug":"6.png","post":"cl85g865x00154gkrfjxudrhj","modified":0,"renderable":0},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/78.png","slug":"78.png","post":"cl85g865x00154gkrfjxudrhj","modified":0,"renderable":0},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/9-1.png","slug":"9-1.png","post":"cl85g865x00154gkrfjxudrhj","modified":0,"renderable":0},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/9.png","slug":"9.png","post":"cl85g865x00154gkrfjxudrhj","modified":0,"renderable":0},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/step1.png","slug":"step1.png","post":"cl85g865x00154gkrfjxudrhj","modified":0,"renderable":0},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/step2.png","slug":"step2.png","post":"cl85g865x00154gkrfjxudrhj","modified":0,"renderable":0},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/step3.png","slug":"step3.png","post":"cl85g865x00154gkrfjxudrhj","modified":0,"renderable":0},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/step4.png","slug":"step4.png","post":"cl85g865x00154gkrfjxudrhj","modified":0,"renderable":0},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/step5.png","slug":"step5.png","post":"cl85g865x00154gkrfjxudrhj","modified":0,"renderable":0},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/step6.png","slug":"step6.png","post":"cl85g865x00154gkrfjxudrhj","modified":0,"renderable":0},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/step7.png","slug":"step7.png","post":"cl85g865x00154gkrfjxudrhj","modified":0,"renderable":0},{"_id":"source/_posts/2019-02-08-Machinelearningseries2/step8.png","slug":"step8.png","post":"cl85g865x00154gkrfjxudrhj","modified":0,"renderable":0},{"_id":"source/_posts/2019-06-21-ABCalgorithm/MCMC3chains_test3.mp4","slug":"MCMC3chains_test3.mp4","post":"cl85g865y00194gkrbl9422jq","modified":0,"renderable":0},{"_id":"source/_posts/2019-06-21-ABCalgorithm/modelseleSMC.png","slug":"modelseleSMC.png","post":"cl85g865y00194gkrbl9422jq","modified":0,"renderable":0},{"_id":"source/_posts/2019-06-21-ABCalgorithm/Rplot2.png","slug":"Rplot2.png","post":"cl85g865y00194gkrbl9422jq","modified":0,"renderable":0},{"_id":"source/_posts/2019-06-21-TPmodel/guixianren1.jpg","slug":"guixianren1.jpg","post":"cl85g865z001d4gkrhndx6250","modified":0,"renderable":0},{"_id":"source/_posts/2019-06-21-TPmodel/guixianren_s.png","slug":"guixianren_s.png","post":"cl85g865z001d4gkrhndx6250","modified":0,"renderable":0},{"_id":"source/_posts/2019-06-21-TPmodel/multi6species15.mp4","slug":"multi6species15.mp4","post":"cl85g865z001d4gkrhndx6250","modified":0,"renderable":0},{"_id":"source/_posts/2019-06-21-TPmodel/singlespecies5.mp4","slug":"singlespecies5.mp4","post":"cl85g865z001d4gkrhndx6250","modified":0,"renderable":0},{"_id":"source/_posts/2020-03-09-GUI-traitevolution/p1.png","slug":"p1.png","post":"cl85g8660001f4gkrd9x3gder","modified":0,"renderable":0},{"_id":"source/_posts/2020-03-09-GUI-traitevolution/p2.png","slug":"p2.png","post":"cl85g8660001f4gkrd9x3gder","modified":0,"renderable":0},{"_id":"source/_posts/2020-03-09-GUI-traitevolution/p3.png","slug":"p3.png","post":"cl85g8660001f4gkrd9x3gder","modified":0,"renderable":0},{"_id":"source/_posts/2020-03-09-GUI-traitevolution/p4.png","slug":"p4.png","post":"cl85g8660001f4gkrd9x3gder","modified":0,"renderable":0},{"_id":"source/_posts/2020-03-18-generalABC/abc_scheme.png","slug":"abc_scheme.png","post":"cl85g8660001k4gkrd5xgg0vj","modified":0,"renderable":0},{"_id":"source/_posts/2020-03-18-generalABC/data.png","slug":"data.png","post":"cl85g8660001k4gkrd5xgg0vj","modified":0,"renderable":0},{"_id":"source/_posts/2020-03-18-generalABC/Predict1.png","slug":"Predict1.png","post":"cl85g8660001k4gkrd5xgg0vj","modified":0,"renderable":0},{"_id":"source/_posts/2020-03-18-generalABC/Predict2.png","slug":"Predict2.png","post":"cl85g8660001k4gkrd5xgg0vj","modified":0,"renderable":0},{"_id":"source/_posts/2020-03-18-generalABC/setup_model1.gif","slug":"setup_model1.gif","post":"cl85g8660001k4gkrd5xgg0vj","modified":0,"renderable":0},{"_id":"source/_posts/2020-03-18-generalABC/setup_model2.gif","slug":"setup_model2.gif","post":"cl85g8660001k4gkrd5xgg0vj","modified":0,"renderable":0},{"_id":"source/_posts/2021-03-21-Blender/smallworld.mkv","slug":"smallworld.mkv","post":"cl85g866t009l4gkr42qrda4h","modified":0,"renderable":0},{"_id":"source/_posts/2021-03-21-Blender/smallworld.mp4","slug":"smallworld.mp4","post":"cl85g866t009l4gkr42qrda4h","modified":0,"renderable":0},{"_id":"source/_posts/2021-03-21-Blender/Step1.png","slug":"Step1.png","post":"cl85g866t009l4gkr42qrda4h","modified":0,"renderable":0},{"_id":"source/_posts/2021-03-21-Blender/Step2.png","slug":"Step2.png","post":"cl85g866t009l4gkr42qrda4h","modified":0,"renderable":0},{"_id":"source/_posts/2021-03-21-Blender/Step3.png","slug":"Step3.png","post":"cl85g866t009l4gkr42qrda4h","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cl85g865g00014gkr7ues6xzi","category_id":"cl85g865k00044gkrhlv40hho","_id":"cl85g865w000z4gkre1zs0zuu"},{"post_id":"cl85g865g00014gkr7ues6xzi","category_id":"cl85g865t000n4gkrd4zeab98","_id":"cl85g865w00124gkrc9aq7xba"},{"post_id":"cl85g865p000d4gkr550h6ycp","category_id":"cl85g865o000a4gkr7r74ai3a","_id":"cl85g865y00184gkr4jq4e4y2"},{"post_id":"cl85g865p000d4gkr550h6ycp","category_id":"cl85g865w000y4gkr2d7ofey4","_id":"cl85g865z001c4gkraw445mam"},{"post_id":"cl85g865i00034gkr2j0v09x9","category_id":"cl85g865o000a4gkr7r74ai3a","_id":"cl85g8660001g4gkr72oiftv8"},{"post_id":"cl85g865i00034gkr2j0v09x9","category_id":"cl85g865x00144gkr82s18vrl","_id":"cl85g8661001l4gkr08b6dsnh"},{"post_id":"cl85g865r000h4gkre3l70jme","category_id":"cl85g865o000a4gkr7r74ai3a","_id":"cl85g8663001s4gkr87ey2p2p"},{"post_id":"cl85g865r000h4gkre3l70jme","category_id":"cl85g8660001h4gkreg3iaviq","_id":"cl85g8663001v4gkratii4bi8"},{"post_id":"cl85g865l00074gkr2rek13ea","category_id":"cl85g865o000a4gkr7r74ai3a","_id":"cl85g8663001w4gkrd9ok7b8n"},{"post_id":"cl85g865l00074gkr2rek13ea","category_id":"cl85g8661001p4gkrbhmk04yj","_id":"cl85g8663001z4gkrap0daqid"},{"post_id":"cl85g865z001d4gkrhndx6250","category_id":"cl85g865o000a4gkr7r74ai3a","_id":"cl85g866900374gkr87urezvm"},{"post_id":"cl85g865z001d4gkrhndx6250","category_id":"cl85g865x00144gkr82s18vrl","_id":"cl85g8669003a4gkr54ss5pay"},{"post_id":"cl85g865z001d4gkrhndx6250","category_id":"cl85g866900304gkr3ih5hfi8","_id":"cl85g8669003d4gkrgjk7f4g7"},{"post_id":"cl85g865p000e4gkr7tfnhozw","category_id":"cl85g865o000a4gkr7r74ai3a","_id":"cl85g866a003f4gkr1u3sflo8"},{"post_id":"cl85g865p000e4gkr7tfnhozw","category_id":"cl85g865z001a4gkr5g115raf","_id":"cl85g866a003h4gkr9f0314ap"},{"post_id":"cl85g865p000e4gkr7tfnhozw","category_id":"cl85g866900334gkra0uh6i4m","_id":"cl85g866a003j4gkrb3ja7qmj"},{"post_id":"cl85g8661001n4gkrcs8f61c7","category_id":"cl85g865o000a4gkr7r74ai3a","_id":"cl85g866a003q4gkrh7kv19i6"},{"post_id":"cl85g8661001n4gkrcs8f61c7","category_id":"cl85g866a003i4gkragpy0lti","_id":"cl85g866a003s4gkrcreearrj"},{"post_id":"cl85g8662001q4gkr1hms43aw","category_id":"cl85g865o000a4gkr7r74ai3a","_id":"cl85g866a003v4gkrc1jv086h"},{"post_id":"cl85g8662001q4gkr1hms43aw","category_id":"cl85g866a003i4gkragpy0lti","_id":"cl85g866b003x4gkrhb247cip"},{"post_id":"cl85g865r000i4gkrf61o361n","category_id":"cl85g865o000a4gkr7r74ai3a","_id":"cl85g866b00404gkrdcg4hys5"},{"post_id":"cl85g865r000i4gkrf61o361n","category_id":"cl85g8663001t4gkreydo97xp","_id":"cl85g866b00424gkrc1hn0i8e"},{"post_id":"cl85g865r000i4gkrf61o361n","category_id":"cl85g866a003p4gkraxadd4ew","_id":"cl85g866b00454gkr07tn63pn"},{"post_id":"cl85g865m00084gkr7oephe2y","category_id":"cl85g865o000a4gkr7r74ai3a","_id":"cl85g866b004a4gkr32vzgqhq"},{"post_id":"cl85g865m00084gkr7oephe2y","category_id":"cl85g8660001h4gkreg3iaviq","_id":"cl85g866b004b4gkra0juahdu"},{"post_id":"cl85g865m00084gkr7oephe2y","category_id":"cl85g866b003z4gkra3rg7pyc","_id":"cl85g866b004c4gkra3ud2tak"},{"post_id":"cl85g865t000m4gkr67h2adtj","category_id":"cl85g865o000a4gkr7r74ai3a","_id":"cl85g866c004f4gkr7mfbhpcf"},{"post_id":"cl85g865t000m4gkr67h2adtj","category_id":"cl85g8663001t4gkreydo97xp","_id":"cl85g866c004g4gkra1nl025o"},{"post_id":"cl85g865t000m4gkr67h2adtj","category_id":"cl85g866a003p4gkraxadd4ew","_id":"cl85g866c004j4gkrag2gd5ls"},{"post_id":"cl85g865u000p4gkr8c40fsbw","category_id":"cl85g865o000a4gkr7r74ai3a","_id":"cl85g866c004l4gkr5beo9d5j"},{"post_id":"cl85g865u000p4gkr8c40fsbw","category_id":"cl85g866500254gkrfaq921nq","_id":"cl85g866c004p4gkr07rt4r7z"},{"post_id":"cl85g865u000p4gkr8c40fsbw","category_id":"cl85g866b00494gkrb34757ug","_id":"cl85g866c004r4gkr8z8p6rdh"},{"post_id":"cl85g865v000u4gkr9vgahe9i","category_id":"cl85g865o000a4gkr7r74ai3a","_id":"cl85g866d004v4gkr0wvy8een"},{"post_id":"cl85g865v000u4gkr9vgahe9i","category_id":"cl85g865z001a4gkr5g115raf","_id":"cl85g866d004w4gkrec1cgmww"},{"post_id":"cl85g865v000u4gkr9vgahe9i","category_id":"cl85g866900334gkra0uh6i4m","_id":"cl85g866d004z4gkr5rqv4dso"},{"post_id":"cl85g865n00094gkr361ueizd","category_id":"cl85g865o000a4gkr7r74ai3a","_id":"cl85g866d00504gkrblbx0c4t"},{"post_id":"cl85g865n00094gkr361ueizd","category_id":"cl85g8660001h4gkreg3iaviq","_id":"cl85g866d00524gkr6e14f2a6"},{"post_id":"cl85g865n00094gkr361ueizd","category_id":"cl85g866b003z4gkra3rg7pyc","_id":"cl85g866d00554gkrf8dk6t0y"},{"post_id":"cl85g865v000x4gkr2o50aj1i","category_id":"cl85g865o000a4gkr7r74ai3a","_id":"cl85g866e00584gkr30b12uya"},{"post_id":"cl85g865v000x4gkr2o50aj1i","category_id":"cl85g866500254gkrfaq921nq","_id":"cl85g866e005b4gkra9alfhkc"},{"post_id":"cl85g865v000x4gkr2o50aj1i","category_id":"cl85g866b00494gkrb34757ug","_id":"cl85g866e005e4gkrgtta071o"},{"post_id":"cl85g865w00104gkr5icq7o20","category_id":"cl85g865o000a4gkr7r74ai3a","_id":"cl85g866e005g4gkr5dba58vg"},{"post_id":"cl85g865w00104gkr5icq7o20","category_id":"cl85g866500254gkrfaq921nq","_id":"cl85g866e005i4gkr0n6s3pmi"},{"post_id":"cl85g865w00104gkr5icq7o20","category_id":"cl85g866b00494gkrb34757ug","_id":"cl85g866e005k4gkrbh2u6181"},{"post_id":"cl85g865x00134gkr5nm07o1y","category_id":"cl85g865o000a4gkr7r74ai3a","_id":"cl85g866e005m4gkr98sp3yyi"},{"post_id":"cl85g865x00134gkr5nm07o1y","category_id":"cl85g8667002n4gkr59ur5at0","_id":"cl85g866f005o4gkrdidqflr5"},{"post_id":"cl85g865x00134gkr5nm07o1y","category_id":"cl85g866d00514gkrfm7v9t8t","_id":"cl85g866f005r4gkr8vuxbswv"},{"post_id":"cl85g865x00154gkrfjxudrhj","category_id":"cl85g865o000a4gkr7r74ai3a","_id":"cl85g866f005u4gkr0qr01umj"},{"post_id":"cl85g865x00154gkrfjxudrhj","category_id":"cl85g8667002n4gkr59ur5at0","_id":"cl85g866f005x4gkr8yodaxtw"},{"post_id":"cl85g865x00154gkrfjxudrhj","category_id":"cl85g866d00514gkrfm7v9t8t","_id":"cl85g866f00604gkrdxf32feh"},{"post_id":"cl85g865y00174gkr2x3740kp","category_id":"cl85g865o000a4gkr7r74ai3a","_id":"cl85g866f00614gkr8c1nbfgl"},{"post_id":"cl85g865y00174gkr2x3740kp","category_id":"cl85g865z001a4gkr5g115raf","_id":"cl85g866f00634gkr8l77f60x"},{"post_id":"cl85g865y00174gkr2x3740kp","category_id":"cl85g866900334gkra0uh6i4m","_id":"cl85g866g00654gkr55t66fyq"},{"post_id":"cl85g865y00194gkrbl9422jq","category_id":"cl85g865o000a4gkr7r74ai3a","_id":"cl85g866g00664gkr13gy6b8x"},{"post_id":"cl85g865y00194gkrbl9422jq","category_id":"cl85g8668002y4gkrei7y9g4x","_id":"cl85g866g00684gkr4uvc32os"},{"post_id":"cl85g865y00194gkrbl9422jq","category_id":"cl85g866e005h4gkr4583dupr","_id":"cl85g866g006a4gkrhyux4uu6"},{"post_id":"cl85g8660001f4gkrd9x3gder","category_id":"cl85g865o000a4gkr7r74ai3a","_id":"cl85g866g006d4gkr997wa1gw"},{"post_id":"cl85g8660001f4gkrd9x3gder","category_id":"cl85g866900384gkr37xx56fc","_id":"cl85g866g006f4gkrb8hxhls0"},{"post_id":"cl85g8660001f4gkrd9x3gder","category_id":"cl85g866e005l4gkra7jygnun","_id":"cl85g866h006i4gkrda9ydw62"},{"post_id":"cl85g8660001k4gkrd5xgg0vj","category_id":"cl85g865o000a4gkr7r74ai3a","_id":"cl85g866h006j4gkr4v8y0zmh"},{"post_id":"cl85g8660001k4gkrd5xgg0vj","category_id":"cl85g8668002y4gkrei7y9g4x","_id":"cl85g866h006l4gkrfuzbeewq"},{"post_id":"cl85g8660001k4gkrd5xgg0vj","category_id":"cl85g866e005h4gkr4583dupr","_id":"cl85g866h006m4gkrdng738vv"},{"post_id":"cl85g865s000l4gkrcg7282ew","category_id":"cl85g865o000a4gkr7r74ai3a","_id":"cl85g866h006o4gkrh9qce5f3"},{"post_id":"cl85g865s000l4gkrcg7282ew","category_id":"cl85g8663001t4gkreydo97xp","_id":"cl85g866h006p4gkr3ckdc1jj"},{"post_id":"cl85g865s000l4gkrcg7282ew","category_id":"cl85g866a003p4gkraxadd4ew","_id":"cl85g866h006r4gkrdqi34w15"},{"post_id":"cl85g865s000l4gkrcg7282ew","category_id":"cl85g866f005w4gkrgrcchzmm","_id":"cl85g866h006t4gkr0m1v4tp1"},{"post_id":"cl85g865u000r4gkrgpq9aw2f","category_id":"cl85g865o000a4gkr7r74ai3a","_id":"cl85g866i006w4gkrebz4d3g4"},{"post_id":"cl85g865u000r4gkrgpq9aw2f","category_id":"cl85g8663001t4gkreydo97xp","_id":"cl85g866i006y4gkr6wx2g6n1"},{"post_id":"cl85g865u000r4gkrgpq9aw2f","category_id":"cl85g866a003p4gkraxadd4ew","_id":"cl85g866i00714gkr883mazq4"},{"post_id":"cl85g865u000r4gkrgpq9aw2f","category_id":"cl85g866f005w4gkrgrcchzmm","_id":"cl85g866i00734gkr05waand6"},{"post_id":"cl85g866t009l4gkr42qrda4h","category_id":"cl85g865o000a4gkr7r74ai3a","_id":"cl85g866u009p4gkrhy5vae43"},{"post_id":"cl85g866s009k4gkrbqwpdz0o","category_id":"cl85g866t009m4gkr68d25750","_id":"cl85g866u009t4gkrbjp6bst4"},{"post_id":"cl85g866t009o4gkr8rky0p3j","category_id":"cl85g866t009m4gkr68d25750","_id":"cl85g866u009w4gkrakeqb002"}],"PostTag":[{"post_id":"cl85g865g00014gkr7ues6xzi","tag_id":"cl85g865l00054gkrcs4f629y","_id":"cl85g865p000c4gkrda8l12tl"},{"post_id":"cl85g865i00034gkr2j0v09x9","tag_id":"cl85g865o000b4gkr7z6he3rc","_id":"cl85g865u000q4gkr8zgr8cao"},{"post_id":"cl85g865i00034gkr2j0v09x9","tag_id":"cl85g865q000g4gkr8nv1fe4g","_id":"cl85g865v000t4gkre6ba060t"},{"post_id":"cl85g865i00034gkr2j0v09x9","tag_id":"cl85g865s000k4gkr0wya7xz7","_id":"cl85g865v000w4gkrhbct0v7v"},{"post_id":"cl85g865l00074gkr2rek13ea","tag_id":"cl85g865u000o4gkr62nudqa3","_id":"cl85g865z001e4gkradov05dv"},{"post_id":"cl85g865l00074gkr2rek13ea","tag_id":"cl85g865v000v4gkr0ogx5hhp","_id":"cl85g8660001i4gkr61buec4h"},{"post_id":"cl85g865l00074gkr2rek13ea","tag_id":"cl85g865q000g4gkr8nv1fe4g","_id":"cl85g8661001m4gkrdig95edo"},{"post_id":"cl85g865l00074gkr2rek13ea","tag_id":"cl85g865y00164gkr0qyba2r6","_id":"cl85g8661001o4gkr77h81m19"},{"post_id":"cl85g865m00084gkr7oephe2y","tag_id":"cl85g865z001b4gkrhz7if4k5","_id":"cl85g866500244gkr5upcdv7w"},{"post_id":"cl85g865m00084gkr7oephe2y","tag_id":"cl85g8660001j4gkrcif42mh3","_id":"cl85g866500264gkr1262004p"},{"post_id":"cl85g865m00084gkr7oephe2y","tag_id":"cl85g8662001r4gkr58x5784x","_id":"cl85g866500284gkrb0wb29pv"},{"post_id":"cl85g865m00084gkr7oephe2y","tag_id":"cl85g8663001u4gkr9akn56z4","_id":"cl85g8665002a4gkr21gd0pyf"},{"post_id":"cl85g865m00084gkr7oephe2y","tag_id":"cl85g8663001y4gkrd16h6mqp","_id":"cl85g8666002c4gkr6m0ngzoe"},{"post_id":"cl85g865m00084gkr7oephe2y","tag_id":"cl85g866400214gkrb2gpepd8","_id":"cl85g8666002e4gkrhv3fh54k"},{"post_id":"cl85g865n00094gkr361ueizd","tag_id":"cl85g865z001b4gkrhz7if4k5","_id":"cl85g8667002m4gkrgb90dro7"},{"post_id":"cl85g865n00094gkr361ueizd","tag_id":"cl85g8660001j4gkrcif42mh3","_id":"cl85g8668002o4gkr3voybkik"},{"post_id":"cl85g865n00094gkr361ueizd","tag_id":"cl85g8662001r4gkr58x5784x","_id":"cl85g8668002q4gkr8gohexlg"},{"post_id":"cl85g865n00094gkr361ueizd","tag_id":"cl85g8663001u4gkr9akn56z4","_id":"cl85g8668002s4gkr1hb1anz4"},{"post_id":"cl85g865n00094gkr361ueizd","tag_id":"cl85g8663001y4gkrd16h6mqp","_id":"cl85g8668002u4gkr53sqe959"},{"post_id":"cl85g865n00094gkr361ueizd","tag_id":"cl85g866400214gkrb2gpepd8","_id":"cl85g8668002w4gkr9uwxgjhf"},{"post_id":"cl85g865p000d4gkr550h6ycp","tag_id":"cl85g8667002l4gkr7pr96al5","_id":"cl85g866900324gkreeiq7l8h"},{"post_id":"cl85g865p000d4gkr550h6ycp","tag_id":"cl85g8668002p4gkr4dj880qd","_id":"cl85g866900344gkrdh4d8a40"},{"post_id":"cl85g865p000d4gkr550h6ycp","tag_id":"cl85g8668002t4gkr0whd1kdz","_id":"cl85g866900364gkrhsr26hq1"},{"post_id":"cl85g865p000d4gkr550h6ycp","tag_id":"cl85g865y00164gkr0qyba2r6","_id":"cl85g866900394gkr7lq7448d"},{"post_id":"cl85g865p000d4gkr550h6ycp","tag_id":"cl85g8668002z4gkr7srs0o85","_id":"cl85g8669003c4gkr1mcg57ej"},{"post_id":"cl85g865p000e4gkr7tfnhozw","tag_id":"cl85g866900314gkreqjacg3v","_id":"cl85g866a003m4gkr4h87dtb7"},{"post_id":"cl85g865p000e4gkr7tfnhozw","tag_id":"cl85g866900354gkrcwyc0t07","_id":"cl85g866a003n4gkrdvnngbpx"},{"post_id":"cl85g865p000e4gkr7tfnhozw","tag_id":"cl85g8669003b4gkred5x7ki7","_id":"cl85g866a003r4gkr0xsjet8t"},{"post_id":"cl85g865p000e4gkr7tfnhozw","tag_id":"cl85g866a003g4gkr1g214dh4","_id":"cl85g866a003t4gkr40xe0738"},{"post_id":"cl85g865r000h4gkre3l70jme","tag_id":"cl85g866a003k4gkrawmw3d19","_id":"cl85g866b00414gkr8bfs2jbl"},{"post_id":"cl85g865r000h4gkre3l70jme","tag_id":"cl85g866a003o4gkr4ztb503w","_id":"cl85g866b00434gkr1dep5zfo"},{"post_id":"cl85g865r000h4gkre3l70jme","tag_id":"cl85g866a003u4gkrgr4b6j69","_id":"cl85g866b00474gkr7zq63cqx"},{"post_id":"cl85g865r000i4gkrf61o361n","tag_id":"cl85g866a003k4gkrawmw3d19","_id":"cl85g866c004k4gkr0wgpgqfx"},{"post_id":"cl85g865r000i4gkrf61o361n","tag_id":"cl85g866b00444gkr81883sxh","_id":"cl85g866c004m4gkr726g0t5m"},{"post_id":"cl85g865r000i4gkrf61o361n","tag_id":"cl85g866b00484gkr9y756pkg","_id":"cl85g866c004q4gkrhwpgdcu2"},{"post_id":"cl85g865r000i4gkrf61o361n","tag_id":"cl85g866c004d4gkr79bhax9g","_id":"cl85g866c004s4gkrars32ddu"},{"post_id":"cl85g865s000l4gkrcg7282ew","tag_id":"cl85g866a003k4gkrawmw3d19","_id":"cl85g866d00544gkre0oc115u"},{"post_id":"cl85g865s000l4gkrcg7282ew","tag_id":"cl85g866c004o4gkrck5m9kj7","_id":"cl85g866e00574gkrecaxefgt"},{"post_id":"cl85g865s000l4gkrcg7282ew","tag_id":"cl85g866d004u4gkrdzf88iaf","_id":"cl85g866e005a4gkrgio2f4gl"},{"post_id":"cl85g865s000l4gkrcg7282ew","tag_id":"cl85g866d004y4gkr6ble7fhs","_id":"cl85g866e005d4gkrgaycht9n"},{"post_id":"cl85g865t000m4gkr67h2adtj","tag_id":"cl85g866a003k4gkrawmw3d19","_id":"cl85g866f005p4gkr5ggxe9r3"},{"post_id":"cl85g865t000m4gkr67h2adtj","tag_id":"cl85g866c004o4gkrck5m9kj7","_id":"cl85g866f005s4gkr6oom5a2w"},{"post_id":"cl85g865t000m4gkr67h2adtj","tag_id":"cl85g866e005f4gkr9q2eevn0","_id":"cl85g866f005v4gkr11jh2ujf"},{"post_id":"cl85g865t000m4gkr67h2adtj","tag_id":"cl85g866d004y4gkr6ble7fhs","_id":"cl85g866f005y4gkr5psr68x9"},{"post_id":"cl85g865u000p4gkr8c40fsbw","tag_id":"cl85g866e005n4gkrfrj60g7u","_id":"cl85g866g00694gkrdv6o7xcw"},{"post_id":"cl85g865u000p4gkr8c40fsbw","tag_id":"cl85g866f005t4gkrffl9h3u9","_id":"cl85g866g006b4gkrgn8r9aku"},{"post_id":"cl85g865u000p4gkr8c40fsbw","tag_id":"cl85g866f005z4gkrfqd67775","_id":"cl85g866g006e4gkr29255s1w"},{"post_id":"cl85g865u000p4gkr8c40fsbw","tag_id":"cl85g866f00644gkr6r88hgtb","_id":"cl85g866g006g4gkregcy5ew5"},{"post_id":"cl85g865u000r4gkrgpq9aw2f","tag_id":"cl85g866a003k4gkrawmw3d19","_id":"cl85g866h006s4gkr07fcgzit"},{"post_id":"cl85g865u000r4gkrgpq9aw2f","tag_id":"cl85g866c004o4gkrck5m9kj7","_id":"cl85g866h006u4gkr5ac3egv4"},{"post_id":"cl85g865u000r4gkrgpq9aw2f","tag_id":"cl85g866d004u4gkrdzf88iaf","_id":"cl85g866i006x4gkrf8b0ajfc"},{"post_id":"cl85g865u000r4gkrgpq9aw2f","tag_id":"cl85g866d004y4gkr6ble7fhs","_id":"cl85g866i006z4gkr3mh17nnx"},{"post_id":"cl85g865u000r4gkrgpq9aw2f","tag_id":"cl85g866h006n4gkr6mpp921h","_id":"cl85g866i00724gkra3l587p2"},{"post_id":"cl85g865v000u4gkr9vgahe9i","tag_id":"cl85g866900314gkreqjacg3v","_id":"cl85g866i00764gkrbr9j5rhk"},{"post_id":"cl85g865v000u4gkr9vgahe9i","tag_id":"cl85g866900354gkrcwyc0t07","_id":"cl85g866j00774gkr88m4b5n4"},{"post_id":"cl85g865v000u4gkr9vgahe9i","tag_id":"cl85g8669003b4gkred5x7ki7","_id":"cl85g866j00794gkrepyr401i"},{"post_id":"cl85g865v000u4gkr9vgahe9i","tag_id":"cl85g866a003g4gkr1g214dh4","_id":"cl85g866j007a4gkr8gyx58wg"},{"post_id":"cl85g865v000x4gkr2o50aj1i","tag_id":"cl85g866e005n4gkrfrj60g7u","_id":"cl85g866k007e4gkr2iphcoft"},{"post_id":"cl85g865v000x4gkr2o50aj1i","tag_id":"cl85g866f005t4gkrffl9h3u9","_id":"cl85g866k007f4gkr69ro6j5j"},{"post_id":"cl85g865v000x4gkr2o50aj1i","tag_id":"cl85g866f005z4gkrfqd67775","_id":"cl85g866k007h4gkraq6q2da7"},{"post_id":"cl85g865v000x4gkr2o50aj1i","tag_id":"cl85g866f00644gkr6r88hgtb","_id":"cl85g866k007i4gkr1gs57t26"},{"post_id":"cl85g865w00104gkr5icq7o20","tag_id":"cl85g866e005n4gkrfrj60g7u","_id":"cl85g866l007m4gkr701pbips"},{"post_id":"cl85g865w00104gkr5icq7o20","tag_id":"cl85g866f005t4gkrffl9h3u9","_id":"cl85g866l007n4gkrbm1r1oe7"},{"post_id":"cl85g865w00104gkr5icq7o20","tag_id":"cl85g866f005z4gkrfqd67775","_id":"cl85g866l007p4gkra12t1ua3"},{"post_id":"cl85g865w00104gkr5icq7o20","tag_id":"cl85g866f00644gkr6r88hgtb","_id":"cl85g866l007q4gkrbd300s5i"},{"post_id":"cl85g865x00134gkr5nm07o1y","tag_id":"cl85g866e005n4gkrfrj60g7u","_id":"cl85g866m007u4gkrff3h4sp0"},{"post_id":"cl85g865x00134gkr5nm07o1y","tag_id":"cl85g866l007o4gkr9mci6ve9","_id":"cl85g866m007v4gkr435edezv"},{"post_id":"cl85g865x00134gkr5nm07o1y","tag_id":"cl85g866l007r4gkrbhlw5sl9","_id":"cl85g866m007x4gkr392efozc"},{"post_id":"cl85g865x00134gkr5nm07o1y","tag_id":"cl85g866f005z4gkrfqd67775","_id":"cl85g866m007y4gkr1v3w30w9"},{"post_id":"cl85g865x00154gkrfjxudrhj","tag_id":"cl85g866e005n4gkrfrj60g7u","_id":"cl85g866n00834gkr8dl947wc"},{"post_id":"cl85g865x00154gkrfjxudrhj","tag_id":"cl85g866l007o4gkr9mci6ve9","_id":"cl85g866n00844gkrfuoc0ryj"},{"post_id":"cl85g865x00154gkrfjxudrhj","tag_id":"cl85g866l007r4gkrbhlw5sl9","_id":"cl85g866n00864gkr18arfumi"},{"post_id":"cl85g865x00154gkrfjxudrhj","tag_id":"cl85g866m00804gkr1ljk8rsi","_id":"cl85g866n00874gkrckkm3uap"},{"post_id":"cl85g865x00154gkrfjxudrhj","tag_id":"cl85g866m00814gkr3wmhgsa8","_id":"cl85g866n00894gkr1jizhku9"},{"post_id":"cl85g865y00174gkr2x3740kp","tag_id":"cl85g866m00824gkrax2h653i","_id":"cl85g866n008b4gkr4vb8eca3"},{"post_id":"cl85g865y00174gkr2x3740kp","tag_id":"cl85g866900354gkrcwyc0t07","_id":"cl85g866o008c4gkreowc345i"},{"post_id":"cl85g865y00174gkr2x3740kp","tag_id":"cl85g866a003k4gkrawmw3d19","_id":"cl85g866o008e4gkrgyv44lf0"},{"post_id":"cl85g865y00194gkrbl9422jq","tag_id":"cl85g866m00824gkrax2h653i","_id":"cl85g866o008h4gkr1xjsaeor"},{"post_id":"cl85g865y00194gkrbl9422jq","tag_id":"cl85g866o008d4gkr3ony5gt6","_id":"cl85g866o008i4gkr38rtgyvu"},{"post_id":"cl85g865y00194gkrbl9422jq","tag_id":"cl85g866o008f4gkrchxi0okk","_id":"cl85g866p008k4gkr36630owl"},{"post_id":"cl85g865z001d4gkrhndx6250","tag_id":"cl85g866o008f4gkrchxi0okk","_id":"cl85g866p008m4gkredtmcil9"},{"post_id":"cl85g865z001d4gkrhndx6250","tag_id":"cl85g866o008j4gkrebwt2n9f","_id":"cl85g866p008n4gkrdqb6b25f"},{"post_id":"cl85g865z001d4gkrhndx6250","tag_id":"cl85g865o000b4gkr7z6he3rc","_id":"cl85g866p008p4gkr3ea1hf55"},{"post_id":"cl85g8660001f4gkrd9x3gder","tag_id":"cl85g866e005n4gkrfrj60g7u","_id":"cl85g866p008s4gkr794k0j8x"},{"post_id":"cl85g8660001f4gkrd9x3gder","tag_id":"cl85g866p008o4gkr6z0966hn","_id":"cl85g866p008t4gkr88mabxxk"},{"post_id":"cl85g8660001f4gkrd9x3gder","tag_id":"cl85g866p008q4gkr91m9gl43","_id":"cl85g866p008v4gkr2pxqb0tz"},{"post_id":"cl85g8660001k4gkrd5xgg0vj","tag_id":"cl85g866e005n4gkrfrj60g7u","_id":"cl85g866p008y4gkr33ax4yxr"},{"post_id":"cl85g8660001k4gkrd5xgg0vj","tag_id":"cl85g866o008d4gkr3ony5gt6","_id":"cl85g866q008z4gkrht5m4otl"},{"post_id":"cl85g8660001k4gkrd5xgg0vj","tag_id":"cl85g866p008w4gkr41gt5n2h","_id":"cl85g866q00914gkr338jecgg"},{"post_id":"cl85g8661001n4gkrcs8f61c7","tag_id":"cl85g866e005n4gkrfrj60g7u","_id":"cl85g866q00964gkr05iq43tc"},{"post_id":"cl85g8661001n4gkrcs8f61c7","tag_id":"cl85g866q00904gkr1dnqbv82","_id":"cl85g866q00974gkr2dt9gkjg"},{"post_id":"cl85g8661001n4gkrcs8f61c7","tag_id":"cl85g866q00924gkr8jtwbm5h","_id":"cl85g866q00994gkrb4s92x9d"},{"post_id":"cl85g8661001n4gkrcs8f61c7","tag_id":"cl85g866q00934gkr71k285ga","_id":"cl85g866q009a4gkrecs2bt71"},{"post_id":"cl85g8661001n4gkrcs8f61c7","tag_id":"cl85g866q00944gkr64lo51ez","_id":"cl85g866q009c4gkr7t4i0ix7"},{"post_id":"cl85g8662001q4gkr1hms43aw","tag_id":"cl85g866a003k4gkrawmw3d19","_id":"cl85g866r009f4gkr9zodb8sc"},{"post_id":"cl85g8662001q4gkr1hms43aw","tag_id":"cl85g866q00904gkr1dnqbv82","_id":"cl85g866r009g4gkrd8a29bj9"},{"post_id":"cl85g8662001q4gkr1hms43aw","tag_id":"cl85g866q00924gkr8jtwbm5h","_id":"cl85g866r009h4gkr7yt25vx3"},{"post_id":"cl85g8662001q4gkr1hms43aw","tag_id":"cl85g866q00934gkr71k285ga","_id":"cl85g866r009i4gkr7e094bju"},{"post_id":"cl85g8662001q4gkr1hms43aw","tag_id":"cl85g866q009e4gkre1i94jba","_id":"cl85g866r009j4gkr30970fqx"},{"post_id":"cl85g866s009k4gkrbqwpdz0o","tag_id":"cl85g866t009n4gkr7n4v94x8","_id":"cl85g866u009s4gkr9y22g942"},{"post_id":"cl85g866t009l4gkr42qrda4h","tag_id":"cl85g866u009r4gkr3uoce6u1","_id":"cl85g866u009v4gkrgozfd2p0"},{"post_id":"cl85g866t009o4gkr8rky0p3j","tag_id":"cl85g866u009u4gkrcezba1xo","_id":"cl85g866u009x4gkr5djzh87o"}],"Tag":[{"name":"Tech","_id":"cl85g865l00054gkrcs4f629y"},{"name":"evolution","_id":"cl85g865o000b4gkr7z6he3rc"},{"name":"mathematical modeling","_id":"cl85g865q000g4gkr8nv1fe4g"},{"name":"diversity-dependence","_id":"cl85g865s000k4gkr0wya7xz7"},{"name":"the Fokker-Planck equation","_id":"cl85g865u000o4gkr62nudqa3"},{"name":"stochastic differential equation","_id":"cl85g865v000v4gkr0ogx5hhp"},{"name":"math","_id":"cl85g865y00164gkr0qyba2r6"},{"name":"phylogeny","_id":"cl85g865z001b4gkrhz7if4k5"},{"name":"phylo class","_id":"cl85g8660001j4gkrcif42mh3"},{"name":"L table","_id":"cl85g8662001r4gkr58x5784x"},{"name":"DDD package","_id":"cl85g8663001u4gkr9akn56z4"},{"name":"pruneL","_id":"cl85g8663001y4gkrd16h6mqp"},{"name":"phylo2L","_id":"cl85g866400214gkrb2gpepd8"},{"name":"regression","_id":"cl85g8667002l4gkr7pr96al5"},{"name":"least square method","_id":"cl85g8668002p4gkr4dj880qd"},{"name":"partial least square","_id":"cl85g8668002t4gkr0whd1kdz"},{"name":"machine learning","_id":"cl85g8668002z4gkr7srs0o85"},{"name":"project 3","_id":"cl85g866900314gkreqjacg3v"},{"name":"bash","_id":"cl85g866900354gkrcwyc0t07"},{"name":"mega data","_id":"cl85g8669003b4gkred5x7ki7"},{"name":"extract information","_id":"cl85g866a003g4gkr1g214dh4"},{"name":"R","_id":"cl85g866a003k4gkrawmw3d19"},{"name":"update","_id":"cl85g866a003o4gkr4ztb503w"},{"name":"packages","_id":"cl85g866a003u4gkrgr4b6j69"},{"name":"color","_id":"cl85g866b00444gkr81883sxh"},{"name":"python","_id":"cl85g866b00484gkr9y756pkg"},{"name":"plot","_id":"cl85g866c004d4gkr79bhax9g"},{"name":"ggplot","_id":"cl85g866c004o4gkrck5m9kj7"},{"name":"ggradar2","_id":"cl85g866d004u4gkrdzf88iaf"},{"name":"Data visualization","_id":"cl85g866d004y4gkr6ble7fhs"},{"name":"SMC","_id":"cl85g866e005f4gkr9q2eevn0"},{"name":"Python","_id":"cl85g866e005n4gkrfrj60g7u"},{"name":"CUDA","_id":"cl85g866f005t4gkrffl9h3u9"},{"name":"GPU programming","_id":"cl85g866f005z4gkrfqd67775"},{"name":"Parallel computation","_id":"cl85g866f00644gkr6r88hgtb"},{"name":"help document","_id":"cl85g866h006n4gkr6mpp921h"},{"name":"Machine learning","_id":"cl85g866l007o4gkr9mci6ve9"},{"name":"neural networks","_id":"cl85g866l007r4gkrbhlw5sl9"},{"name":"Backward propagation","_id":"cl85g866m00804gkr1ljk8rsi"},{"name":"gradient descent","_id":"cl85g866m00814gkr3wmhgsa8"},{"name":"data analysis","_id":"cl85g866m00824gkrax2h653i"},{"name":"ABC","_id":"cl85g866o008d4gkr3ony5gt6"},{"name":"Animation","_id":"cl85g866o008f4gkrchxi0okk"},{"name":"ecology","_id":"cl85g866o008j4gkrebwt2n9f"},{"name":"GUI","_id":"cl85g866p008o4gkr6z0966hn"},{"name":"models","_id":"cl85g866p008q4gkr91m9gl43"},{"name":"algorithm","_id":"cl85g866p008w4gkr41gt5n2h"},{"name":"simulation","_id":"cl85g866q00904gkr1dnqbv82"},{"name":"coronavirus","_id":"cl85g866q00924gkr8jtwbm5h"},{"name":"pandemic","_id":"cl85g866q00934gkr71k285ga"},{"name":"government measure","_id":"cl85g866q00944gkr64lo51ez"},{"name":"data visualization","_id":"cl85g866q009e4gkre1i94jba"},{"name":"Postdoc","_id":"cl85g866t009n4gkr7n4v94x8"},{"name":"Blender","_id":"cl85g866u009r4gkr3uoce6u1"},{"name":"info","_id":"cl85g866u009u4gkrcezba1xo"}]}}